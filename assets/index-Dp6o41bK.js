(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config)
        "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config ? config : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var react = { exports: {} };
var react_production = {};
var hasRequiredReact_production;
function requireReact_production() {
  if (hasRequiredReact_production) return react_production;
  hasRequiredReact_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var ReactNoopUpdateQueue = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, assign = Object.assign, emptyObject = {};
  function Component(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function(partialState, callback) {
    if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  function ComponentDummy() {
  }
  ComponentDummy.prototype = Component.prototype;
  function PureComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent;
  assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;
  var isArrayImpl = Array.isArray;
  function noop() {
  }
  var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
  function ReactElement(type, key, props) {
    var refProp = props.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== refProp ? refProp : null,
      props
    };
  }
  function cloneAndReplaceKey(oldElement, newKey) {
    return ReactElement(oldElement.type, newKey, oldElement.props);
  }
  function isValidElement(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function escape(key) {
    var escaperLookup = { "=": "=0", ":": "=2" };
    return "$" + key.replace(/[=:]/g, function(match) {
      return escaperLookup[match];
    });
  }
  var userProvidedKeyEscapeRegex = /\/+/g;
  function getElementKey(element, index) {
    return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
  }
  function resolveThenable(thenable) {
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
          function(fulfilledValue) {
            "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          },
          function(error) {
            "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
          }
        )), thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
    }
    throw thenable;
  }
  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
    var type = typeof children;
    if ("undefined" === type || "boolean" === type) children = null;
    var invokeCallback = false;
    if (null === children) invokeCallback = true;
    else
      switch (type) {
        case "bigint":
        case "string":
        case "number":
          invokeCallback = true;
          break;
        case "object":
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = true;
              break;
            case REACT_LAZY_TYPE:
              return invokeCallback = children._init, mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
          }
      }
    if (invokeCallback)
      return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
        return c2;
      })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
        callback,
        escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
          userProvidedKeyEscapeRegex,
          "$&/"
        ) + "/") + invokeCallback
      )), array.push(callback)), 1;
    invokeCallback = 0;
    var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
    if (isArrayImpl(children))
      for (var i2 = 0; i2 < children.length; i2++)
        nameSoFar = children[i2], type = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        );
    else if (i2 = getIteratorFn(children), "function" === typeof i2)
      for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
        nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        );
    else if ("object" === type) {
      if ("function" === typeof children.then)
        return mapIntoArray(
          resolveThenable(children),
          array,
          escapedPrefix,
          nameSoFar,
          callback
        );
      array = String(children);
      throw Error(
        "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return invokeCallback;
  }
  function mapChildren(children, func, context) {
    if (null == children) return children;
    var result = [], count = 0;
    mapIntoArray(children, result, "", "", function(child) {
      return func.call(context, child, count++);
    });
    return result;
  }
  function lazyInitializer(payload) {
    if (-1 === payload._status) {
      var ctor = payload._result;
      ctor = ctor();
      ctor.then(
        function(moduleObject) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 1, payload._result = moduleObject;
        },
        function(error) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 2, payload._result = error;
        }
      );
      -1 === payload._status && (payload._status = 0, payload._result = ctor);
    }
    if (1 === payload._status) return payload._result.default;
    throw payload._result;
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  }, Children = {
    map: mapChildren,
    forEach: function(children, forEachFunc, forEachContext) {
      mapChildren(
        children,
        function() {
          forEachFunc.apply(this, arguments);
        },
        forEachContext
      );
    },
    count: function(children) {
      var n2 = 0;
      mapChildren(children, function() {
        n2++;
      });
      return n2;
    },
    toArray: function(children) {
      return mapChildren(children, function(child) {
        return child;
      }) || [];
    },
    only: function(children) {
      if (!isValidElement(children))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return children;
    }
  };
  react_production.Activity = REACT_ACTIVITY_TYPE;
  react_production.Children = Children;
  react_production.Component = Component;
  react_production.Fragment = REACT_FRAGMENT_TYPE;
  react_production.Profiler = REACT_PROFILER_TYPE;
  react_production.PureComponent = PureComponent;
  react_production.StrictMode = REACT_STRICT_MODE_TYPE;
  react_production.Suspense = REACT_SUSPENSE_TYPE;
  react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
  react_production.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(size) {
      return ReactSharedInternals.H.useMemoCache(size);
    }
  };
  react_production.cache = function(fn) {
    return function() {
      return fn.apply(null, arguments);
    };
  };
  react_production.cacheSignal = function() {
    return null;
  };
  react_production.cloneElement = function(element, config, children) {
    if (null === element || void 0 === element)
      throw Error(
        "The argument must be a React element, but you passed " + element + "."
      );
    var props = assign({}, element.props), key = element.key;
    if (null != config)
      for (propName in void 0 !== config.key && (key = "" + config.key), config)
        !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
    var propName = arguments.length - 2;
    if (1 === propName) props.children = children;
    else if (1 < propName) {
      for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
        childArray[i2] = arguments[i2 + 2];
      props.children = childArray;
    }
    return ReactElement(element.type, key, props);
  };
  react_production.createContext = function(defaultValue) {
    defaultValue = {
      $$typeof: REACT_CONTEXT_TYPE,
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    defaultValue.Provider = defaultValue;
    defaultValue.Consumer = {
      $$typeof: REACT_CONSUMER_TYPE,
      _context: defaultValue
    };
    return defaultValue;
  };
  react_production.createElement = function(type, config, children) {
    var propName, props = {}, key = null;
    if (null != config)
      for (propName in void 0 !== config.key && (key = "" + config.key), config)
        hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
    var childrenLength = arguments.length - 2;
    if (1 === childrenLength) props.children = children;
    else if (1 < childrenLength) {
      for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
        childArray[i2] = arguments[i2 + 2];
      props.children = childArray;
    }
    if (type && type.defaultProps)
      for (propName in childrenLength = type.defaultProps, childrenLength)
        void 0 === props[propName] && (props[propName] = childrenLength[propName]);
    return ReactElement(type, key, props);
  };
  react_production.createRef = function() {
    return { current: null };
  };
  react_production.forwardRef = function(render) {
    return { $$typeof: REACT_FORWARD_REF_TYPE, render };
  };
  react_production.isValidElement = isValidElement;
  react_production.lazy = function(ctor) {
    return {
      $$typeof: REACT_LAZY_TYPE,
      _payload: { _status: -1, _result: ctor },
      _init: lazyInitializer
    };
  };
  react_production.memo = function(type, compare) {
    return {
      $$typeof: REACT_MEMO_TYPE,
      type,
      compare: void 0 === compare ? null : compare
    };
  };
  react_production.startTransition = function(scope) {
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
    } catch (error) {
      reportGlobalError(error);
    } finally {
      null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
    }
  };
  react_production.unstable_useCacheRefresh = function() {
    return ReactSharedInternals.H.useCacheRefresh();
  };
  react_production.use = function(usable) {
    return ReactSharedInternals.H.use(usable);
  };
  react_production.useActionState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useActionState(action, initialState, permalink);
  };
  react_production.useCallback = function(callback, deps) {
    return ReactSharedInternals.H.useCallback(callback, deps);
  };
  react_production.useContext = function(Context) {
    return ReactSharedInternals.H.useContext(Context);
  };
  react_production.useDebugValue = function() {
  };
  react_production.useDeferredValue = function(value, initialValue) {
    return ReactSharedInternals.H.useDeferredValue(value, initialValue);
  };
  react_production.useEffect = function(create, deps) {
    return ReactSharedInternals.H.useEffect(create, deps);
  };
  react_production.useEffectEvent = function(callback) {
    return ReactSharedInternals.H.useEffectEvent(callback);
  };
  react_production.useId = function() {
    return ReactSharedInternals.H.useId();
  };
  react_production.useImperativeHandle = function(ref, create, deps) {
    return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
  };
  react_production.useInsertionEffect = function(create, deps) {
    return ReactSharedInternals.H.useInsertionEffect(create, deps);
  };
  react_production.useLayoutEffect = function(create, deps) {
    return ReactSharedInternals.H.useLayoutEffect(create, deps);
  };
  react_production.useMemo = function(create, deps) {
    return ReactSharedInternals.H.useMemo(create, deps);
  };
  react_production.useOptimistic = function(passthrough, reducer) {
    return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
  };
  react_production.useReducer = function(reducer, initialArg, init) {
    return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
  };
  react_production.useRef = function(initialValue) {
    return ReactSharedInternals.H.useRef(initialValue);
  };
  react_production.useState = function(initialState) {
    return ReactSharedInternals.H.useState(initialState);
  };
  react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
    return ReactSharedInternals.H.useSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot
    );
  };
  react_production.useTransition = function() {
    return ReactSharedInternals.H.useTransition();
  };
  react_production.version = "19.2.3";
  return react_production;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production();
  }
  return react.exports;
}
var reactExports = requireReact();
var client = { exports: {} };
var reactDomClient_production = {};
var scheduler = { exports: {} };
var scheduler_production = {};
var hasRequiredScheduler_production;
function requireScheduler_production() {
  if (hasRequiredScheduler_production) return scheduler_production;
  hasRequiredScheduler_production = 1;
  (function(exports$1) {
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index; ) {
        var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
        if (0 < compare(parent, node))
          heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
          var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
          else if (rightIndex < length && 0 > compare(right, last))
            heap[index] = right, heap[rightIndex] = last, index = rightIndex;
          else break a;
        }
      }
      return first;
    }
    function compare(a2, b2) {
      var diff = a2.sortIndex - b2.sortIndex;
      return 0 !== diff ? diff : a2.id - b2.id;
    }
    exports$1.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      exports$1.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports$1.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    function shouldYieldToHost() {
      return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
    }
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports$1.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports$1.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports$1.unstable_now());
      }, ms);
    }
    exports$1.unstable_IdlePriority = 5;
    exports$1.unstable_ImmediatePriority = 1;
    exports$1.unstable_LowPriority = 4;
    exports$1.unstable_NormalPriority = 3;
    exports$1.unstable_Profiling = null;
    exports$1.unstable_UserBlockingPriority = 2;
    exports$1.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports$1.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports$1.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports$1.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports$1.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports$1.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports$1.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports$1.unstable_shouldYield = shouldYieldToHost;
    exports$1.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  })(scheduler_production);
  return scheduler_production;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production();
  }
  return scheduler.exports;
}
var reactDom = { exports: {} };
var reactDom_production = {};
var hasRequiredReactDom_production;
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var React = requireReact();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i2 = 2; i2 < arguments.length; i2++)
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function noop() {
  }
  var Internals = {
    d: {
      f: noop,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children,
      containerInfo,
      implementation
    };
  }
  var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as, input) {
    if ("font" === as) return "";
    if ("string" === typeof input)
      return "use-credentials" === input ? input : "";
  }
  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  reactDom_production.createPortal = function(children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
      throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  reactDom_production.flushSync = function(fn) {
    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  reactDom_production.preconnect = function(href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  reactDom_production.prefetchDNS = function(href) {
    "string" === typeof href && Internals.d.D(href);
  };
  reactDom_production.preinit = function(href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as ? Internals.d.S(
        href,
        "string" === typeof options.precedence ? options.precedence : void 0,
        {
          crossOrigin,
          integrity,
          fetchPriority
        }
      ) : "script" === as && Internals.d.X(href, {
        crossOrigin,
        integrity,
        fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  reactDom_production.preinitModule = function(href, options) {
    if ("string" === typeof href)
      if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          );
          Internals.d.M(href, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      } else null == options && Internals.d.M(href);
  };
  reactDom_production.preload = function(href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
      Internals.d.L(href, as, {
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  reactDom_production.preloadModule = function(href, options) {
    if ("string" === typeof href)
      if (options) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        });
      } else Internals.d.m(href);
  };
  reactDom_production.requestFormReset = function(form) {
    Internals.d.r(form);
  };
  reactDom_production.unstable_batchedUpdates = function(fn, a2) {
    return fn(a2);
  };
  reactDom_production.useFormState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action, initialState, permalink);
  };
  reactDom_production.useFormStatus = function() {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  reactDom_production.version = "19.2.3";
  return reactDom_production;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production();
  }
  return reactDom.exports;
}
var hasRequiredReactDomClient_production;
function requireReactDomClient_production() {
  if (hasRequiredReactDomClient_production) return reactDomClient_production;
  hasRequiredReactDomClient_production = 1;
  var Scheduler = requireScheduler(), React = requireReact(), ReactDOM = requireReactDom();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i2 = 2; i2 < arguments.length; i2++)
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function isValidContainer(node) {
    return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
  }
  function getNearestMountedFiber(fiber) {
    var node = fiber, nearestMounted = fiber;
    if (fiber.alternate) for (; node.return; ) node = node.return;
    else {
      fiber = node;
      do
        node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
      while (fiber);
    }
    return 3 === node.tag ? nearestMounted : null;
  }
  function getSuspenseInstanceFromFiber(fiber) {
    if (13 === fiber.tag) {
      var suspenseState = fiber.memoizedState;
      null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
      if (null !== suspenseState) return suspenseState.dehydrated;
    }
    return null;
  }
  function getActivityInstanceFromFiber(fiber) {
    if (31 === fiber.tag) {
      var activityState = fiber.memoizedState;
      null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
      if (null !== activityState) return activityState.dehydrated;
    }
    return null;
  }
  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber)
      throw Error(formatProdErrorMessage(188));
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      alternate = getNearestMountedFiber(fiber);
      if (null === alternate) throw Error(formatProdErrorMessage(188));
      return alternate !== fiber ? null : fiber;
    }
    for (var a2 = fiber, b2 = alternate; ; ) {
      var parentA = a2.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;
      if (null === parentB) {
        b2 = parentA.return;
        if (null !== b2) {
          a2 = b2;
          continue;
        }
        break;
      }
      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB; ) {
          if (parentB === a2) return assertIsMounted(parentA), fiber;
          if (parentB === b2) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }
        throw Error(formatProdErrorMessage(188));
      }
      if (a2.return !== b2.return) a2 = parentA, b2 = parentB;
      else {
        for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
          if (child$0 === a2) {
            didFindChild = true;
            a2 = parentA;
            b2 = parentB;
            break;
          }
          if (child$0 === b2) {
            didFindChild = true;
            b2 = parentA;
            a2 = parentB;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) {
          for (child$0 = parentB.child; child$0; ) {
            if (child$0 === a2) {
              didFindChild = true;
              a2 = parentB;
              b2 = parentA;
              break;
            }
            if (child$0 === b2) {
              didFindChild = true;
              b2 = parentB;
              a2 = parentA;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) throw Error(formatProdErrorMessage(189));
        }
      }
      if (a2.alternate !== b2) throw Error(formatProdErrorMessage(190));
    }
    if (3 !== a2.tag) throw Error(formatProdErrorMessage(188));
    return a2.stateNode.current === a2 ? fiber : alternate;
  }
  function findCurrentHostFiberImpl(node) {
    var tag = node.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
    for (node = node.child; null !== node; ) {
      tag = findCurrentHostFiberImpl(node);
      if (null !== tag) return tag;
      node = node.sibling;
    }
    return null;
  }
  var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
  var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
  var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
      case REACT_ACTIVITY_TYPE:
        return "Activity";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return type.displayName || "Context";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x2) {
          }
      }
    return null;
  }
  var isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
    pending: false,
    data: null,
    method: null,
    action: null
  }, valueStack = [], index = -1;
  function createCursor(defaultValue) {
    return { current: defaultValue };
  }
  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }
  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }
  var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance);
    push(contextFiberStackCursor, fiber);
    push(contextStackCursor, null);
    switch (nextRootInstance.nodeType) {
      case 9:
      case 11:
        fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
        break;
      default:
        if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
          nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
        else
          switch (fiber) {
            case "svg":
              fiber = 1;
              break;
            case "math":
              fiber = 2;
              break;
            default:
              fiber = 0;
          }
    }
    pop(contextStackCursor);
    push(contextStackCursor, fiber);
  }
  function popHostContainer() {
    pop(contextStackCursor);
    pop(contextFiberStackCursor);
    pop(rootInstanceStackCursor);
  }
  function pushHostContext(fiber) {
    null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
    var context = contextStackCursor.current;
    var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
    context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
  }
  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
    hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
  }
  var prefix, suffix;
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix)
      try {
        throw Error();
      } catch (x2) {
        var match = x2.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return "\n" + prefix + name + suffix;
  }
  var reentry = false;
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: function() {
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x2) {
                  var control = x2;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$1) {
                  control = x$1;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$2) {
                control = x$2;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
              });
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack)
              return [sample.stack, control.stack];
          }
          return [null, null];
        }
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name"
      );
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
          RunInRootFrame++;
        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        ); )
          namePropDescriptor++;
        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
          for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
            namePropDescriptor--;
        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
          if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
              do
                if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                  var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                  fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                  return frame;
                }
              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
            }
            break;
          }
      }
    } finally {
      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
    }
    return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
  }
  function describeFiber(fiber, childFiber) {
    switch (fiber.tag) {
      case 26:
      case 27:
      case 5:
        return describeBuiltInComponentFrame(fiber.type);
      case 16:
        return describeBuiltInComponentFrame("Lazy");
      case 13:
        return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
      case 19:
        return describeBuiltInComponentFrame("SuspenseList");
      case 0:
      case 15:
        return describeNativeComponentFrame(fiber.type, false);
      case 11:
        return describeNativeComponentFrame(fiber.type.render, false);
      case 1:
        return describeNativeComponentFrame(fiber.type, true);
      case 31:
        return describeBuiltInComponentFrame("Activity");
      default:
        return "";
    }
  }
  function getStackByFiberInDevAndProd(workInProgress2) {
    try {
      var info = "", previous = null;
      do
        info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
      while (workInProgress2);
      return info;
    } catch (x2) {
      return "\nError generating stack: " + x2.message + "\n" + x2.stack;
    }
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
  function setIsStrictModeForDevtools(newIsStrictMode) {
    "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
    if (injectedHook && "function" === typeof injectedHook.setStrictMode)
      try {
        injectedHook.setStrictMode(rendererID, newIsStrictMode);
      } catch (err) {
      }
  }
  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
  function clz32Fallback(x2) {
    x2 >>>= 0;
    return 0 === x2 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
  }
  var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
  function getHighestPriorityLanes(lanes) {
    var pendingSyncLanes = lanes & 42;
    if (0 !== pendingSyncLanes) return pendingSyncLanes;
    switch (lanes & -lanes) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return lanes & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return lanes & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return lanes & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return lanes;
    }
  }
  function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
    var pendingLanes = root2.pendingLanes;
    if (0 === pendingLanes) return 0;
    var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
    root2 = root2.warmLanes;
    var nonIdlePendingLanes = pendingLanes & 134217727;
    0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
    return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
  }
  function checkIfRootIsPrerendering(root2, renderLanes2) {
    return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
  }
  function computeExpirationTime(lane, currentTime) {
    switch (lane) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return currentTime + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return currentTime + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function claimNextRetryLane() {
    var lane = nextRetryLane;
    nextRetryLane <<= 1;
    0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
    return lane;
  }
  function createLaneMap(initial) {
    for (var laneMap = [], i2 = 0; 31 > i2; i2++) laneMap.push(initial);
    return laneMap;
  }
  function markRootUpdated$1(root2, updateLane) {
    root2.pendingLanes |= updateLane;
    268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
  }
  function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
    var previouslyPendingLanes = root2.pendingLanes;
    root2.pendingLanes = remainingLanes;
    root2.suspendedLanes = 0;
    root2.pingedLanes = 0;
    root2.warmLanes = 0;
    root2.expiredLanes &= remainingLanes;
    root2.entangledLanes &= remainingLanes;
    root2.errorRecoveryDisabledLanes &= remainingLanes;
    root2.shellSuspendCounter = 0;
    var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
    for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
      var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
      entanglements[index$7] = 0;
      expirationTimes[index$7] = -1;
      var hiddenUpdatesForLane = hiddenUpdates[index$7];
      if (null !== hiddenUpdatesForLane)
        for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
          var update = hiddenUpdatesForLane[index$7];
          null !== update && (update.lane &= -536870913);
        }
      remainingLanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
    0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
  }
  function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
    root2.pendingLanes |= spawnedLane;
    root2.suspendedLanes &= ~spawnedLane;
    var spawnedLaneIndex = 31 - clz32(spawnedLane);
    root2.entangledLanes |= spawnedLane;
    root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
  }
  function markRootEntangled(root2, entangledLanes) {
    var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
    for (root2 = root2.entanglements; rootEntangledLanes; ) {
      var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
      lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
      rootEntangledLanes &= ~lane;
    }
  }
  function getBumpedLaneForHydration(root2, renderLanes2) {
    var renderLane = renderLanes2 & -renderLanes2;
    renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
    return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
  }
  function getBumpedLaneForHydrationByLane(lane) {
    switch (lane) {
      case 2:
        lane = 1;
        break;
      case 8:
        lane = 4;
        break;
      case 32:
        lane = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        lane = 128;
        break;
      case 268435456:
        lane = 134217728;
        break;
      default:
        lane = 0;
    }
    return lane;
  }
  function lanesToEventPriority(lanes) {
    lanes &= -lanes;
    return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
  }
  function resolveUpdatePriority() {
    var updatePriority = ReactDOMSharedInternals.p;
    if (0 !== updatePriority) return updatePriority;
    updatePriority = window.event;
    return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
  }
  function runWithPriority(priority, fn) {
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      return ReactDOMSharedInternals.p = priority, fn();
    } finally {
      ReactDOMSharedInternals.p = previousPriority;
    }
  }
  var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
  function detachDeletedInstance(node) {
    delete node[internalInstanceKey];
    delete node[internalPropsKey];
    delete node[internalEventHandlersKey];
    delete node[internalEventHandlerListenersKey];
    delete node[internalEventHandlesSetKey];
  }
  function getClosestInstanceFromNode(targetNode) {
    var targetInst = targetNode[internalInstanceKey];
    if (targetInst) return targetInst;
    for (var parentNode = targetNode.parentNode; parentNode; ) {
      if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
        parentNode = targetInst.alternate;
        if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
          for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
            if (parentNode = targetNode[internalInstanceKey]) return parentNode;
            targetNode = getParentHydrationBoundary(targetNode);
          }
        return targetInst;
      }
      targetNode = parentNode;
      parentNode = targetNode.parentNode;
    }
    return null;
  }
  function getInstanceFromNode(node) {
    if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
      var tag = node.tag;
      if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
        return node;
    }
    return null;
  }
  function getNodeFromInstance(inst) {
    var tag = inst.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
    throw Error(formatProdErrorMessage(33));
  }
  function getResourcesFromRoot(root2) {
    var resources = root2[internalRootNodeResourcesKey];
    resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
    return resources;
  }
  function markNodeAsHoistable(node) {
    node[internalHoistableMarker] = true;
  }
  var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
  function registerTwoPhaseEvent(registrationName, dependencies) {
    registerDirectEvent(registrationName, dependencies);
    registerDirectEvent(registrationName + "Capture", dependencies);
  }
  function registerDirectEvent(registrationName, dependencies) {
    registrationNameDependencies[registrationName] = dependencies;
    for (registrationName = 0; registrationName < dependencies.length; registrationName++)
      allNativeEvents.add(dependencies[registrationName]);
  }
  var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
      return true;
    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
      return validatedAttributeNameCache[attributeName] = true;
    illegalAttributeNameCache[attributeName] = true;
    return false;
  }
  function setValueForAttribute(node, name, value) {
    if (isAttributeNameSafe(name))
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            node.removeAttribute(name);
            return;
          case "boolean":
            var prefix$10 = name.toLowerCase().slice(0, 5);
            if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
              node.removeAttribute(name);
              return;
            }
        }
        node.setAttribute(name, "" + value);
      }
  }
  function setValueForKnownAttribute(node, name, value) {
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttribute(name, "" + value);
    }
  }
  function setValueForNamespacedAttribute(node, namespace, name, value) {
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttributeNS(namespace, name, "" + value);
    }
  }
  function getToStringValue(value) {
    switch (typeof value) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return value;
      case "object":
        return value;
      default:
        return "";
    }
  }
  function isCheckable(elem) {
    var type = elem.type;
    return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
  }
  function trackValueOnNode(node, valueField, currentValue) {
    var descriptor = Object.getOwnPropertyDescriptor(
      node.constructor.prototype,
      valueField
    );
    if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
      var get = descriptor.get, set = descriptor.set;
      Object.defineProperty(node, valueField, {
        configurable: true,
        get: function() {
          return get.call(this);
        },
        set: function(value) {
          currentValue = "" + value;
          set.call(this, value);
        }
      });
      Object.defineProperty(node, valueField, {
        enumerable: descriptor.enumerable
      });
      return {
        getValue: function() {
          return currentValue;
        },
        setValue: function(value) {
          currentValue = "" + value;
        },
        stopTracking: function() {
          node._valueTracker = null;
          delete node[valueField];
        }
      };
    }
  }
  function track(node) {
    if (!node._valueTracker) {
      var valueField = isCheckable(node) ? "checked" : "value";
      node._valueTracker = trackValueOnNode(
        node,
        valueField,
        "" + node[valueField]
      );
    }
  }
  function updateValueIfChanged(node) {
    if (!node) return false;
    var tracker = node._valueTracker;
    if (!tracker) return true;
    var lastValue = tracker.getValue();
    var value = "";
    node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
    node = value;
    return node !== lastValue ? (tracker.setValue(node), true) : false;
  }
  function getActiveElement(doc) {
    doc = doc || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof doc) return null;
    try {
      return doc.activeElement || doc.body;
    } catch (e2) {
      return doc.body;
    }
  }
  var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
  function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
    return value.replace(
      escapeSelectorAttributeValueInsideDoubleQuotesRegex,
      function(ch) {
        return "\\" + ch.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
    element.name = "";
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
    if (null != value)
      if ("number" === type) {
        if (0 === value && "" === element.value || element.value != value)
          element.value = "" + getToStringValue(value);
      } else
        element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
    else
      "submit" !== type && "reset" !== type || element.removeAttribute("value");
    null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
    null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
    null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
  }
  function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
    if (null != value || null != defaultValue) {
      if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
        track(element);
        return;
      }
      defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      value = null != value ? "" + getToStringValue(value) : defaultValue;
      isHydrating2 || value === element.value || (element.value = value);
      element.defaultValue = value;
    }
    checked = null != checked ? checked : defaultChecked;
    checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
    element.checked = isHydrating2 ? element.checked : !!checked;
    element.defaultChecked = !!checked;
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
    track(element);
  }
  function setDefaultValue(node, type, value) {
    "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
  }
  function updateOptions(node, multiple, propValue, setDefaultSelected) {
    node = node.options;
    if (multiple) {
      multiple = {};
      for (var i2 = 0; i2 < propValue.length; i2++)
        multiple["$" + propValue[i2]] = true;
      for (propValue = 0; propValue < node.length; propValue++)
        i2 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i2 && (node[propValue].selected = i2), i2 && setDefaultSelected && (node[propValue].defaultSelected = true);
    } else {
      propValue = "" + getToStringValue(propValue);
      multiple = null;
      for (i2 = 0; i2 < node.length; i2++) {
        if (node[i2].value === propValue) {
          node[i2].selected = true;
          setDefaultSelected && (node[i2].defaultSelected = true);
          return;
        }
        null !== multiple || node[i2].disabled || (multiple = node[i2]);
      }
      null !== multiple && (multiple.selected = true);
    }
  }
  function updateTextarea(element, value, defaultValue) {
    if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
      element.defaultValue !== value && (element.defaultValue = value);
      return;
    }
    element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
  }
  function initTextarea(element, value, defaultValue, children) {
    if (null == value) {
      if (null != children) {
        if (null != defaultValue) throw Error(formatProdErrorMessage(92));
        if (isArrayImpl(children)) {
          if (1 < children.length) throw Error(formatProdErrorMessage(93));
          children = children[0];
        }
        defaultValue = children;
      }
      null == defaultValue && (defaultValue = "");
      value = defaultValue;
    }
    defaultValue = getToStringValue(value);
    element.defaultValue = defaultValue;
    children = element.textContent;
    children === defaultValue && "" !== children && null !== children && (element.value = children);
    track(element);
  }
  function setTextContent(node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  }
  var unitlessNumbers = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function setValueForStyle(style2, styleName, value) {
    var isCustomProperty = 0 === styleName.indexOf("--");
    null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
  }
  function setValueForStyles(node, styles, prevStyles) {
    if (null != styles && "object" !== typeof styles)
      throw Error(formatProdErrorMessage(62));
    node = node.style;
    if (null != prevStyles) {
      for (var styleName in prevStyles)
        !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
      for (var styleName$16 in styles)
        styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
    } else
      for (var styleName$17 in styles)
        styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
  }
  function isCustomElement(tagName) {
    if (-1 === tagName.indexOf("-")) return false;
    switch (tagName) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var aliases = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function sanitizeURL(url) {
    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
  }
  function noop$1() {
  }
  var currentReplayingEvent = null;
  function getEventTarget(nativeEvent) {
    nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
    nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
    return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
  }
  var restoreTarget = null, restoreQueue = null;
  function restoreStateOfTarget(target) {
    var internalInstance = getInstanceFromNode(target);
    if (internalInstance && (target = internalInstance.stateNode)) {
      var props = target[internalPropsKey] || null;
      a: switch (target = internalInstance.stateNode, internalInstance.type) {
        case "input":
          updateInput(
            target,
            props.value,
            props.defaultValue,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name
          );
          internalInstance = props.name;
          if ("radio" === props.type && null != internalInstance) {
            for (props = target; props.parentNode; ) props = props.parentNode;
            props = props.querySelectorAll(
              'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) + '"][type="radio"]'
            );
            for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
              var otherNode = props[internalInstance];
              if (otherNode !== target && otherNode.form === target.form) {
                var otherProps = otherNode[internalPropsKey] || null;
                if (!otherProps) throw Error(formatProdErrorMessage(90));
                updateInput(
                  otherNode,
                  otherProps.value,
                  otherProps.defaultValue,
                  otherProps.defaultValue,
                  otherProps.checked,
                  otherProps.defaultChecked,
                  otherProps.type,
                  otherProps.name
                );
              }
            }
            for (internalInstance = 0; internalInstance < props.length; internalInstance++)
              otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
          }
          break a;
        case "textarea":
          updateTextarea(target, props.value, props.defaultValue);
          break a;
        case "select":
          internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
      }
    }
  }
  var isInsideEventHandler = false;
  function batchedUpdates$1(fn, a2, b2) {
    if (isInsideEventHandler) return fn(a2, b2);
    isInsideEventHandler = true;
    try {
      var JSCompiler_inline_result = fn(a2);
      return JSCompiler_inline_result;
    } finally {
      if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
        if (flushSyncWork$1(), restoreTarget && (a2 = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a2), fn))
          for (a2 = 0; a2 < fn.length; a2++) restoreStateOfTarget(fn[a2]);
      }
    }
  }
  function getListener(inst, registrationName) {
    var stateNode = inst.stateNode;
    if (null === stateNode) return null;
    var props = stateNode[internalPropsKey] || null;
    if (null === props) return null;
    stateNode = props[registrationName];
    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;
      default:
        inst = false;
    }
    if (inst) return null;
    if (stateNode && "function" !== typeof stateNode)
      throw Error(
        formatProdErrorMessage(231, registrationName, typeof stateNode)
      );
    return stateNode;
  }
  var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
  if (canUseDOM)
    try {
      var options = {};
      Object.defineProperty(options, "passive", {
        get: function() {
          passiveBrowserEventsSupported = true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (e2) {
      passiveBrowserEventsSupported = false;
    }
  var root = null, startText = null, fallbackText = null;
  function getData() {
    if (fallbackText) return fallbackText;
    var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
    for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
    var minEnd = startLength - start;
    for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
    return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
  }
  function getEventCharCode(nativeEvent) {
    var keyCode = nativeEvent.keyCode;
    "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
    10 === nativeEvent && (nativeEvent = 13);
    return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
  }
  function functionThatReturnsTrue() {
    return true;
  }
  function functionThatReturnsFalse() {
    return false;
  }
  function createSyntheticEvent(Interface) {
    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
      this._reactName = reactName;
      this._targetInst = targetInst;
      this.type = reactEventType;
      this.nativeEvent = nativeEvent;
      this.target = nativeEventTarget;
      this.currentTarget = null;
      for (var propName in Interface)
        Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
      this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
      this.isPropagationStopped = functionThatReturnsFalse;
      return this;
    }
    assign(SyntheticBaseEvent.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
      },
      stopPropagation: function() {
        var event = this.nativeEvent;
        event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
      },
      persist: function() {
      },
      isPersistent: functionThatReturnsTrue
    });
    return SyntheticBaseEvent;
  }
  var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function(event) {
      return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
    },
    movementX: function(event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
      return lastMovementX;
    },
    movementY: function(event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function(event) {
      return "clipboardData" in event ? event.clipboardData : window.clipboardData;
    }
  }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function modifierStateGetter(keyArg) {
    var nativeEvent = this.nativeEvent;
    return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
  }
  function getEventModifierState() {
    return modifierStateGetter;
  }
  var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function(nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function(event) {
      return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    },
    which: function(event) {
      return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    }
  }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function(event) {
      return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function(event) {
      return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
  canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
  var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
  function isFallbackCompositionEnd(domEventName, nativeEvent) {
    switch (domEventName) {
      case "keyup":
        return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
      case "keydown":
        return 229 !== nativeEvent.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    nativeEvent = nativeEvent.detail;
    return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
  }
  var isComposing = false;
  function getNativeBeforeInputChars(domEventName, nativeEvent) {
    switch (domEventName) {
      case "compositionend":
        return getDataFromCustomEvent(nativeEvent);
      case "keypress":
        if (32 !== nativeEvent.which) return null;
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case "textInput":
        return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(domEventName, nativeEvent) {
    if (isComposing)
      return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
    switch (domEventName) {
      case "paste":
        return null;
      case "keypress":
        if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
          if (nativeEvent.char && 1 < nativeEvent.char.length)
            return nativeEvent.char;
          if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case "compositionend":
        return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  var supportedInputTypes = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
  }
  function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
    restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
    inst = accumulateTwoPhaseListeners(inst, "onChange");
    0 < inst.length && (nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
  }
  var activeElement$1 = null, activeElementInst$1 = null;
  function runEventInBatch(dispatchQueue) {
    processDispatchQueue(dispatchQueue, 0);
  }
  function getInstIfValueChanged(targetInst) {
    var targetNode = getNodeFromInstance(targetInst);
    if (updateValueIfChanged(targetNode)) return targetInst;
  }
  function getTargetInstForChangeEvent(domEventName, targetInst) {
    if ("change" === domEventName) return targetInst;
  }
  var isInputEventSupported = false;
  if (canUseDOM) {
    var JSCompiler_inline_result$jscomp$286;
    if (canUseDOM) {
      var isSupported$jscomp$inline_427 = "oninput" in document;
      if (!isSupported$jscomp$inline_427) {
        var element$jscomp$inline_428 = document.createElement("div");
        element$jscomp$inline_428.setAttribute("oninput", "return;");
        isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
      }
      JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
    } else JSCompiler_inline_result$jscomp$286 = false;
    isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
  }
  function stopWatchingForValueChange() {
    activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
  }
  function handlePropertyChange(nativeEvent) {
    if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
      var dispatchQueue = [];
      createAndAccumulateChangeEvent(
        dispatchQueue,
        activeElementInst$1,
        nativeEvent,
        getEventTarget(nativeEvent)
      );
      batchedUpdates$1(runEventInBatch, dispatchQueue);
    }
  }
  function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
    "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
  }
  function getTargetInstForInputEventPolyfill(domEventName) {
    if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
      return getInstIfValueChanged(activeElementInst$1);
  }
  function getTargetInstForClickEvent(domEventName, targetInst) {
    if ("click" === domEventName) return getInstIfValueChanged(targetInst);
  }
  function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
    if ("input" === domEventName || "change" === domEventName)
      return getInstIfValueChanged(targetInst);
  }
  function is(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is;
  function shallowEqual(objA, objB) {
    if (objectIs(objA, objB)) return true;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
      return false;
    var keysA = Object.keys(objA), keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for (keysB = 0; keysB < keysA.length; keysB++) {
      var currentKey = keysA[keysB];
      if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
        return false;
    }
    return true;
  }
  function getLeafNode(node) {
    for (; node && node.firstChild; ) node = node.firstChild;
    return node;
  }
  function getNodeForCharacterOffset(root2, offset) {
    var node = getLeafNode(root2);
    root2 = 0;
    for (var nodeEnd; node; ) {
      if (3 === node.nodeType) {
        nodeEnd = root2 + node.textContent.length;
        if (root2 <= offset && nodeEnd >= offset)
          return { node, offset: offset - root2 };
        root2 = nodeEnd;
      }
      a: {
        for (; node; ) {
          if (node.nextSibling) {
            node = node.nextSibling;
            break a;
          }
          node = node.parentNode;
        }
        node = void 0;
      }
      node = getLeafNode(node);
    }
  }
  function containsNode(outerNode, innerNode) {
    return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
  }
  function getActiveElementDeep(containerInfo) {
    containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
    for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
      try {
        var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
      } catch (err) {
        JSCompiler_inline_result = false;
      }
      if (JSCompiler_inline_result) containerInfo = element.contentWindow;
      else break;
      element = getActiveElement(containerInfo.document);
    }
    return element;
  }
  function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
  }
  var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
  function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
    mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
      anchorNode: doc.anchorNode,
      anchorOffset: doc.anchorOffset,
      focusNode: doc.focusNode,
      focusOffset: doc.focusOffset
    }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
      "onSelect",
      "select",
      null,
      nativeEvent,
      nativeEventTarget
    ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
  }
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit" + styleProp] = "webkit" + eventName;
    prefixes["Moz" + styleProp] = "moz" + eventName;
    return prefixes;
  }
  var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  }, prefixedEventNames = {}, style = {};
  canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    if (!vendorPrefixes[eventName]) return eventName;
    var prefixMap = vendorPrefixes[eventName], styleProp;
    for (styleProp in prefixMap)
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
        return prefixedEventNames[eventName] = prefixMap[styleProp];
    return eventName;
  }
  var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  simpleEventPluginEvents.push("scrollEnd");
  function registerSimpleEvent(domEventName, reactName) {
    topLevelEventsToReactNames.set(domEventName, reactName);
    registerTwoPhaseEvent(reactName, [domEventName]);
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
  function finishQueueingConcurrentUpdates() {
    for (var endIndex = concurrentQueuesIndex, i2 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i2 < endIndex; ) {
      var fiber = concurrentQueues[i2];
      concurrentQueues[i2++] = null;
      var queue = concurrentQueues[i2];
      concurrentQueues[i2++] = null;
      var update = concurrentQueues[i2];
      concurrentQueues[i2++] = null;
      var lane = concurrentQueues[i2];
      concurrentQueues[i2++] = null;
      if (null !== queue && null !== update) {
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
    }
  }
  function enqueueUpdate$1(fiber, queue, update, lane) {
    concurrentQueues[concurrentQueuesIndex++] = fiber;
    concurrentQueues[concurrentQueuesIndex++] = queue;
    concurrentQueues[concurrentQueuesIndex++] = update;
    concurrentQueues[concurrentQueuesIndex++] = lane;
    concurrentlyUpdatedLanes |= lane;
    fiber.lanes |= lane;
    fiber = fiber.alternate;
    null !== fiber && (fiber.lanes |= lane);
  }
  function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
    enqueueUpdate$1(fiber, queue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function enqueueConcurrentRenderForLane(fiber, lane) {
    enqueueUpdate$1(fiber, null, null, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
    sourceFiber.lanes |= lane;
    var alternate = sourceFiber.alternate;
    null !== alternate && (alternate.lanes |= lane);
    for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
      parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
    return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
  }
  function getRootForUpdatedFiber(sourceFiber) {
    if (50 < nestedUpdateCount)
      throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
    for (var parent = sourceFiber.return; null !== parent; )
      sourceFiber = parent, parent = sourceFiber.return;
    return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
  }
  var emptyContextObject = {};
  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.refCleanup = this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function createFiberImplClass(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }
  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }
  function createWorkInProgress(current, pendingProps) {
    var workInProgress2 = current.alternate;
    null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
      current.tag,
      pendingProps,
      current.key,
      current.mode
    ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
    workInProgress2.flags = current.flags & 65011712;
    workInProgress2.childLanes = current.childLanes;
    workInProgress2.lanes = current.lanes;
    workInProgress2.child = current.child;
    workInProgress2.memoizedProps = current.memoizedProps;
    workInProgress2.memoizedState = current.memoizedState;
    workInProgress2.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
    workInProgress2.sibling = current.sibling;
    workInProgress2.index = current.index;
    workInProgress2.ref = current.ref;
    workInProgress2.refCleanup = current.refCleanup;
    return workInProgress2;
  }
  function resetWorkInProgress(workInProgress2, renderLanes2) {
    workInProgress2.flags &= 65011714;
    var current = workInProgress2.alternate;
    null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
      lanes: renderLanes2.lanes,
      firstContext: renderLanes2.firstContext
    });
    return workInProgress2;
  }
  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
    var fiberTag = 0;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
    else if ("string" === typeof type)
      fiberTag = isHostHoistableType(
        type,
        pendingProps,
        contextStackCursor.current
      ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
    else
      a: switch (type) {
        case REACT_ACTIVITY_TYPE:
          return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(pendingProps.children, mode, lanes, key);
        case REACT_STRICT_MODE_TYPE:
          fiberTag = 8;
          mode |= 24;
          break;
        case REACT_PROFILER_TYPE:
          return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
        case REACT_SUSPENSE_TYPE:
          return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
        case REACT_SUSPENSE_LIST_TYPE:
          return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
        default:
          if ("object" === typeof type && null !== type)
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                fiberTag = 10;
                break a;
              case REACT_CONSUMER_TYPE:
                fiberTag = 9;
                break a;
              case REACT_FORWARD_REF_TYPE:
                fiberTag = 11;
                break a;
              case REACT_MEMO_TYPE:
                fiberTag = 14;
                break a;
              case REACT_LAZY_TYPE:
                fiberTag = 16;
                owner = null;
                break a;
            }
          fiberTag = 29;
          pendingProps = Error(
            formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
          );
          owner = null;
      }
    key = createFiberImplClass(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.lanes = lanes;
    return key;
  }
  function createFiberFromFragment(elements, mode, lanes, key) {
    elements = createFiberImplClass(7, elements, key, mode);
    elements.lanes = lanes;
    return elements;
  }
  function createFiberFromText(content, mode, lanes) {
    content = createFiberImplClass(6, content, null, mode);
    content.lanes = lanes;
    return content;
  }
  function createFiberFromDehydratedFragment(dehydratedNode) {
    var fiber = createFiberImplClass(18, null, null, 0);
    fiber.stateNode = dehydratedNode;
    return fiber;
  }
  function createFiberFromPortal(portal, mode, lanes) {
    mode = createFiberImplClass(
      4,
      null !== portal.children ? portal.children : [],
      portal.key,
      mode
    );
    mode.lanes = lanes;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }
  var CapturedStacks = /* @__PURE__ */ new WeakMap();
  function createCapturedValueAtFiber(value, source) {
    if ("object" === typeof value && null !== value) {
      var existing = CapturedStacks.get(value);
      if (void 0 !== existing) return existing;
      source = {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
      CapturedStacks.set(value, source);
      return source;
    }
    return {
      value,
      source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
  var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
  function pushTreeFork(workInProgress2, totalChildren) {
    forkStack[forkStackIndex++] = treeForkCount;
    forkStack[forkStackIndex++] = treeForkProvider;
    treeForkProvider = workInProgress2;
    treeForkCount = totalChildren;
  }
  function pushTreeId(workInProgress2, totalChildren, index2) {
    idStack[idStackIndex++] = treeContextId;
    idStack[idStackIndex++] = treeContextOverflow;
    idStack[idStackIndex++] = treeContextProvider;
    treeContextProvider = workInProgress2;
    var baseIdWithLeadingBit = treeContextId;
    workInProgress2 = treeContextOverflow;
    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
    baseIdWithLeadingBit &= ~(1 << baseLength);
    index2 += 1;
    var length = 32 - clz32(totalChildren) + baseLength;
    if (30 < length) {
      var numberOfOverflowBits = baseLength - baseLength % 5;
      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
      baseIdWithLeadingBit >>= numberOfOverflowBits;
      baseLength -= numberOfOverflowBits;
      treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
      treeContextOverflow = length + workInProgress2;
    } else
      treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
  }
  function pushMaterializedTreeId(workInProgress2) {
    null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
  }
  function popTreeContext(workInProgress2) {
    for (; workInProgress2 === treeForkProvider; )
      treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
    for (; workInProgress2 === treeContextProvider; )
      treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
  }
  function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
    idStack[idStackIndex++] = treeContextId;
    idStack[idStackIndex++] = treeContextOverflow;
    idStack[idStackIndex++] = treeContextProvider;
    treeContextId = suspendedContext.id;
    treeContextOverflow = suspendedContext.overflow;
    treeContextProvider = workInProgress2;
  }
  var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
  function throwOnHydrationMismatch(fiber) {
    var error = Error(
      formatProdErrorMessage(
        418,
        1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    queueHydrationError(createCapturedValueAtFiber(error, fiber));
    throw HydrationMismatchException;
  }
  function prepareToHydrateHostInstance(fiber) {
    var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
    instance[internalInstanceKey] = fiber;
    instance[internalPropsKey] = props;
    switch (type) {
      case "dialog":
        listenToNonDelegatedEvent("cancel", instance);
        listenToNonDelegatedEvent("close", instance);
        break;
      case "iframe":
      case "object":
      case "embed":
        listenToNonDelegatedEvent("load", instance);
        break;
      case "video":
      case "audio":
        for (type = 0; type < mediaEventTypes.length; type++)
          listenToNonDelegatedEvent(mediaEventTypes[type], instance);
        break;
      case "source":
        listenToNonDelegatedEvent("error", instance);
        break;
      case "img":
      case "image":
      case "link":
        listenToNonDelegatedEvent("error", instance);
        listenToNonDelegatedEvent("load", instance);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", instance);
        break;
      case "input":
        listenToNonDelegatedEvent("invalid", instance);
        initInput(
          instance,
          props.value,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name,
          true
        );
        break;
      case "select":
        listenToNonDelegatedEvent("invalid", instance);
        break;
      case "textarea":
        listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
    }
    type = props.children;
    "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
    instance || throwOnHydrationMismatch(fiber, true);
  }
  function popToNextHostParent(fiber) {
    for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
      switch (hydrationParentFiber.tag) {
        case 5:
        case 31:
        case 13:
          rootOrSingletonContext = false;
          return;
        case 27:
        case 3:
          rootOrSingletonContext = true;
          return;
        default:
          hydrationParentFiber = hydrationParentFiber.return;
      }
  }
  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) return false;
    if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
    var tag = fiber.tag, JSCompiler_temp;
    if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
      if (JSCompiler_temp = 5 === tag)
        JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
      JSCompiler_temp = !JSCompiler_temp;
    }
    JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
    popToNextHostParent(fiber);
    if (13 === tag) {
      fiber = fiber.memoizedState;
      fiber = null !== fiber ? fiber.dehydrated : null;
      if (!fiber) throw Error(formatProdErrorMessage(317));
      nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
    } else if (31 === tag) {
      fiber = fiber.memoizedState;
      fiber = null !== fiber ? fiber.dehydrated : null;
      if (!fiber) throw Error(formatProdErrorMessage(317));
      nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
    } else
      27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
    return true;
  }
  function resetHydrationState() {
    nextHydratableInstance = hydrationParentFiber = null;
    isHydrating = false;
  }
  function upgradeHydrationErrorsToRecoverable() {
    var queuedErrors = hydrationErrors;
    null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
      workInProgressRootRecoverableErrors,
      queuedErrors
    ), hydrationErrors = null);
    return queuedErrors;
  }
  function queueHydrationError(error) {
    null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
  }
  var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
  function pushProvider(providerFiber, context, nextValue) {
    push(valueCursor, context._currentValue);
    context._currentValue = nextValue;
  }
  function popProvider(context) {
    context._currentValue = valueCursor.current;
    pop(valueCursor);
  }
  function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
    for (; null !== parent; ) {
      var alternate = parent.alternate;
      (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
      if (parent === propagationRoot) break;
      parent = parent.return;
    }
  }
  function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
    var fiber = workInProgress2.child;
    null !== fiber && (fiber.return = workInProgress2);
    for (; null !== fiber; ) {
      var list = fiber.dependencies;
      if (null !== list) {
        var nextFiber = fiber.child;
        list = list.firstContext;
        a: for (; null !== list; ) {
          var dependency = list;
          list = fiber;
          for (var i2 = 0; i2 < contexts.length; i2++)
            if (dependency.context === contexts[i2]) {
              list.lanes |= renderLanes2;
              dependency = list.alternate;
              null !== dependency && (dependency.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                list.return,
                renderLanes2,
                workInProgress2
              );
              forcePropagateEntireTree || (nextFiber = null);
              break a;
            }
          list = dependency.next;
        }
      } else if (18 === fiber.tag) {
        nextFiber = fiber.return;
        if (null === nextFiber) throw Error(formatProdErrorMessage(341));
        nextFiber.lanes |= renderLanes2;
        list = nextFiber.alternate;
        null !== list && (list.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
        nextFiber = null;
      } else nextFiber = fiber.child;
      if (null !== nextFiber) nextFiber.return = fiber;
      else
        for (nextFiber = fiber; null !== nextFiber; ) {
          if (nextFiber === workInProgress2) {
            nextFiber = null;
            break;
          }
          fiber = nextFiber.sibling;
          if (null !== fiber) {
            fiber.return = nextFiber.return;
            nextFiber = fiber;
            break;
          }
          nextFiber = nextFiber.return;
        }
      fiber = nextFiber;
    }
  }
  function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
    current = null;
    for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
      if (!isInsidePropagationBailout) {
        if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
        else if (0 !== (parent.flags & 262144)) break;
      }
      if (10 === parent.tag) {
        var currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent = currentParent.memoizedProps;
        if (null !== currentParent) {
          var context = parent.type;
          objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
        }
      } else if (parent === hostTransitionProviderCursor.current) {
        currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
      }
      parent = parent.return;
    }
    null !== current && propagateContextChanges(
      workInProgress2,
      current,
      renderLanes2,
      forcePropagateEntireTree
    );
    workInProgress2.flags |= 262144;
  }
  function checkIfContextChanged(currentDependencies) {
    for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
      if (!objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      ))
        return true;
      currentDependencies = currentDependencies.next;
    }
    return false;
  }
  function prepareToReadContext(workInProgress2) {
    currentlyRenderingFiber$1 = workInProgress2;
    lastContextDependency = null;
    workInProgress2 = workInProgress2.dependencies;
    null !== workInProgress2 && (workInProgress2.firstContext = null);
  }
  function readContext(context) {
    return readContextForConsumer(currentlyRenderingFiber$1, context);
  }
  function readContextDuringReconciliation(consumer, context) {
    null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
    return readContextForConsumer(consumer, context);
  }
  function readContextForConsumer(consumer, context) {
    var value = context._currentValue;
    context = { context, memoizedValue: value, next: null };
    if (null === lastContextDependency) {
      if (null === consumer) throw Error(formatProdErrorMessage(308));
      lastContextDependency = context;
      consumer.dependencies = { lanes: 0, firstContext: context };
      consumer.flags |= 524288;
    } else lastContextDependency = lastContextDependency.next = context;
    return value;
  }
  var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
    var listeners = [], signal = this.signal = {
      aborted: false,
      addEventListener: function(type, listener) {
        listeners.push(listener);
      }
    };
    this.abort = function() {
      signal.aborted = true;
      listeners.forEach(function(listener) {
        return listener();
      });
    };
  }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function createCache() {
    return {
      controller: new AbortControllerLocal(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function releaseCache(cache) {
    cache.refCount--;
    0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
      cache.controller.abort();
    });
  }
  var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
  function entangleAsyncAction(transition, thenable) {
    if (null === currentEntangledListeners) {
      var entangledListeners = currentEntangledListeners = [];
      currentEntangledPendingCount = 0;
      currentEntangledLane = requestTransitionLane();
      currentEntangledActionThenable = {
        status: "pending",
        value: void 0,
        then: function(resolve) {
          entangledListeners.push(resolve);
        }
      };
    }
    currentEntangledPendingCount++;
    thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
    return thenable;
  }
  function pingEngtangledActionScope() {
    if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
      null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
      var listeners = currentEntangledListeners;
      currentEntangledListeners = null;
      currentEntangledLane = 0;
      currentEntangledActionThenable = null;
      for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])();
    }
  }
  function chainThenableValue(thenable, result) {
    var listeners = [], thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function(resolve) {
        listeners.push(resolve);
      }
    };
    thenable.then(
      function() {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])(result);
      },
      function(error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0; error < listeners.length; error++)
          (0, listeners[error])(void 0);
      }
    );
    return thenableWithOverride;
  }
  var prevOnStartTransitionFinish = ReactSharedInternals.S;
  ReactSharedInternals.S = function(transition, returnValue) {
    globalMostRecentTransitionTime = now();
    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
    null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
  };
  var resumedCache = createCursor(null);
  function peekCacheFromPool() {
    var cacheResumedFromPreviousRender = resumedCache.current;
    return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
  }
  function pushTransition(offscreenWorkInProgress, prevCachePool) {
    null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
  }
  function getSuspendedCache() {
    var cacheFromPool = peekCacheFromPool();
    return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
  }
  var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
  } };
  function isThenableResolved(thenable) {
    thenable = thenable.status;
    return "fulfilled" === thenable || "rejected" === thenable;
  }
  function trackUsedThenable(thenableState2, thenable, index2) {
    index2 = thenableState2[index2];
    void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$1, noop$1), thenable = index2);
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
      default:
        if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
        else {
          thenableState2 = workInProgressRoot;
          if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
            throw Error(formatProdErrorMessage(482));
          thenableState2 = thenable;
          thenableState2.status = "pending";
          thenableState2.then(
            function(fulfilledValue) {
              if ("pending" === thenable.status) {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            },
            function(error) {
              if ("pending" === thenable.status) {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            }
          );
        }
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        }
        suspendedThenable = thenable;
        throw SuspenseException;
    }
  }
  function resolveLazy(lazyType) {
    try {
      var init = lazyType._init;
      return init(lazyType._payload);
    } catch (x2) {
      if (null !== x2 && "object" === typeof x2 && "function" === typeof x2.then)
        throw suspendedThenable = x2, SuspenseException;
      throw x2;
    }
  }
  var suspendedThenable = null;
  function getSuspendedThenable() {
    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
    var thenable = suspendedThenable;
    suspendedThenable = null;
    return thenable;
  }
  function checkIfUseWrappedInAsyncCatch(rejectedReason) {
    if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
      throw Error(formatProdErrorMessage(483));
  }
  var thenableState$1 = null, thenableIndexCounter$1 = 0;
  function unwrapThenable(thenable) {
    var index2 = thenableIndexCounter$1;
    thenableIndexCounter$1 += 1;
    null === thenableState$1 && (thenableState$1 = []);
    return trackUsedThenable(thenableState$1, thenable, index2);
  }
  function coerceRef(workInProgress2, element) {
    element = element.props.ref;
    workInProgress2.ref = void 0 !== element ? element : null;
  }
  function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
    if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
      throw Error(formatProdErrorMessage(525));
    returnFiber = Object.prototype.toString.call(newChild);
    throw Error(
      formatProdErrorMessage(
        31,
        "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
      )
    );
  }
  function createChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var deletions = returnFiber.deletions;
        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
      }
    }
    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;
      for (; null !== currentFirstChild; )
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return null;
    }
    function mapRemainingChildren(currentFirstChild) {
      for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
        null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return existingChildren;
    }
    function useFiber(fiber, pendingProps) {
      fiber = createWorkInProgress(fiber, pendingProps);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }
    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects)
        return newFiber.flags |= 1048576, lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex)
        return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
      newFiber.flags |= 67108866;
      return lastPlacedIndex;
    }
    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
      return newFiber;
    }
    function updateTextNode(returnFiber, current, textContent, lanes) {
      if (null === current || 6 !== current.tag)
        return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, textContent);
      current.return = returnFiber;
      return current;
    }
    function updateElement(returnFiber, current, element, lanes) {
      var elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE)
        return updateFragment(
          returnFiber,
          current,
          element.props.children,
          lanes,
          element.key
        );
      if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
        return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
      current = createFiberFromTypeAndProps(
        element.type,
        element.key,
        element.props,
        null,
        returnFiber.mode,
        lanes
      );
      coerceRef(current, element);
      current.return = returnFiber;
      return current;
    }
    function updatePortal(returnFiber, current, portal, lanes) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
        return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, portal.children || []);
      current.return = returnFiber;
      return current;
    }
    function updateFragment(returnFiber, current, fragment, lanes, key) {
      if (null === current || 7 !== current.tag)
        return current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        ), current.return = returnFiber, current;
      current = useFiber(current, fragment);
      current.return = returnFiber;
      return current;
    }
    function createChild(returnFiber, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        ), newChild.return = returnFiber, newChild;
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          ), newChild.return = returnFiber, newChild;
        if ("function" === typeof newChild.then)
          return createChild(returnFiber, unwrapThenable(newChild), lanes);
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return createChild(
            returnFiber,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return null;
    }
    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
        if ("function" === typeof newChild.then)
          return updateSlot(
            returnFiber,
            oldFiber,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return updateSlot(
            returnFiber,
            oldFiber,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return null;
    }
    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(
              null === newChild.key ? newIdx : newChild.key
            ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(
              null === newChild.key ? newIdx : newChild.key
            ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              newChild,
              lanes
            );
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
        if ("function" === typeof newChild.then)
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return null;
    }
    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          newChildren[newIdx],
          lanes
        );
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (newIdx === newChildren.length)
        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++)
          oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
            oldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
        nextOldFiber = updateFromMap(
          oldFiber,
          returnFiber,
          newIdx,
          newChildren[newIdx],
          lanes
        ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
          null === nextOldFiber.key ? newIdx : nextOldFiber.key
        ), currentFirstChild = placeChild(
          nextOldFiber,
          currentFirstChild,
          newIdx
        ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      shouldTrackSideEffects && oldFiber.forEach(function(child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
      if (null == newChildren) throw Error(formatProdErrorMessage(151));
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (step.done)
        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildren.next())
          step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
        step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
      shouldTrackSideEffects && oldFiber.forEach(function(child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
      "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            a: {
              for (var key = newChild.key; null !== currentFirstChild; ) {
                if (currentFirstChild.key === key) {
                  key = newChild.type;
                  if (key === REACT_FRAGMENT_TYPE) {
                    if (7 === currentFirstChild.tag) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(
                        currentFirstChild,
                        newChild.props.children
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                  } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(currentFirstChild, newChild.props);
                    coerceRef(lanes, newChild);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                newChild.props.children,
                returnFiber.mode,
                lanes,
                newChild.key
              ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
            }
            return placeSingleChild(returnFiber);
          case REACT_PORTAL_TYPE:
            a: {
              for (key = newChild.key; null !== currentFirstChild; ) {
                if (currentFirstChild.key === key)
                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(currentFirstChild, newChild.children || []);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
              lanes.return = returnFiber;
              returnFiber = lanes;
            }
            return placeSingleChild(returnFiber);
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
        }
        if (isArrayImpl(newChild))
          return reconcileChildrenArray(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
        if (getIteratorFn(newChild)) {
          key = getIteratorFn(newChild);
          if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
          newChild = key.call(newChild);
          return reconcileChildrenIterator(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
        }
        if ("function" === typeof newChild.then)
          return reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
    }
    return function(returnFiber, currentFirstChild, newChild, lanes) {
      try {
        thenableIndexCounter$1 = 0;
        var firstChildFiber = reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
        thenableState$1 = null;
        return firstChildFiber;
      } catch (x2) {
        if (x2 === SuspenseException || x2 === SuspenseActionException) throw x2;
        var fiber = createFiberImplClass(29, x2, null, returnFiber.mode);
        fiber.lanes = lanes;
        fiber.return = returnFiber;
        return fiber;
      } finally {
      }
    };
  }
  var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
  function initializeUpdateQueue(fiber) {
    fiber.updateQueue = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function cloneUpdateQueue(current, workInProgress2) {
    current = current.updateQueue;
    workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
  }
  function createUpdate(lane) {
    return { lane, tag: 0, payload: null, callback: null, next: null };
  }
  function enqueueUpdate(fiber, update, lane) {
    var updateQueue = fiber.updateQueue;
    if (null === updateQueue) return null;
    updateQueue = updateQueue.shared;
    if (0 !== (executionContext & 2)) {
      var pending = updateQueue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      updateQueue.pending = update;
      update = getRootForUpdatedFiber(fiber);
      markUpdateLaneFromFiberToRoot(fiber, null, lane);
      return update;
    }
    enqueueUpdate$1(fiber, updateQueue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function entangleTransitions(root2, fiber, lane) {
    fiber = fiber.updateQueue;
    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
      var queueLanes = fiber.lanes;
      queueLanes &= root2.pendingLanes;
      lane |= queueLanes;
      fiber.lanes = lane;
      markRootEntangled(root2, lane);
    }
  }
  function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
    var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
    if (null !== current && (current = current.updateQueue, queue === current)) {
      var newFirst = null, newLast = null;
      queue = queue.firstBaseUpdate;
      if (null !== queue) {
        do {
          var clone = {
            lane: queue.lane,
            tag: queue.tag,
            payload: queue.payload,
            callback: null,
            next: null
          };
          null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
          queue = queue.next;
        } while (null !== queue);
        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
      } else newFirst = newLast = capturedUpdate;
      queue = {
        baseState: current.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: current.shared,
        callbacks: current.callbacks
      };
      workInProgress2.updateQueue = queue;
      return;
    }
    workInProgress2 = queue.lastBaseUpdate;
    null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
    queue.lastBaseUpdate = capturedUpdate;
  }
  var didReadFromEntangledAsyncAction = false;
  function suspendIfUpdateReadFromEntangledAsyncAction() {
    if (didReadFromEntangledAsyncAction) {
      var entangledActionThenable = currentEntangledActionThenable;
      if (null !== entangledActionThenable) throw entangledActionThenable;
    }
  }
  function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
    didReadFromEntangledAsyncAction = false;
    var queue = workInProgress$jscomp$0.updateQueue;
    hasForceUpdate = false;
    var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
    if (null !== pendingQueue) {
      queue.shared.pending = null;
      var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
      lastPendingUpdate.next = null;
      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
      lastBaseUpdate = lastPendingUpdate;
      var current = workInProgress$jscomp$0.alternate;
      null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
    }
    if (null !== firstBaseUpdate) {
      var newState = queue.baseState;
      lastBaseUpdate = 0;
      current = firstPendingUpdate = lastPendingUpdate = null;
      pendingQueue = firstBaseUpdate;
      do {
        var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
        if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
          0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
          null !== current && (current = current.next = {
            lane: 0,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: null,
            next: null
          });
          a: {
            var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
            updateLane = props;
            var instance = instance$jscomp$0;
            switch (update.tag) {
              case 1:
                workInProgress2 = update.payload;
                if ("function" === typeof workInProgress2) {
                  newState = workInProgress2.call(instance, newState, updateLane);
                  break a;
                }
                newState = workInProgress2;
                break a;
              case 3:
                workInProgress2.flags = workInProgress2.flags & -65537 | 128;
              case 0:
                workInProgress2 = update.payload;
                updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                if (null === updateLane || void 0 === updateLane) break a;
                newState = assign({}, newState, updateLane);
                break a;
              case 2:
                hasForceUpdate = true;
            }
          }
          updateLane = pendingQueue.callback;
          null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
        } else
          isHiddenUpdate = {
            lane: updateLane,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: pendingQueue.callback,
            next: null
          }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
        pendingQueue = pendingQueue.next;
        if (null === pendingQueue)
          if (pendingQueue = queue.shared.pending, null === pendingQueue)
            break;
          else
            isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
      } while (1);
      null === current && (lastPendingUpdate = newState);
      queue.baseState = lastPendingUpdate;
      queue.firstBaseUpdate = firstPendingUpdate;
      queue.lastBaseUpdate = current;
      null === firstBaseUpdate && (queue.shared.lanes = 0);
      workInProgressRootSkippedLanes |= lastBaseUpdate;
      workInProgress$jscomp$0.lanes = lastBaseUpdate;
      workInProgress$jscomp$0.memoizedState = newState;
    }
  }
  function callCallback(callback, context) {
    if ("function" !== typeof callback)
      throw Error(formatProdErrorMessage(191, callback));
    callback.call(context);
  }
  function commitCallbacks(updateQueue, context) {
    var callbacks = updateQueue.callbacks;
    if (null !== callbacks)
      for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
        callCallback(callbacks[updateQueue], context);
  }
  var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
  function pushHiddenContext(fiber, context) {
    fiber = entangledRenderLanes;
    push(prevEntangledRenderLanesCursor, fiber);
    push(currentTreeHiddenStackCursor, context);
    entangledRenderLanes = fiber | context.baseLanes;
  }
  function reuseHiddenContextOnStack() {
    push(prevEntangledRenderLanesCursor, entangledRenderLanes);
    push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
  }
  function popHiddenContext() {
    entangledRenderLanes = prevEntangledRenderLanesCursor.current;
    pop(currentTreeHiddenStackCursor);
    pop(prevEntangledRenderLanesCursor);
  }
  var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
  function pushPrimaryTreeSuspenseHandler(handler) {
    var current = handler.alternate;
    push(suspenseStackCursor, suspenseStackCursor.current & 1);
    push(suspenseHandlerStackCursor, handler);
    null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
  }
  function pushDehydratedActivitySuspenseHandler(fiber) {
    push(suspenseStackCursor, suspenseStackCursor.current);
    push(suspenseHandlerStackCursor, fiber);
    null === shellBoundary && (shellBoundary = fiber);
  }
  function pushOffscreenSuspenseHandler(fiber) {
    22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
  }
  function reuseSuspenseHandlerOnStack() {
    push(suspenseStackCursor, suspenseStackCursor.current);
    push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
  }
  function popSuspenseHandler(fiber) {
    pop(suspenseHandlerStackCursor);
    shellBoundary === fiber && (shellBoundary = null);
    pop(suspenseStackCursor);
  }
  var suspenseStackCursor = createCursor(0);
  function findFirstSuspended(row) {
    for (var node = row; null !== node; ) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
          return node;
      } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
        if (0 !== (node.flags & 128)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === row) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
    return null;
  }
  var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
  function throwInvalidHookError() {
    throw Error(formatProdErrorMessage(321));
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
    if (null === prevDeps) return false;
    for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
      if (!objectIs(nextDeps[i2], prevDeps[i2])) return false;
    return true;
  }
  function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber = workInProgress2;
    workInProgress2.memoizedState = null;
    workInProgress2.updateQueue = null;
    workInProgress2.lanes = 0;
    ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    nextRenderLanes = Component(props, secondArg);
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
      workInProgress2,
      Component,
      props,
      secondArg
    ));
    finishRenderingHooks(current);
    return nextRenderLanes;
  }
  function finishRenderingHooks(current) {
    ReactSharedInternals.H = ContextOnlyDispatcher;
    var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdate = false;
    thenableIndexCounter = 0;
    thenableState = null;
    if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
    null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
  }
  function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
    currentlyRenderingFiber = workInProgress2;
    var numberOfReRenders = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
      thenableIndexCounter = 0;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
      numberOfReRenders += 1;
      workInProgressHook = currentHook = null;
      if (null != workInProgress2.updateQueue) {
        var children = workInProgress2.updateQueue;
        children.lastEffect = null;
        children.events = null;
        children.stores = null;
        null != children.memoCache && (children.memoCache.index = 0);
      }
      ReactSharedInternals.H = HooksDispatcherOnRerender;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
    return children;
  }
  function TransitionAwareHostComponent() {
    var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
    maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
    dispatcher = dispatcher.useState()[0];
    (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
    return maybeThenable;
  }
  function checkDidRenderIdHook() {
    var didRenderIdHook = 0 !== localIdCounter;
    localIdCounter = 0;
    return didRenderIdHook;
  }
  function bailoutHooks(current, workInProgress2, lanes) {
    workInProgress2.updateQueue = current.updateQueue;
    workInProgress2.flags &= -2053;
    current.lanes &= ~lanes;
  }
  function resetHooksOnUnwind(workInProgress2) {
    if (didScheduleRenderPhaseUpdate) {
      for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
        var queue = workInProgress2.queue;
        null !== queue && (queue.pending = null);
        workInProgress2 = workInProgress2.next;
      }
      didScheduleRenderPhaseUpdate = false;
    }
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdateDuringThisPass = false;
    thenableIndexCounter = localIdCounter = 0;
    thenableState = null;
  }
  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
    return workInProgressHook;
  }
  function updateWorkInProgressHook() {
    if (null === currentHook) {
      var nextCurrentHook = currentlyRenderingFiber.alternate;
      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
    } else nextCurrentHook = currentHook.next;
    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
    if (null !== nextWorkInProgressHook)
      workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
    else {
      if (null === nextCurrentHook) {
        if (null === currentlyRenderingFiber.alternate)
          throw Error(formatProdErrorMessage(467));
        throw Error(formatProdErrorMessage(310));
      }
      currentHook = nextCurrentHook;
      nextCurrentHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        baseQueue: currentHook.baseQueue,
        queue: currentHook.queue,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
    }
    return workInProgressHook;
  }
  function createFunctionComponentUpdateQueue() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function useThenable(thenable) {
    var index2 = thenableIndexCounter;
    thenableIndexCounter += 1;
    null === thenableState && (thenableState = []);
    thenable = trackUsedThenable(thenableState, thenable, index2);
    index2 = currentlyRenderingFiber;
    null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
    return thenable;
  }
  function use(usable) {
    if (null !== usable && "object" === typeof usable) {
      if ("function" === typeof usable.then) return useThenable(usable);
      if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
    }
    throw Error(formatProdErrorMessage(438, String(usable)));
  }
  function useMemoCache(size) {
    var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
    null !== updateQueue && (memoCache = updateQueue.memoCache);
    if (null == memoCache) {
      var current = currentlyRenderingFiber.alternate;
      null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
        data: current.data.map(function(array) {
          return array.slice();
        }),
        index: 0
      })));
    }
    null == memoCache && (memoCache = { data: [], index: 0 });
    null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
    updateQueue.memoCache = memoCache;
    updateQueue = memoCache.data[memoCache.index];
    if (void 0 === updateQueue)
      for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
        updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
    memoCache.index++;
    return updateQueue;
  }
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  function updateReducer(reducer) {
    var hook = updateWorkInProgressHook();
    return updateReducerImpl(hook, currentHook, reducer);
  }
  function updateReducerImpl(hook, current, reducer) {
    var queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
    if (null !== pendingQueue) {
      if (null !== baseQueue) {
        var baseFirst = baseQueue.next;
        baseQueue.next = pendingQueue.next;
        pendingQueue.next = baseFirst;
      }
      current.baseQueue = baseQueue = pendingQueue;
      queue.pending = null;
    }
    pendingQueue = hook.baseState;
    if (null === baseQueue) hook.memoizedState = pendingQueue;
    else {
      current = baseQueue.next;
      var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
      do {
        var updateLane = update.lane & -536870913;
        if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
          var revertLane = update.revertLane;
          if (0 === revertLane)
            null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
          else if ((renderLanes & revertLane) === revertLane) {
            update = update.next;
            revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
            continue;
          } else
            updateLane = {
              lane: 0,
              revertLane: update.revertLane,
              gesture: null,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
          updateLane = update.action;
          shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
          pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
        } else
          revertLane = {
            lane: updateLane,
            revertLane: update.revertLane,
            gesture: update.gesture,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
        update = update.next;
      } while (null !== update && update !== current);
      null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
      if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
        throw reducer;
      hook.memoizedState = pendingQueue;
      hook.baseState = baseFirst;
      hook.baseQueue = newBaseQueueLast;
      queue.lastRenderedState = pendingQueue;
    }
    null === baseQueue && (queue.lanes = 0);
    return [hook.memoizedState, queue.dispatch];
  }
  function rerenderReducer(reducer) {
    var hook = updateWorkInProgressHook(), queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
    if (null !== lastRenderPhaseUpdate) {
      queue.pending = null;
      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      do
        newState = reducer(newState, update.action), update = update.next;
      while (update !== lastRenderPhaseUpdate);
      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = newState;
      null === hook.baseQueue && (hook.baseState = newState);
      queue.lastRenderedState = newState;
    }
    return [newState, dispatch];
  }
  function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
    if (isHydrating$jscomp$0) {
      if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else getServerSnapshot = getSnapshot();
    var snapshotChanged = !objectIs(
      (currentHook || hook).memoizedState,
      getServerSnapshot
    );
    snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
    hook = hook.queue;
    updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
      subscribe
    ]);
    if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          hook,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
      isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    return getServerSnapshot;
  }
  function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
    fiber.flags |= 16384;
    fiber = { getSnapshot, value: renderedSnapshot };
    getSnapshot = currentlyRenderingFiber.updateQueue;
    null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
  }
  function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
    inst.value = nextSnapshot;
    inst.getSnapshot = getSnapshot;
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  }
  function subscribeToStore(fiber, inst, subscribe) {
    return subscribe(function() {
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    });
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function forceStoreRerender(fiber) {
    var root2 = enqueueConcurrentRenderForLane(fiber, 2);
    null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
  }
  function mountStateImpl(initialState) {
    var hook = mountWorkInProgressHook();
    if ("function" === typeof initialState) {
      var initialStateInitializer = initialState;
      initialState = initialStateInitializer();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          initialStateInitializer();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
    }
    hook.memoizedState = hook.baseState = initialState;
    hook.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialState
    };
    return hook;
  }
  function updateOptimisticImpl(hook, current, passthrough, reducer) {
    hook.baseState = passthrough;
    return updateReducerImpl(
      hook,
      currentHook,
      "function" === typeof reducer ? reducer : basicStateReducer
    );
  }
  function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
    if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
    fiber = actionQueue.action;
    if (null !== fiber) {
      var actionNode = {
        payload,
        action: fiber,
        next: null,
        isTransition: true,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(listener) {
          actionNode.listeners.push(listener);
        }
      };
      null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
      setState(actionNode);
      setPendingState = actionQueue.pending;
      null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
    }
  }
  function runActionStateAction(actionQueue, node) {
    var action = node.action, payload = node.payload, prevState = actionQueue.state;
    if (node.isTransition) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        handleActionReturnValue(actionQueue, node, returnValue);
      } catch (error) {
        onActionError(actionQueue, node, error);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    } else
      try {
        prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
      } catch (error$66) {
        onActionError(actionQueue, node, error$66);
      }
  }
  function handleActionReturnValue(actionQueue, node, returnValue) {
    null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
      function(nextState) {
        onActionSuccess(actionQueue, node, nextState);
      },
      function(error) {
        return onActionError(actionQueue, node, error);
      }
    ) : onActionSuccess(actionQueue, node, returnValue);
  }
  function onActionSuccess(actionQueue, actionNode, nextState) {
    actionNode.status = "fulfilled";
    actionNode.value = nextState;
    notifyActionListeners(actionNode);
    actionQueue.state = nextState;
    actionNode = actionQueue.pending;
    null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
  }
  function onActionError(actionQueue, actionNode, error) {
    var last = actionQueue.pending;
    actionQueue.pending = null;
    if (null !== last) {
      last = last.next;
      do
        actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
      while (actionNode !== last);
    }
    actionQueue.action = null;
  }
  function notifyActionListeners(actionNode) {
    actionNode = actionNode.listeners;
    for (var i2 = 0; i2 < actionNode.length; i2++) (0, actionNode[i2])();
  }
  function actionStateReducer(oldState, newState) {
    return newState;
  }
  function mountActionState(action, initialStateProp) {
    if (isHydrating) {
      var ssrFormState = workInProgressRoot.formState;
      if (null !== ssrFormState) {
        a: {
          var JSCompiler_inline_result = currentlyRenderingFiber;
          if (isHydrating) {
            if (nextHydratableInstance) {
              b: {
                var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                  if (!inRootOrSingleton) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                  JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  if (null === JSCompiler_inline_result$jscomp$0) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                }
                inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
              }
              if (JSCompiler_inline_result$jscomp$0) {
                nextHydratableInstance = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                break a;
              }
            }
            throwOnHydrationMismatch(JSCompiler_inline_result);
          }
          JSCompiler_inline_result = false;
        }
        JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
      }
    }
    ssrFormState = mountWorkInProgressHook();
    ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
    JSCompiler_inline_result = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: actionStateReducer,
      lastRenderedState: initialStateProp
    };
    ssrFormState.queue = JSCompiler_inline_result;
    ssrFormState = dispatchSetState.bind(
      null,
      currentlyRenderingFiber,
      JSCompiler_inline_result
    );
    JSCompiler_inline_result.dispatch = ssrFormState;
    JSCompiler_inline_result = mountStateImpl(false);
    inRootOrSingleton = dispatchOptimisticSetState.bind(
      null,
      currentlyRenderingFiber,
      false,
      JSCompiler_inline_result.queue
    );
    JSCompiler_inline_result = mountWorkInProgressHook();
    JSCompiler_inline_result$jscomp$0 = {
      state: initialStateProp,
      dispatch: null,
      action,
      pending: null
    };
    JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
    ssrFormState = dispatchActionState.bind(
      null,
      currentlyRenderingFiber,
      JSCompiler_inline_result$jscomp$0,
      inRootOrSingleton,
      ssrFormState
    );
    JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
    JSCompiler_inline_result.memoizedState = action;
    return [initialStateProp, ssrFormState, false];
  }
  function updateActionState(action) {
    var stateHook = updateWorkInProgressHook();
    return updateActionStateImpl(stateHook, currentHook, action);
  }
  function updateActionStateImpl(stateHook, currentStateHook, action) {
    currentStateHook = updateReducerImpl(
      stateHook,
      currentStateHook,
      actionStateReducer
    )[0];
    stateHook = updateReducer(basicStateReducer)[0];
    if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
      try {
        var state = useThenable(currentStateHook);
      } catch (x2) {
        if (x2 === SuspenseException) throw SuspenseActionException;
        throw x2;
      }
    else state = currentStateHook;
    currentStateHook = updateWorkInProgressHook();
    var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
    action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
      9,
      { destroy: void 0 },
      actionStateActionEffect.bind(null, actionQueue, action),
      null
    ));
    return [state, dispatch, stateHook];
  }
  function actionStateActionEffect(actionQueue, action) {
    actionQueue.action = action;
  }
  function rerenderActionState(action) {
    var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
    if (null !== currentStateHook)
      return updateActionStateImpl(stateHook, currentStateHook, action);
    updateWorkInProgressHook();
    stateHook = stateHook.memoizedState;
    currentStateHook = updateWorkInProgressHook();
    var dispatch = currentStateHook.queue.dispatch;
    currentStateHook.memoizedState = action;
    return [stateHook, dispatch, false];
  }
  function pushSimpleEffect(tag, inst, create, deps) {
    tag = { tag, create, deps, inst, next: null };
    inst = currentlyRenderingFiber.updateQueue;
    null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
    create = inst.lastEffect;
    null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
    return tag;
  }
  function updateRef() {
    return updateWorkInProgressHook().memoizedState;
  }
  function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = mountWorkInProgressHook();
    currentlyRenderingFiber.flags |= fiberFlags;
    hook.memoizedState = pushSimpleEffect(
      1 | hookFlags,
      { destroy: void 0 },
      create,
      void 0 === deps ? null : deps
    );
  }
  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var inst = hook.memoizedState.inst;
    null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
      1 | hookFlags,
      inst,
      create,
      deps
    ));
  }
  function mountEffect(create, deps) {
    mountEffectImpl(8390656, 8, create, deps);
  }
  function updateEffect(create, deps) {
    updateEffectImpl(2048, 8, create, deps);
  }
  function useEffectEventImpl(payload) {
    currentlyRenderingFiber.flags |= 4;
    var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
    if (null === componentUpdateQueue)
      componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
    else {
      var events = componentUpdateQueue.events;
      null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
    }
  }
  function updateEvent(callback) {
    var ref = updateWorkInProgressHook().memoizedState;
    useEffectEventImpl({ ref, nextImpl: callback });
    return function() {
      if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
      return ref.impl.apply(void 0, arguments);
    };
  }
  function updateInsertionEffect(create, deps) {
    return updateEffectImpl(4, 2, create, deps);
  }
  function updateLayoutEffect(create, deps) {
    return updateEffectImpl(4, 4, create, deps);
  }
  function imperativeHandleEffect(create, ref) {
    if ("function" === typeof ref) {
      create = create();
      var refCleanup = ref(create);
      return function() {
        "function" === typeof refCleanup ? refCleanup() : ref(null);
      };
    }
    if (null !== ref && void 0 !== ref)
      return create = create(), ref.current = create, function() {
        ref.current = null;
      };
  }
  function updateImperativeHandle(ref, create, deps) {
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
  }
  function mountDebugValue() {
  }
  function updateCallback(callback, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
      return prevState[0];
    hook.memoizedState = [callback, deps];
    return callback;
  }
  function updateMemo(nextCreate, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
      return prevState[0];
    prevState = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    hook.memoizedState = [prevState, deps];
    return prevState;
  }
  function mountDeferredValueImpl(hook, value, initialValue) {
    if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
      return hook.memoizedState = value;
    hook.memoizedState = initialValue;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return initialValue;
  }
  function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
    if (objectIs(value, prevValue)) return value;
    if (null !== currentTreeHiddenStackCursor.current)
      return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
    if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
      return didReceiveUpdate = true, hook.memoizedState = value;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return prevValue;
  }
  function startTransition(fiber, queue, pendingState, finishedState, callback) {
    var previousPriority = ReactDOMSharedInternals.p;
    ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    dispatchOptimisticSetState(fiber, false, queue, pendingState);
    try {
      var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
        var thenableForFinishedState = chainThenableValue(
          returnValue,
          finishedState
        );
        dispatchSetStateInternal(
          fiber,
          queue,
          thenableForFinishedState,
          requestUpdateLane(fiber)
        );
      } else
        dispatchSetStateInternal(
          fiber,
          queue,
          finishedState,
          requestUpdateLane(fiber)
        );
    } catch (error) {
      dispatchSetStateInternal(
        fiber,
        queue,
        { then: function() {
        }, status: "rejected", reason: error },
        requestUpdateLane()
      );
    } finally {
      ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
    }
  }
  function noop() {
  }
  function startHostTransition(formFiber, pendingState, action, formData) {
    if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
    var queue = ensureFormComponentIsStateful(formFiber).queue;
    startTransition(
      formFiber,
      queue,
      pendingState,
      sharedNotPendingObject,
      null === action ? noop : function() {
        requestFormReset$1(formFiber);
        return action(formData);
      }
    );
  }
  function ensureFormComponentIsStateful(formFiber) {
    var existingStateHook = formFiber.memoizedState;
    if (null !== existingStateHook) return existingStateHook;
    existingStateHook = {
      memoizedState: sharedNotPendingObject,
      baseState: sharedNotPendingObject,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: sharedNotPendingObject
      },
      next: null
    };
    var initialResetState = {};
    existingStateHook.next = {
      memoizedState: initialResetState,
      baseState: initialResetState,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialResetState
      },
      next: null
    };
    formFiber.memoizedState = existingStateHook;
    formFiber = formFiber.alternate;
    null !== formFiber && (formFiber.memoizedState = existingStateHook);
    return existingStateHook;
  }
  function requestFormReset$1(formFiber) {
    var stateHook = ensureFormComponentIsStateful(formFiber);
    null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
    dispatchSetStateInternal(
      formFiber,
      stateHook.next.queue,
      {},
      requestUpdateLane()
    );
  }
  function useHostTransitionStatus() {
    return readContext(HostTransitionContext);
  }
  function updateId() {
    return updateWorkInProgressHook().memoizedState;
  }
  function updateRefresh() {
    return updateWorkInProgressHook().memoizedState;
  }
  function refreshCache(fiber) {
    for (var provider = fiber.return; null !== provider; ) {
      switch (provider.tag) {
        case 24:
        case 3:
          var lane = requestUpdateLane();
          fiber = createUpdate(lane);
          var root$69 = enqueueUpdate(provider, fiber, lane);
          null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
          provider = { cache: createCache() };
          fiber.payload = provider;
          return;
      }
      provider = provider.return;
    }
  }
  function dispatchReducerAction(fiber, queue, action) {
    var lane = requestUpdateLane();
    action = {
      lane,
      revertLane: 0,
      gesture: null,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
  }
  function dispatchSetState(fiber, queue, action) {
    var lane = requestUpdateLane();
    dispatchSetStateInternal(fiber, queue, action, lane);
  }
  function dispatchSetStateInternal(fiber, queue, action, lane) {
    var update = {
      lane,
      revertLane: 0,
      gesture: null,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
    else {
      var alternate = fiber.alternate;
      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
        try {
          var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (objectIs(eagerState, currentState))
            return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
        } catch (error) {
        } finally {
        }
      action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
      if (null !== action)
        return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
    }
    return false;
  }
  function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
    action = {
      lane: 2,
      revertLane: requestTransitionLane(),
      gesture: null,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) {
      if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
    } else
      throwIfDuringRender = enqueueConcurrentHookUpdate(
        fiber,
        queue,
        action,
        2
      ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
  }
  function isRenderPhaseUpdate(fiber) {
    var alternate = fiber.alternate;
    return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
  }
  function enqueueRenderPhaseUpdate(queue, update) {
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
    var pending = queue.pending;
    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
    queue.pending = update;
  }
  function entangleTransitionUpdate(root2, queue, lane) {
    if (0 !== (lane & 4194048)) {
      var queueLanes = queue.lanes;
      queueLanes &= root2.pendingLanes;
      lane |= queueLanes;
      queue.lanes = lane;
      markRootEntangled(root2, lane);
    }
  }
  var ContextOnlyDispatcher = {
    readContext,
    use,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useInsertionEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useSyncExternalStore: throwInvalidHookError,
    useId: throwInvalidHookError,
    useHostTransitionStatus: throwInvalidHookError,
    useFormState: throwInvalidHookError,
    useActionState: throwInvalidHookError,
    useOptimistic: throwInvalidHookError,
    useMemoCache: throwInvalidHookError,
    useCacheRefresh: throwInvalidHookError
  };
  ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
  var HooksDispatcherOnMount = {
    readContext,
    use,
    useCallback: function(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function(ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      mountEffectImpl(
        4194308,
        4,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    },
    useLayoutEffect: function(create, deps) {
      return mountEffectImpl(4194308, 4, create, deps);
    },
    useInsertionEffect: function(create, deps) {
      mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    },
    useReducer: function(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    },
    useRef: function(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    },
    useState: function(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    },
    useTransition: function() {
      var stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        true,
        false
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    },
    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else {
        getServerSnapshot = getSnapshot();
        if (null === workInProgressRoot)
          throw Error(formatProdErrorMessage(349));
        0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      hook.memoizedState = getServerSnapshot;
      var inst = { value: getServerSnapshot, getSnapshot };
      hook.queue = inst;
      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
        subscribe
      ]);
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          inst,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      return getServerSnapshot;
    },
    useId: function() {
      var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var JSCompiler_inline_result = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
        identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
        JSCompiler_inline_result = localIdCounter++;
        0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
        identifierPrefix += "_";
      } else
        JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
      return hook.memoizedState = identifierPrefix;
    },
    useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        true,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    },
    useMemoCache,
    useCacheRefresh: function() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      );
    },
    useEffectEvent: function(callback) {
      var hook = mountWorkInProgressHook(), ref = { impl: callback };
      hook.memoizedState = ref;
      return function() {
        if (0 !== (executionContext & 2))
          throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
  }, HooksDispatcherOnUpdate = {
    readContext,
    use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function() {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  };
  HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
  var HooksDispatcherOnRerender = {
    readContext,
    use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: rerenderReducer,
    useRef: updateRef,
    useState: function() {
      return rerenderReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: rerenderActionState,
    useActionState: rerenderActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  };
  HooksDispatcherOnRerender.useEffectEvent = updateEvent;
  function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress2.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
    workInProgress2.memoizedState = getDerivedStateFromProps;
    0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
  }
  var classComponentUpdater = {
    enqueueSetState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueReplaceState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 1;
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueForceUpdate: function(inst, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 2;
      void 0 !== callback && null !== callback && (update.callback = callback);
      callback = enqueueUpdate(inst, update, lane);
      null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
    }
  };
  function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress2 = workInProgress2.stateNode;
    return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
  }
  function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
    workInProgress2 = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
  function resolveClassComponentProps(Component, baseProps) {
    var newProps = baseProps;
    if ("ref" in baseProps) {
      newProps = {};
      for (var propName in baseProps)
        "ref" !== propName && (newProps[propName] = baseProps[propName]);
    }
    if (Component = Component.defaultProps) {
      newProps === baseProps && (newProps = assign({}, newProps));
      for (var propName$73 in Component)
        void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
    }
    return newProps;
  }
  function defaultOnUncaughtError(error) {
    reportGlobalError(error);
  }
  function defaultOnCaughtError(error) {
    console.error(error);
  }
  function defaultOnRecoverableError(error) {
    reportGlobalError(error);
  }
  function logUncaughtError(root2, errorInfo) {
    try {
      var onUncaughtError = root2.onUncaughtError;
      onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
    } catch (e$74) {
      setTimeout(function() {
        throw e$74;
      });
    }
  }
  function logCaughtError(root2, boundary, errorInfo) {
    try {
      var onCaughtError = root2.onCaughtError;
      onCaughtError(errorInfo.value, {
        componentStack: errorInfo.stack,
        errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
      });
    } catch (e$75) {
      setTimeout(function() {
        throw e$75;
      });
    }
  }
  function createRootErrorUpdate(root2, errorInfo, lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    lane.payload = { element: null };
    lane.callback = function() {
      logUncaughtError(root2, errorInfo);
    };
    return lane;
  }
  function createClassErrorUpdate(lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    return lane;
  }
  function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;
      update.payload = function() {
        return getDerivedStateFromError(error);
      };
      update.callback = function() {
        logCaughtError(root2, fiber, errorInfo);
      };
    }
    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
      logCaughtError(root2, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
  }
  function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
    sourceFiber.flags |= 32768;
    if (null !== value && "object" === typeof value && "function" === typeof value.then) {
      returnFiber = sourceFiber.alternate;
      null !== returnFiber && propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        true
      );
      sourceFiber = suspenseHandlerStackCursor.current;
      if (null !== sourceFiber) {
        switch (sourceFiber.tag) {
          case 31:
          case 13:
            return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
          case 22:
            return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([value])
            }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
        }
        throw Error(formatProdErrorMessage(435, sourceFiber.tag));
      }
      attachPingListener(root2, value, rootRenderLanes);
      renderDidSuspendDelayIfPossible();
      return false;
    }
    if (isHydrating)
      return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
        cause: value
      }), queueHydrationError(
        createCapturedValueAtFiber(returnFiber, sourceFiber)
      )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
        root2.stateNode,
        value,
        rootRenderLanes
      ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
    var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
    wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
    null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
    4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
    if (null === returnFiber) return true;
    value = createCapturedValueAtFiber(value, sourceFiber);
    sourceFiber = returnFiber;
    do {
      switch (sourceFiber.tag) {
        case 3:
          return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
        case 1:
          if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
            return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
              rootRenderLanes,
              root2,
              sourceFiber,
              value
            ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
      }
      sourceFiber = sourceFiber.return;
    } while (null !== sourceFiber);
    return false;
  }
  var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
  function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
    workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
      workInProgress2,
      current.child,
      nextChildren,
      renderLanes2
    );
  }
  function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
    Component = Component.render;
    var ref = workInProgress2.ref;
    if ("ref" in nextProps) {
      var propsWithoutRef = {};
      for (var key in nextProps)
        "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
    } else propsWithoutRef = nextProps;
    prepareToReadContext(workInProgress2);
    nextProps = renderWithHooks(
      current,
      workInProgress2,
      Component,
      propsWithoutRef,
      ref,
      renderLanes2
    );
    key = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && key && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    return workInProgress2.child;
  }
  function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    if (null === current) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
        return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
          current,
          workInProgress2,
          type,
          nextProps,
          renderLanes2
        );
      current = createFiberFromTypeAndProps(
        Component.type,
        null,
        nextProps,
        workInProgress2,
        workInProgress2.mode,
        renderLanes2
      );
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    type = current.child;
    if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
      var prevProps = type.memoizedProps;
      Component = Component.compare;
      Component = null !== Component ? Component : shallowEqual;
      if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    workInProgress2.flags |= 1;
    current = createWorkInProgress(type, nextProps);
    current.ref = workInProgress2.ref;
    current.return = workInProgress2;
    return workInProgress2.child = current;
  }
  function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    if (null !== current) {
      var prevProps = current.memoizedProps;
      if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
        if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
          0 !== (current.flags & 131072) && (didReceiveUpdate = true);
        else
          return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    return updateFunctionComponent(
      current,
      workInProgress2,
      Component,
      nextProps,
      renderLanes2
    );
  }
  function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
    var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
    null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
    if ("hidden" === nextProps.mode) {
      if (0 !== (workInProgress2.flags & 128)) {
        prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
        if (null !== current) {
          nextProps = workInProgress2.child = current.child;
          for (nextChildren = 0; null !== nextProps; )
            nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
          nextProps = nextChildren & ~prevState;
        } else nextProps = 0, workInProgress2.child = null;
        return deferHiddenOffscreenComponent(
          current,
          workInProgress2,
          prevState,
          renderLanes2,
          nextProps
        );
      }
      if (0 !== (renderLanes2 & 536870912))
        workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
          workInProgress2,
          null !== prevState ? prevState.cachePool : null
        ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
      else
        return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
          current,
          workInProgress2,
          null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
          renderLanes2,
          nextProps
        );
    } else
      null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
    reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
    return workInProgress2.child;
  }
  function bailoutOffscreenComponent(current, workInProgress2) {
    null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
    return workInProgress2.sibling;
  }
  function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
    var JSCompiler_inline_result = peekCacheFromPool();
    JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
    workInProgress2.memoizedState = {
      baseLanes: nextBaseLanes,
      cachePool: JSCompiler_inline_result
    };
    null !== current && pushTransition(workInProgress2, null);
    reuseHiddenContextOnStack();
    pushOffscreenSuspenseHandler(workInProgress2);
    null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
    workInProgress2.childLanes = remainingChildLanes;
    return null;
  }
  function mountActivityChildren(workInProgress2, nextProps) {
    nextProps = mountWorkInProgressOffscreenFiber(
      { mode: nextProps.mode, children: nextProps.children },
      workInProgress2.mode
    );
    nextProps.ref = workInProgress2.ref;
    workInProgress2.child = nextProps;
    nextProps.return = workInProgress2;
    return nextProps;
  }
  function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
    reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
    current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
    current.flags |= 2;
    popSuspenseHandler(workInProgress2);
    workInProgress2.memoizedState = null;
    return current;
  }
  function updateActivityComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
    workInProgress2.flags &= -129;
    if (null === current) {
      if (isHydrating) {
        if ("hidden" === nextProps.mode)
          return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
          current,
          rootOrSingletonContext
        ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
          dehydrated: current,
          treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
        if (null === current) throw throwOnHydrationMismatch(workInProgress2);
        workInProgress2.lanes = 536870912;
        return null;
      }
      return mountActivityChildren(workInProgress2, nextProps);
    }
    var prevState = current.memoizedState;
    if (null !== prevState) {
      var dehydrated = prevState.dehydrated;
      pushDehydratedActivitySuspenseHandler(workInProgress2);
      if (didSuspend)
        if (workInProgress2.flags & 256)
          workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        else if (null !== workInProgress2.memoizedState)
          workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
        else throw Error(formatProdErrorMessage(558));
      else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
        nextProps = workInProgressRoot;
        if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
          throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
        renderDidSuspendDelayIfPossible();
        workInProgress2 = retryActivityComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else
        current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
      return workInProgress2;
    }
    current = createWorkInProgress(current.child, {
      mode: nextProps.mode,
      children: nextProps.children
    });
    current.ref = workInProgress2.ref;
    workInProgress2.child = current;
    current.return = workInProgress2;
    return current;
  }
  function markRef(current, workInProgress2) {
    var ref = workInProgress2.ref;
    if (null === ref)
      null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
    else {
      if ("function" !== typeof ref && "object" !== typeof ref)
        throw Error(formatProdErrorMessage(284));
      if (null === current || current.ref !== ref)
        workInProgress2.flags |= 4194816;
    }
  }
  function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    prepareToReadContext(workInProgress2);
    Component = renderWithHooks(
      current,
      workInProgress2,
      Component,
      nextProps,
      void 0,
      renderLanes2
    );
    nextProps = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, Component, renderLanes2);
    return workInProgress2.child;
  }
  function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
    prepareToReadContext(workInProgress2);
    workInProgress2.updateQueue = null;
    nextProps = renderWithHooksAgain(
      workInProgress2,
      Component,
      nextProps,
      secondArg
    );
    finishRenderingHooks(current);
    Component = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && Component && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    return workInProgress2.child;
  }
  function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    prepareToReadContext(workInProgress2);
    if (null === workInProgress2.stateNode) {
      var context = emptyContextObject, contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
      context = new Component(nextProps, context);
      workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
      context.updater = classComponentUpdater;
      workInProgress2.stateNode = context;
      context._reactInternals = workInProgress2;
      context = workInProgress2.stateNode;
      context.props = nextProps;
      context.state = workInProgress2.memoizedState;
      context.refs = {};
      initializeUpdateQueue(workInProgress2);
      contextType = Component.contextType;
      context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
      context.state = workInProgress2.memoizedState;
      contextType = Component.getDerivedStateFromProps;
      "function" === typeof contextType && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        contextType,
        nextProps
      ), context.state = workInProgress2.memoizedState);
      "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
      "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
      nextProps = true;
    } else if (null === current) {
      context = workInProgress2.stateNode;
      var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
      context.props = oldProps;
      var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
      contextType = emptyContextObject;
      "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
      contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
      unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
      contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
        workInProgress2,
        context,
        nextProps,
        contextType
      );
      hasForceUpdate = false;
      var oldState = workInProgress2.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
      suspendIfUpdateReadFromEntangledAsyncAction();
      oldContext = workInProgress2.memoizedState;
      unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        getDerivedStateFromProps,
        nextProps
      ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
        workInProgress2,
        Component,
        oldProps,
        nextProps,
        oldState,
        oldContext,
        contextType
      )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
    } else {
      context = workInProgress2.stateNode;
      cloneUpdateQueue(current, workInProgress2);
      contextType = workInProgress2.memoizedProps;
      contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
      context.props = contextType$jscomp$0;
      getDerivedStateFromProps = workInProgress2.pendingProps;
      oldState = context.context;
      oldContext = Component.contextType;
      oldProps = emptyContextObject;
      "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
      unresolvedOldProps = Component.getDerivedStateFromProps;
      (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
        workInProgress2,
        context,
        nextProps,
        oldProps
      );
      hasForceUpdate = false;
      oldState = workInProgress2.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
      suspendIfUpdateReadFromEntangledAsyncAction();
      var newState = workInProgress2.memoizedState;
      contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        unresolvedOldProps,
        nextProps
      ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
        workInProgress2,
        Component,
        contextType$jscomp$0,
        nextProps,
        oldState,
        newState,
        oldProps
      ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
        nextProps,
        newState,
        oldProps
      )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
    }
    context = nextProps;
    markRef(current, workInProgress2);
    nextProps = 0 !== (workInProgress2.flags & 128);
    context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      current.child,
      null,
      renderLanes2
    ), workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      null,
      Component,
      renderLanes2
    )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
      current,
      workInProgress2,
      renderLanes2
    );
    return current;
  }
  function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
    resetHydrationState();
    workInProgress2.flags |= 256;
    reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
    return workInProgress2.child;
  }
  var SUSPENDED_MARKER = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function mountSuspenseOffscreenState(renderLanes2) {
    return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
  }
  function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
    current = null !== current ? current.childLanes & ~renderLanes2 : 0;
    primaryTreeDidDefer && (current |= workInProgressDeferredLane);
    return current;
  }
  function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
    (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
    JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
    JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
    workInProgress2.flags &= -33;
    if (null === current) {
      if (isHydrating) {
        showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
        (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
          current,
          rootOrSingletonContext
        ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
          dehydrated: current,
          treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
        if (null === current) throw throwOnHydrationMismatch(workInProgress2);
        isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
        return null;
      }
      var nextPrimaryChildren = nextProps.children;
      nextProps = nextProps.fallback;
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextPrimaryChildren },
          showFallback
        ), nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
    }
    var prevState = current.memoizedState;
    if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
      if (didSuspend)
        workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: nextProps.children },
          showFallback
        ), nextPrimaryChildren = createFiberFromFragment(
          nextPrimaryChildren,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
      else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
        JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
        if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
        JSCompiler_temp = digest;
        nextProps = Error(formatProdErrorMessage(419));
        nextProps.stack = "";
        nextProps.digest = JSCompiler_temp;
        queueHydrationError({ value: nextProps, source: null, stack: null });
        workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
        JSCompiler_temp = workInProgressRoot;
        if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
          throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
        isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
        workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else
        isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
          nextPrimaryChildren.nextSibling
        ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
          workInProgress2,
          nextProps.children
        ), workInProgress2.flags |= 4096);
      return workInProgress2;
    }
    if (showFallback)
      return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
        mode: "hidden",
        children: nextProps.children
      }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
        digest,
        nextPrimaryChildren
      ) : (nextPrimaryChildren = createFiberFromFragment(
        nextPrimaryChildren,
        showFallback,
        renderLanes2,
        null
      ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
        baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
        cachePool: showFallback
      }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes2
      ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
    pushPrimaryTreeSuspenseHandler(workInProgress2);
    renderLanes2 = current.child;
    current = renderLanes2.sibling;
    renderLanes2 = createWorkInProgress(renderLanes2, {
      mode: "visible",
      children: nextProps.children
    });
    renderLanes2.return = workInProgress2;
    renderLanes2.sibling = null;
    null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
    workInProgress2.child = renderLanes2;
    workInProgress2.memoizedState = null;
    return renderLanes2;
  }
  function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
    primaryChildren = mountWorkInProgressOffscreenFiber(
      { mode: "visible", children: primaryChildren },
      workInProgress2.mode
    );
    primaryChildren.return = workInProgress2;
    return workInProgress2.child = primaryChildren;
  }
  function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
    offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
    offscreenProps.lanes = 0;
    return offscreenProps;
  }
  function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
    reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
    current = mountSuspensePrimaryChildren(
      workInProgress2,
      workInProgress2.pendingProps.children
    );
    current.flags |= 2;
    workInProgress2.memoizedState = null;
    return current;
  }
  function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
    fiber.lanes |= renderLanes2;
    var alternate = fiber.alternate;
    null !== alternate && (alternate.lanes |= renderLanes2);
    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
  }
  function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
    var renderState = workInProgress2.memoizedState;
    null === renderState ? workInProgress2.memoizedState = {
      isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail,
      tailMode,
      treeForkCount: treeForkCount2
    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
  }
  function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
    nextProps = nextProps.children;
    var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
    shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
    push(suspenseStackCursor, suspenseContext);
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    nextProps = isHydrating ? treeForkCount : 0;
    if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
      a: for (current = workInProgress2.child; null !== current; ) {
        if (13 === current.tag)
          null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
        else if (19 === current.tag)
          scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
        else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress2) break a;
        for (; null === current.sibling; ) {
          if (null === current.return || current.return === workInProgress2)
            break a;
          current = current.return;
        }
        current.sibling.return = current.return;
        current = current.sibling;
      }
    switch (revealOrder) {
      case "forwards":
        renderLanes2 = workInProgress2.child;
        for (revealOrder = null; null !== renderLanes2; )
          current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
        renderLanes2 = revealOrder;
        null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
        initSuspenseListRenderState(
          workInProgress2,
          false,
          revealOrder,
          renderLanes2,
          tailMode,
          nextProps
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        renderLanes2 = null;
        revealOrder = workInProgress2.child;
        for (workInProgress2.child = null; null !== revealOrder; ) {
          current = revealOrder.alternate;
          if (null !== current && null === findFirstSuspended(current)) {
            workInProgress2.child = revealOrder;
            break;
          }
          current = revealOrder.sibling;
          revealOrder.sibling = renderLanes2;
          renderLanes2 = revealOrder;
          revealOrder = current;
        }
        initSuspenseListRenderState(
          workInProgress2,
          true,
          renderLanes2,
          null,
          tailMode,
          nextProps
        );
        break;
      case "together":
        initSuspenseListRenderState(
          workInProgress2,
          false,
          null,
          null,
          void 0,
          nextProps
        );
        break;
      default:
        workInProgress2.memoizedState = null;
    }
    return workInProgress2.child;
  }
  function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
    null !== current && (workInProgress2.dependencies = current.dependencies);
    workInProgressRootSkippedLanes |= workInProgress2.lanes;
    if (0 === (renderLanes2 & workInProgress2.childLanes))
      if (null !== current) {
        if (propagateParentContextChanges(
          current,
          workInProgress2,
          renderLanes2,
          false
        ), 0 === (renderLanes2 & workInProgress2.childLanes))
          return null;
      } else return null;
    if (null !== current && workInProgress2.child !== current.child)
      throw Error(formatProdErrorMessage(153));
    if (null !== workInProgress2.child) {
      current = workInProgress2.child;
      renderLanes2 = createWorkInProgress(current, current.pendingProps);
      workInProgress2.child = renderLanes2;
      for (renderLanes2.return = workInProgress2; null !== current.sibling; )
        current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
    }
    return workInProgress2.child;
  }
  function checkScheduledUpdateOrContext(current, renderLanes2) {
    if (0 !== (current.lanes & renderLanes2)) return true;
    current = current.dependencies;
    return null !== current && checkIfContextChanged(current) ? true : false;
  }
  function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
    switch (workInProgress2.tag) {
      case 3:
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        resetHydrationState();
        break;
      case 27:
      case 5:
        pushHostContext(workInProgress2);
        break;
      case 4:
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        break;
      case 10:
        pushProvider(
          workInProgress2,
          workInProgress2.type,
          workInProgress2.memoizedProps.value
        );
        break;
      case 31:
        if (null !== workInProgress2.memoizedState)
          return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
        break;
      case 13:
        var state$102 = workInProgress2.memoizedState;
        if (null !== state$102) {
          if (null !== state$102.dehydrated)
            return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
          if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          current = bailoutOnAlreadyFinishedWork(
            current,
            workInProgress2,
            renderLanes2
          );
          return null !== current ? current.sibling : null;
        }
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        break;
      case 19:
        var didSuspendBefore = 0 !== (current.flags & 128);
        state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
        state$102 || (propagateParentContextChanges(
          current,
          workInProgress2,
          renderLanes2,
          false
        ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
        if (didSuspendBefore) {
          if (state$102)
            return updateSuspenseListComponent(
              current,
              workInProgress2,
              renderLanes2
            );
          workInProgress2.flags |= 128;
        }
        didSuspendBefore = workInProgress2.memoizedState;
        null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
        push(suspenseStackCursor, suspenseStackCursor.current);
        if (state$102) break;
        else return null;
      case 22:
        return workInProgress2.lanes = 0, updateOffscreenComponent(
          current,
          workInProgress2,
          renderLanes2,
          workInProgress2.pendingProps
        );
      case 24:
        pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
    }
    return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  }
  function beginWork(current, workInProgress2, renderLanes2) {
    if (null !== current)
      if (current.memoizedProps !== workInProgress2.pendingProps)
        didReceiveUpdate = true;
      else {
        if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
          return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress2,
            renderLanes2
          );
        didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
      }
    else
      didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
    workInProgress2.lanes = 0;
    switch (workInProgress2.tag) {
      case 16:
        a: {
          var props = workInProgress2.pendingProps;
          current = resolveLazy(workInProgress2.elementType);
          workInProgress2.type = current;
          if ("function" === typeof current)
            shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
              null,
              workInProgress2,
              current,
              props,
              renderLanes2
            )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
              null,
              workInProgress2,
              current,
              props,
              renderLanes2
            ));
          else {
            if (void 0 !== current && null !== current) {
              var $$typeof = current.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                workInProgress2.tag = 11;
                workInProgress2 = updateForwardRef(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                );
                break a;
              } else if ($$typeof === REACT_MEMO_TYPE) {
                workInProgress2.tag = 14;
                workInProgress2 = updateMemoComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                );
                break a;
              }
            }
            workInProgress2 = getComponentNameFromType(current) || current;
            throw Error(formatProdErrorMessage(306, workInProgress2, ""));
          }
        }
        return workInProgress2;
      case 0:
        return updateFunctionComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 1:
        return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
          props,
          workInProgress2.pendingProps
        ), updateClassComponent(
          current,
          workInProgress2,
          props,
          $$typeof,
          renderLanes2
        );
      case 3:
        a: {
          pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          );
          if (null === current) throw Error(formatProdErrorMessage(387));
          props = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          $$typeof = prevState.element;
          cloneUpdateQueue(current, workInProgress2);
          processUpdateQueue(workInProgress2, props, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          props = nextState.cache;
          pushProvider(workInProgress2, CacheContext, props);
          props !== prevState.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          );
          suspendIfUpdateReadFromEntangledAsyncAction();
          props = nextState.element;
          if (prevState.isDehydrated)
            if (prevState = {
              element: props,
              isDehydrated: false,
              cache: nextState.cache
            }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
              workInProgress2 = mountHostRootWithoutHydrating(
                current,
                workInProgress2,
                props,
                renderLanes2
              );
              break a;
            } else if (props !== $$typeof) {
              $$typeof = createCapturedValueAtFiber(
                Error(formatProdErrorMessage(424)),
                workInProgress2
              );
              queueHydrationError($$typeof);
              workInProgress2 = mountHostRootWithoutHydrating(
                current,
                workInProgress2,
                props,
                renderLanes2
              );
              break a;
            } else {
              current = workInProgress2.stateNode.containerInfo;
              switch (current.nodeType) {
                case 9:
                  current = current.body;
                  break;
                default:
                  current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
              }
              nextHydratableInstance = getNextHydratable(current.firstChild);
              hydrationParentFiber = workInProgress2;
              isHydrating = true;
              hydrationErrors = null;
              rootOrSingletonContext = true;
              renderLanes2 = mountChildFibers(
                workInProgress2,
                null,
                props,
                renderLanes2
              );
              for (workInProgress2.child = renderLanes2; renderLanes2; )
                renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
            }
          else {
            resetHydrationState();
            if (props === $$typeof) {
              workInProgress2 = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              break a;
            }
            reconcileChildren(current, workInProgress2, props, renderLanes2);
          }
          workInProgress2 = workInProgress2.child;
        }
        return workInProgress2;
      case 26:
        return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
          workInProgress2.type,
          null,
          workInProgress2.pendingProps,
          null
        )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
          rootInstanceStackCursor.current
        ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
          workInProgress2.type,
          current.memoizedProps,
          workInProgress2.pendingProps,
          current.memoizedState
        ), null;
      case 27:
        return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
          workInProgress2.type,
          workInProgress2.pendingProps,
          rootInstanceStackCursor.current
        ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
      case 5:
        if (null === current && isHydrating) {
          if ($$typeof = props = nextHydratableInstance)
            props = canHydrateInstance(
              props,
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
          $$typeof || throwOnHydrationMismatch(workInProgress2);
        }
        pushHostContext(workInProgress2);
        $$typeof = workInProgress2.type;
        prevState = workInProgress2.pendingProps;
        nextState = null !== current ? current.memoizedProps : null;
        props = prevState.children;
        shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
        null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
          current,
          workInProgress2,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes2
        ), HostTransitionContext._currentValue = $$typeof);
        markRef(current, workInProgress2);
        reconcileChildren(current, workInProgress2, props, renderLanes2);
        return workInProgress2.child;
      case 6:
        if (null === current && isHydrating) {
          if (current = renderLanes2 = nextHydratableInstance)
            renderLanes2 = canHydrateTextInstance(
              renderLanes2,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
          current || throwOnHydrationMismatch(workInProgress2);
        }
        return null;
      case 13:
        return updateSuspenseComponent(current, workInProgress2, renderLanes2);
      case 4:
        return pushHostContainer(
          workInProgress2,
          workInProgress2.stateNode.containerInfo
        ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          props,
          renderLanes2
        ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
      case 11:
        return updateForwardRef(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 7:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps,
          renderLanes2
        ), workInProgress2.child;
      case 8:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 12:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 10:
        return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
      case 9:
        return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
      case 14:
        return updateMemoComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 15:
        return updateSimpleMemoComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 19:
        return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
      case 31:
        return updateActivityComponent(current, workInProgress2, renderLanes2);
      case 22:
        return updateOffscreenComponent(
          current,
          workInProgress2,
          renderLanes2,
          workInProgress2.pendingProps
        );
      case 24:
        return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
          workInProgress2,
          [CacheContext],
          renderLanes2,
          true
        ))), reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 29:
        throw workInProgress2.pendingProps;
    }
    throw Error(formatProdErrorMessage(156, workInProgress2.tag));
  }
  function markUpdate(workInProgress2) {
    workInProgress2.flags |= 4;
  }
  function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
    if (type = 0 !== (workInProgress2.mode & 32)) type = false;
    if (type) {
      if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
        if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
        else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    } else workInProgress2.flags &= -16777217;
  }
  function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
    if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
      workInProgress2.flags &= -16777217;
    else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
      if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
      else
        throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
  }
  function scheduleRetryEffect(workInProgress2, retryQueue) {
    null !== retryQueue && (workInProgress2.flags |= 4);
    workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
  }
  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    if (!isHydrating)
      switch (renderState.tailMode) {
        case "hidden":
          hasRenderedATailFallback = renderState.tail;
          for (var lastTailNode = null; null !== hasRenderedATailFallback; )
            null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
          null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
          break;
        case "collapsed":
          lastTailNode = renderState.tail;
          for (var lastTailNode$106 = null; null !== lastTailNode; )
            null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
          null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
      }
  }
  function bubbleProperties(completedWork) {
    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
    if (didBailout)
      for (var child$107 = completedWork.child; null !== child$107; )
        newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
    else
      for (child$107 = completedWork.child; null !== child$107; )
        newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
    completedWork.subtreeFlags |= subtreeFlags;
    completedWork.childLanes = newChildLanes;
    return didBailout;
  }
  function completeWork(current, workInProgress2, renderLanes2) {
    var newProps = workInProgress2.pendingProps;
    popTreeContext(workInProgress2);
    switch (workInProgress2.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bubbleProperties(workInProgress2), null;
      case 1:
        return bubbleProperties(workInProgress2), null;
      case 3:
        renderLanes2 = workInProgress2.stateNode;
        newProps = null;
        null !== current && (newProps = current.memoizedState.cache);
        workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
        popProvider(CacheContext);
        popHostContainer();
        renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
        if (null === current || null === current.child)
          popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
        bubbleProperties(workInProgress2);
        return null;
      case 26:
        var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
        null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
          workInProgress2,
          type,
          null,
          newProps,
          renderLanes2
        ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
          workInProgress2,
          type,
          current,
          newProps,
          renderLanes2
        ));
        return null;
      case 27:
        popHostContext(workInProgress2);
        renderLanes2 = rootInstanceStackCursor.current;
        type = workInProgress2.type;
        if (null !== current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if (!newProps) {
            if (null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress2);
            return null;
          }
          current = contextStackCursor.current;
          popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
        }
        bubbleProperties(workInProgress2);
        return null;
      case 5:
        popHostContext(workInProgress2);
        type = workInProgress2.type;
        if (null !== current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if (!newProps) {
            if (null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress2);
            return null;
          }
          nextResource = contextStackCursor.current;
          if (popHydrationState(workInProgress2))
            prepareToHydrateHostInstance(workInProgress2);
          else {
            var ownerDocument = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            );
            switch (nextResource) {
              case 1:
                nextResource = ownerDocument.createElementNS(
                  "http://www.w3.org/2000/svg",
                  type
                );
                break;
              case 2:
                nextResource = ownerDocument.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  type
                );
                break;
              default:
                switch (type) {
                  case "svg":
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/2000/svg",
                      type
                    );
                    break;
                  case "math":
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      type
                    );
                    break;
                  case "script":
                    nextResource = ownerDocument.createElement("div");
                    nextResource.innerHTML = "<script><\/script>";
                    nextResource = nextResource.removeChild(
                      nextResource.firstChild
                    );
                    break;
                  case "select":
                    nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                      is: newProps.is
                    }) : ownerDocument.createElement("select");
                    newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                    break;
                  default:
                    nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                }
            }
            nextResource[internalInstanceKey] = workInProgress2;
            nextResource[internalPropsKey] = newProps;
            a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
              if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                nextResource.appendChild(ownerDocument.stateNode);
              else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                ownerDocument.child.return = ownerDocument;
                ownerDocument = ownerDocument.child;
                continue;
              }
              if (ownerDocument === workInProgress2) break a;
              for (; null === ownerDocument.sibling; ) {
                if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                  break a;
                ownerDocument = ownerDocument.return;
              }
              ownerDocument.sibling.return = ownerDocument.return;
              ownerDocument = ownerDocument.sibling;
            }
            workInProgress2.stateNode = nextResource;
            a: switch (setInitialProperties(nextResource, type, newProps), type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                newProps = !!newProps.autoFocus;
                break a;
              case "img":
                newProps = true;
                break a;
              default:
                newProps = false;
            }
            newProps && markUpdate(workInProgress2);
          }
        }
        bubbleProperties(workInProgress2);
        preloadInstanceAndSuspendIfNeeded(
          workInProgress2,
          workInProgress2.type,
          null === current ? null : current.memoizedProps,
          workInProgress2.pendingProps,
          renderLanes2
        );
        return null;
      case 6:
        if (current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if ("string" !== typeof newProps && null === workInProgress2.stateNode)
            throw Error(formatProdErrorMessage(166));
          current = rootInstanceStackCursor.current;
          if (popHydrationState(workInProgress2)) {
            current = workInProgress2.stateNode;
            renderLanes2 = workInProgress2.memoizedProps;
            newProps = null;
            type = hydrationParentFiber;
            if (null !== type)
              switch (type.tag) {
                case 27:
                case 5:
                  newProps = type.memoizedProps;
              }
            current[internalInstanceKey] = workInProgress2;
            current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
            current || throwOnHydrationMismatch(workInProgress2, true);
          } else
            current = getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
        }
        bubbleProperties(workInProgress2);
        return null;
      case 31:
        renderLanes2 = workInProgress2.memoizedState;
        if (null === current || null !== current.memoizedState) {
          newProps = popHydrationState(workInProgress2);
          if (null !== renderLanes2) {
            if (null === current) {
              if (!newProps) throw Error(formatProdErrorMessage(318));
              current = workInProgress2.memoizedState;
              current = null !== current ? current.dehydrated : null;
              if (!current) throw Error(formatProdErrorMessage(557));
              current[internalInstanceKey] = workInProgress2;
            } else
              resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
            bubbleProperties(workInProgress2);
            current = false;
          } else
            renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
          if (!current) {
            if (workInProgress2.flags & 256)
              return popSuspenseHandler(workInProgress2), workInProgress2;
            popSuspenseHandler(workInProgress2);
            return null;
          }
          if (0 !== (workInProgress2.flags & 128))
            throw Error(formatProdErrorMessage(558));
        }
        bubbleProperties(workInProgress2);
        return null;
      case 13:
        newProps = workInProgress2.memoizedState;
        if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
          type = popHydrationState(workInProgress2);
          if (null !== newProps && null !== newProps.dehydrated) {
            if (null === current) {
              if (!type) throw Error(formatProdErrorMessage(318));
              type = workInProgress2.memoizedState;
              type = null !== type ? type.dehydrated : null;
              if (!type) throw Error(formatProdErrorMessage(317));
              type[internalInstanceKey] = workInProgress2;
            } else
              resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
            bubbleProperties(workInProgress2);
            type = false;
          } else
            type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
          if (!type) {
            if (workInProgress2.flags & 256)
              return popSuspenseHandler(workInProgress2), workInProgress2;
            popSuspenseHandler(workInProgress2);
            return null;
          }
        }
        popSuspenseHandler(workInProgress2);
        if (0 !== (workInProgress2.flags & 128))
          return workInProgress2.lanes = renderLanes2, workInProgress2;
        renderLanes2 = null !== newProps;
        current = null !== current && null !== current.memoizedState;
        renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
        renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
        scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
        bubbleProperties(workInProgress2);
        return null;
      case 4:
        return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
      case 10:
        return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
      case 19:
        pop(suspenseStackCursor);
        newProps = workInProgress2.memoizedState;
        if (null === newProps) return bubbleProperties(workInProgress2), null;
        type = 0 !== (workInProgress2.flags & 128);
        nextResource = newProps.rendering;
        if (null === nextResource)
          if (type) cutOffTailIfNeeded(newProps, false);
          else {
            if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
              for (current = workInProgress2.child; null !== current; ) {
                nextResource = findFirstSuspended(current);
                if (null !== nextResource) {
                  workInProgress2.flags |= 128;
                  cutOffTailIfNeeded(newProps, false);
                  current = nextResource.updateQueue;
                  workInProgress2.updateQueue = current;
                  scheduleRetryEffect(workInProgress2, current);
                  workInProgress2.subtreeFlags = 0;
                  current = renderLanes2;
                  for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                    resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                  push(
                    suspenseStackCursor,
                    suspenseStackCursor.current & 1 | 2
                  );
                  isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                  return workInProgress2.child;
                }
                current = current.sibling;
              }
            null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
          }
        else {
          if (!type)
            if (current = findFirstSuspended(nextResource), null !== current) {
              if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                return bubbleProperties(workInProgress2), null;
            } else
              2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
          newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
        }
        if (null !== newProps.tail)
          return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
            suspenseStackCursor,
            type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
          ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
        bubbleProperties(workInProgress2);
        return null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
      case 24:
        return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(formatProdErrorMessage(156, workInProgress2.tag));
  }
  function unwindWork(current, workInProgress2) {
    popTreeContext(workInProgress2);
    switch (workInProgress2.tag) {
      case 1:
        return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 3:
        return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 26:
      case 27:
      case 5:
        return popHostContext(workInProgress2), null;
      case 31:
        if (null !== workInProgress2.memoizedState) {
          popSuspenseHandler(workInProgress2);
          if (null === workInProgress2.alternate)
            throw Error(formatProdErrorMessage(340));
          resetHydrationState();
        }
        current = workInProgress2.flags;
        return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 13:
        popSuspenseHandler(workInProgress2);
        current = workInProgress2.memoizedState;
        if (null !== current && null !== current.dehydrated) {
          if (null === workInProgress2.alternate)
            throw Error(formatProdErrorMessage(340));
          resetHydrationState();
        }
        current = workInProgress2.flags;
        return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 19:
        return pop(suspenseStackCursor), null;
      case 4:
        return popHostContainer(), null;
      case 10:
        return popProvider(workInProgress2.type), null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 24:
        return popProvider(CacheContext), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function unwindInterruptedWork(current, interruptedWork) {
    popTreeContext(interruptedWork);
    switch (interruptedWork.tag) {
      case 3:
        popProvider(CacheContext);
        popHostContainer();
        break;
      case 26:
      case 27:
      case 5:
        popHostContext(interruptedWork);
        break;
      case 4:
        popHostContainer();
        break;
      case 31:
        null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
        break;
      case 13:
        popSuspenseHandler(interruptedWork);
        break;
      case 19:
        pop(suspenseStackCursor);
        break;
      case 10:
        popProvider(interruptedWork.type);
        break;
      case 22:
      case 23:
        popSuspenseHandler(interruptedWork);
        popHiddenContext();
        null !== current && pop(resumedCache);
        break;
      case 24:
        popProvider(CacheContext);
    }
  }
  function commitHookEffectListMount(flags, finishedWork) {
    try {
      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            lastEffect = void 0;
            var create = updateQueue.create, inst = updateQueue.inst;
            lastEffect = create();
            inst.destroy = lastEffect;
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
    try {
      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            var inst = updateQueue.inst, destroy = inst.destroy;
            if (void 0 !== destroy) {
              inst.destroy = void 0;
              lastEffect = finishedWork;
              var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
              try {
                destroy_();
              } catch (error) {
                captureCommitPhaseError(
                  lastEffect,
                  nearestMountedAncestor,
                  error
                );
              }
            }
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitClassCallbacks(finishedWork) {
    var updateQueue = finishedWork.updateQueue;
    if (null !== updateQueue) {
      var instance = finishedWork.stateNode;
      try {
        commitCallbacks(updateQueue, instance);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
  function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
    instance.props = resolveClassComponentProps(
      current.type,
      current.memoizedProps
    );
    instance.state = current.memoizedState;
    try {
      instance.componentWillUnmount();
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyAttachRef(current, nearestMountedAncestor) {
    try {
      var ref = current.ref;
      if (null !== ref) {
        switch (current.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = current.stateNode;
            break;
          case 30:
            instanceToUse = current.stateNode;
            break;
          default:
            instanceToUse = current.stateNode;
        }
        "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
      }
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyDetachRef(current, nearestMountedAncestor) {
    var ref = current.ref, refCleanup = current.refCleanup;
    if (null !== ref)
      if ("function" === typeof refCleanup)
        try {
          refCleanup();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        } finally {
          current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
        }
      else if ("function" === typeof ref)
        try {
          ref(null);
        } catch (error$140) {
          captureCommitPhaseError(current, nearestMountedAncestor, error$140);
        }
      else ref.current = null;
  }
  function commitHostMount(finishedWork) {
    var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
    try {
      a: switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          props.autoFocus && instance.focus();
          break a;
        case "img":
          props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHostUpdate(finishedWork, newProps, oldProps) {
    try {
      var domElement = finishedWork.stateNode;
      updateProperties(domElement, finishedWork.type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
  }
  function getHostSibling(fiber) {
    a: for (; ; ) {
      for (; null === fiber.sibling; ) {
        if (null === fiber.return || isHostParent(fiber.return)) return null;
        fiber = fiber.return;
      }
      fiber.sibling.return = fiber.return;
      for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
        if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
        if (fiber.flags & 2) continue a;
        if (null === fiber.child || 4 === fiber.tag) continue a;
        else fiber.child.return = fiber, fiber = fiber.child;
      }
      if (!(fiber.flags & 2)) return fiber.stateNode;
    }
  }
  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag)
      node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
      for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
        insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
  }
  function insertOrAppendPlacementNode(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag)
      node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
      for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
        insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
  }
  function commitHostSingletonAcquisition(finishedWork) {
    var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
    try {
      for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
        singleton.removeAttributeNode(attributes[0]);
      setInitialProperties(singleton, type, props);
      singleton[internalInstanceKey] = finishedWork;
      singleton[internalPropsKey] = props;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
  function commitBeforeMutationEffects(root2, firstChild) {
    root2 = root2.containerInfo;
    eventsEnabled = _enabled;
    root2 = getActiveElementDeep(root2);
    if (hasSelectionCapabilities(root2)) {
      if ("selectionStart" in root2)
        var JSCompiler_temp = {
          start: root2.selectionStart,
          end: root2.selectionEnd
        };
      else
        a: {
          JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
          var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
          if (selection && 0 !== selection.rangeCount) {
            JSCompiler_temp = selection.anchorNode;
            var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
            selection = selection.focusOffset;
            try {
              JSCompiler_temp.nodeType, focusNode.nodeType;
            } catch (e$20) {
              JSCompiler_temp = null;
              break a;
            }
            var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
            b: for (; ; ) {
              for (var next; ; ) {
                node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                3 === node.nodeType && (length += node.nodeValue.length);
                if (null === (next = node.firstChild)) break;
                parentNode = node;
                node = next;
              }
              for (; ; ) {
                if (node === root2) break b;
                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                if (null !== (next = node.nextSibling)) break;
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
          } else JSCompiler_temp = null;
        }
      JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
    } else JSCompiler_temp = null;
    selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
    _enabled = false;
    for (nextEffect = firstChild; null !== nextEffect; )
      if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
        root2.return = firstChild, nextEffect = root2;
      else
        for (; null !== nextEffect; ) {
          firstChild = nextEffect;
          focusNode = firstChild.alternate;
          root2 = firstChild.flags;
          switch (firstChild.tag) {
            case 0:
              if (0 !== (root2 & 4) && (root2 = firstChild.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                  anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if (0 !== (root2 & 1024) && null !== focusNode) {
                root2 = void 0;
                JSCompiler_temp = firstChild;
                anchorOffset = focusNode.memoizedProps;
                focusNode = focusNode.memoizedState;
                selection = JSCompiler_temp.stateNode;
                try {
                  var resolvedPrevProps = resolveClassComponentProps(
                    JSCompiler_temp.type,
                    anchorOffset
                  );
                  root2 = selection.getSnapshotBeforeUpdate(
                    resolvedPrevProps,
                    focusNode
                  );
                  selection.__reactInternalSnapshotBeforeUpdate = root2;
                } catch (error) {
                  captureCommitPhaseError(
                    JSCompiler_temp,
                    JSCompiler_temp.return,
                    error
                  );
                }
              }
              break;
            case 3:
              if (0 !== (root2 & 1024)) {
                if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                  clearContainerSparingly(root2);
                else if (1 === JSCompiler_temp)
                  switch (root2.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      clearContainerSparingly(root2);
                      break;
                    default:
                      root2.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
          }
          root2 = firstChild.sibling;
          if (null !== root2) {
            root2.return = firstChild.return;
            nextEffect = root2;
            break;
          }
          nextEffect = firstChild.return;
        }
  }
  function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitHookEffectListMount(5, finishedWork);
        break;
      case 1:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 4)
          if (finishedRoot = finishedWork.stateNode, null === current)
            try {
              finishedRoot.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          else {
            var prevProps = resolveClassComponentProps(
              finishedWork.type,
              current.memoizedProps
            );
            current = current.memoizedState;
            try {
              finishedRoot.componentDidUpdate(
                prevProps,
                current,
                finishedRoot.__reactInternalSnapshotBeforeUpdate
              );
            } catch (error$139) {
              captureCommitPhaseError(
                finishedWork,
                finishedWork.return,
                error$139
              );
            }
          }
        flags & 64 && commitClassCallbacks(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
          current = null;
          if (null !== finishedWork.child)
            switch (finishedWork.child.tag) {
              case 27:
              case 5:
                current = finishedWork.child.stateNode;
                break;
              case 1:
                current = finishedWork.child.stateNode;
            }
          try {
            commitCallbacks(finishedRoot, current);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 27:
        null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        null === current && flags & 4 && commitHostMount(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        break;
      case 31:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
          null,
          finishedWork
        ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
        break;
      case 22:
        flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
        if (!flags) {
          current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
          prevProps = offscreenSubtreeIsHidden;
          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = flags;
          (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            0 !== (finishedWork.subtreeFlags & 8772)
          ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          offscreenSubtreeIsHidden = prevProps;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        }
        break;
      case 30:
        break;
      default:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
    }
  }
  function detachFiberAfterEffects(fiber) {
    var alternate = fiber.alternate;
    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
    fiber.child = null;
    fiber.deletions = null;
    fiber.sibling = null;
    5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
    fiber.stateNode = null;
    fiber.return = null;
    fiber.dependencies = null;
    fiber.memoizedProps = null;
    fiber.memoizedState = null;
    fiber.pendingProps = null;
    fiber.stateNode = null;
    fiber.updateQueue = null;
  }
  var hostParent = null, hostParentIsContainer = false;
  function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
    for (parent = parent.child; null !== parent; )
      commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
  }
  function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
      try {
        injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
      } catch (err) {
      }
    switch (deletedFiber.tag) {
      case 26:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
        break;
      case 27:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
        isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        releaseSingletonInstance(deletedFiber.stateNode);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 5:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      case 6:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = null;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        if (null !== hostParent)
          if (hostParentIsContainer)
            try {
              (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
            } catch (error) {
              captureCommitPhaseError(
                deletedFiber,
                nearestMountedAncestor,
                error
              );
            }
          else
            try {
              hostParent.removeChild(deletedFiber.stateNode);
            } catch (error) {
              captureCommitPhaseError(
                deletedFiber,
                nearestMountedAncestor,
                error
              );
            }
        break;
      case 18:
        null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
          9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
          deletedFiber.stateNode
        ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
        break;
      case 4:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = deletedFiber.stateNode.containerInfo;
        hostParentIsContainer = true;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 1:
        offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
          deletedFiber,
          nearestMountedAncestor,
          prevHostParent
        ));
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 21:
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 22:
        offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        offscreenSubtreeWasHidden = prevHostParent;
        break;
      default:
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
    }
  }
  function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
      finishedRoot = finishedRoot.dehydrated;
      try {
        retryIfBlockedOn(finishedRoot);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
  function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
      try {
        retryIfBlockedOn(finishedRoot);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
  }
  function getRetryCache(finishedWork) {
    switch (finishedWork.tag) {
      case 31:
      case 13:
      case 19:
        var retryCache = finishedWork.stateNode;
        null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
        return retryCache;
      case 22:
        return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
      default:
        throw Error(formatProdErrorMessage(435, finishedWork.tag));
    }
  }
  function attachSuspenseRetryListeners(finishedWork, wakeables) {
    var retryCache = getRetryCache(finishedWork);
    wakeables.forEach(function(wakeable) {
      if (!retryCache.has(wakeable)) {
        retryCache.add(wakeable);
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        wakeable.then(retry, retry);
      }
    });
  }
  function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
    var deletions = parentFiber.deletions;
    if (null !== deletions)
      for (var i2 = 0; i2 < deletions.length; i2++) {
        var childToDelete = deletions[i2], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
        a: for (; null !== parent; ) {
          switch (parent.tag) {
            case 27:
              if (isSingletonScope(parent.type)) {
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              }
              break;
            case 5:
              hostParent = parent.stateNode;
              hostParentIsContainer = false;
              break a;
            case 3:
            case 4:
              hostParent = parent.stateNode.containerInfo;
              hostParentIsContainer = true;
              break a;
          }
          parent = parent.return;
        }
        if (null === hostParent) throw Error(formatProdErrorMessage(160));
        commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
        hostParent = null;
        hostParentIsContainer = false;
        root2 = childToDelete.alternate;
        null !== root2 && (root2.return = null);
        childToDelete.return = null;
      }
    if (parentFiber.subtreeFlags & 13886)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
  }
  var currentHoistableRoot = null;
  function commitMutationEffectsOnFiber(finishedWork, root2) {
    var current = finishedWork.alternate, flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
        break;
      case 1:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
        break;
      case 26:
        var hoistableRoot = currentHoistableRoot;
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (flags & 4) {
          var currentResource = null !== current ? current.memoizedState : null;
          flags = finishedWork.memoizedState;
          if (null === current)
            if (null === flags)
              if (null === finishedWork.stateNode) {
                a: {
                  flags = finishedWork.type;
                  current = finishedWork.memoizedProps;
                  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                  b: switch (flags) {
                    case "title":
                      currentResource = hoistableRoot.getElementsByTagName("title")[0];
                      if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                        currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                      setInitialProperties(currentResource, flags, current);
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                      break a;
                    case "link":
                      var maybeNodes = getHydratableHoistableCache(
                        "link",
                        "href",
                        hoistableRoot
                      ).get(flags + (current.href || ""));
                      if (maybeNodes) {
                        for (var i2 = 0; i2 < maybeNodes.length; i2++)
                          if (currentResource = maybeNodes[i2], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                            maybeNodes.splice(i2, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    case "meta":
                      if (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || ""))) {
                        for (i2 = 0; i2 < maybeNodes.length; i2++)
                          if (currentResource = maybeNodes[i2], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                            maybeNodes.splice(i2, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    default:
                      throw Error(formatProdErrorMessage(468, flags));
                  }
                  currentResource[internalInstanceKey] = finishedWork;
                  markNodeAsHoistable(currentResource);
                  flags = currentResource;
                }
                finishedWork.stateNode = flags;
              } else
                mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                );
            else
              finishedWork.stateNode = acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              );
          else
            currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
              hoistableRoot,
              finishedWork.type,
              finishedWork.stateNode
            ) : acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
        }
        break;
      case 27:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        null !== current && flags & 4 && commitHostUpdate(
          finishedWork,
          finishedWork.memoizedProps,
          current.memoizedProps
        );
        break;
      case 5:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (finishedWork.flags & 32) {
          hoistableRoot = finishedWork.stateNode;
          try {
            setTextContent(hoistableRoot, "");
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
        flags & 1024 && (needsFormReset = true);
        break;
      case 6:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        if (flags & 4) {
          if (null === finishedWork.stateNode)
            throw Error(formatProdErrorMessage(162));
          flags = finishedWork.memoizedProps;
          current = finishedWork.stateNode;
          try {
            current.nodeValue = flags;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 3:
        tagCaches = null;
        hoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(root2.containerInfo);
        recursivelyTraverseMutationEffects(root2, finishedWork);
        currentHoistableRoot = hoistableRoot;
        commitReconciliationEffects(finishedWork);
        if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
          try {
            retryIfBlockedOn(root2.containerInfo);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
        break;
      case 4:
        flags = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(
          finishedWork.stateNode.containerInfo
        );
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        currentHoistableRoot = flags;
        break;
      case 12:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        break;
      case 31:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 13:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 22:
        hoistableRoot = null !== finishedWork.memoizedState;
        var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
        recursivelyTraverseMutationEffects(root2, finishedWork);
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        commitReconciliationEffects(finishedWork);
        if (flags & 8192)
          a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
            if (5 === root2.tag || 26 === root2.tag) {
              if (null === current) {
                wasHidden = current = root2;
                try {
                  if (currentResource = wasHidden.stateNode, hoistableRoot)
                    maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                  else {
                    i2 = wasHidden.stateNode;
                    var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                    i2.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                  }
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if (6 === root2.tag) {
              if (null === current) {
                wasHidden = root2;
                try {
                  wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if (18 === root2.tag) {
              if (null === current) {
                wasHidden = root2;
                try {
                  var instance = wasHidden.stateNode;
                  hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
              root2.child.return = root2;
              root2 = root2.child;
              continue;
            }
            if (root2 === finishedWork) break a;
            for (; null === root2.sibling; ) {
              if (null === root2.return || root2.return === finishedWork) break a;
              current === root2 && (current = null);
              root2 = root2.return;
            }
            current === root2 && (current = null);
            root2.sibling.return = root2.return;
            root2 = root2.sibling;
          }
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
        break;
      case 19:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
    }
  }
  function commitReconciliationEffects(finishedWork) {
    var flags = finishedWork.flags;
    if (flags & 2) {
      try {
        for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
          if (isHostParent(parentFiber)) {
            hostParentFiber = parentFiber;
            break;
          }
          parentFiber = parentFiber.return;
        }
        if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
        switch (hostParentFiber.tag) {
          case 27:
            var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          case 5:
            var parent$141 = hostParentFiber.stateNode;
            hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
            var before$142 = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
            break;
          case 3:
          case 4:
            var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(
              finishedWork,
              before$144,
              parent$143
            );
            break;
          default:
            throw Error(formatProdErrorMessage(161));
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
      finishedWork.flags &= -3;
    }
    flags & 4096 && (finishedWork.flags &= -4097);
  }
  function recursivelyResetForms(parentFiber) {
    if (parentFiber.subtreeFlags & 1024)
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var fiber = parentFiber;
        recursivelyResetForms(fiber);
        5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
        parentFiber = parentFiber.sibling;
      }
  }
  function recursivelyTraverseLayoutEffects(root2, parentFiber) {
    if (parentFiber.subtreeFlags & 8772)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
  }
  function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedWork = parentFiber;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          releaseSingletonInstance(finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          commitHookEffectListMount(4, finishedWork);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          current = finishedWork;
          finishedRoot = current.stateNode;
          if ("function" === typeof finishedRoot.componentDidMount)
            try {
              finishedRoot.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(current, current.return, error);
            }
          current = finishedWork;
          finishedRoot = current.updateQueue;
          if (null !== finishedRoot) {
            var instance = current.stateNode;
            try {
              var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
              if (null !== hiddenCallbacks)
                for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                  callCallback(hiddenCallbacks[finishedRoot], instance);
            } catch (error) {
              captureCommitPhaseError(current, current.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          break;
        case 31:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitOffscreenPassiveMountEffects(current, finishedWork) {
    var previousCache = null;
    null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
    current = null;
    null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
    current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
  }
  function commitCachePassiveMountEffect(current, finishedWork) {
    current = null;
    null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
    finishedWork = finishedWork.memoizedState.cache;
    finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
  }
  function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitPassiveMountOnFiber(
          root2,
          parentFiber,
          committedLanes,
          committedTransitions
        ), parentFiber = parentFiber.sibling;
  }
  function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && commitHookEffectListMount(9, finishedWork);
        break;
      case 1:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 3:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
        break;
      case 12:
        if (flags & 2048) {
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          finishedRoot = finishedWork.stateNode;
          try {
            var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
            "function" === typeof onPostCommit && onPostCommit(
              id,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        } else
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
        break;
      case 31:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 13:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 23:
        break;
      case 22:
        _finishedWork$memoize2 = finishedWork.stateNode;
        id = finishedWork.alternate;
        null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          0 !== (finishedWork.subtreeFlags & 10256) || false
        ));
        flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
        break;
      case 24:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
    }
  }
  function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          commitHookEffectListMount(8, finishedWork);
          break;
        case 23:
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          ) : recursivelyTraverseAtomicPassiveEffects(
            finishedRoot,
            finishedWork
          ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          ));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 22:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
  }
  var suspenseyCommitFlag = 8192;
  function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
    if (parentFiber.subtreeFlags & suspenseyCommitFlag)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        accumulateSuspenseyCommitOnFiber(
          parentFiber,
          committedLanes,
          suspendedState
        ), parentFiber = parentFiber.sibling;
  }
  function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
    switch (fiber.tag) {
      case 26:
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
        fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
          suspendedState,
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
        break;
      case 5:
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
        break;
      case 3:
      case 4:
        var previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
        currentHoistableRoot = previousHoistableRoot;
        break;
      case 22:
        null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        ));
        break;
      default:
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
    }
  }
  function detachAlternateSiblings(parentFiber) {
    var previousFiber = parentFiber.alternate;
    if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
      previousFiber.child = null;
      do
        previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
      while (null !== parentFiber);
    }
  }
  function recursivelyTraversePassiveUnmountEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions)
        for (var i2 = 0; i2 < deletions.length; i2++) {
          var childToDelete = deletions[i2];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
            childToDelete,
            parentFiber
          );
        }
      detachAlternateSiblings(parentFiber);
    }
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function commitPassiveUnmountOnFiber(finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 12:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      default:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
    }
  }
  function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions)
        for (var i2 = 0; i2 < deletions.length; i2++) {
          var childToDelete = deletions[i2];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
            childToDelete,
            parentFiber
          );
        }
      detachAlternateSiblings(parentFiber);
    }
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      deletions = parentFiber;
      switch (deletions.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, deletions, deletions.return);
          recursivelyTraverseDisconnectPassiveEffects(deletions);
          break;
        case 22:
          i2 = deletions.stateNode;
          i2._visibility & 2 && (i2._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(deletions);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
    for (; null !== nextEffect; ) {
      var fiber = nextEffect;
      switch (fiber.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
          break;
        case 23:
        case 22:
          if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
            var cache = fiber.memoizedState.cachePool.pool;
            null != cache && cache.refCount++;
          }
          break;
        case 24:
          releaseCache(fiber.memoizedState.cache);
      }
      cache = fiber.child;
      if (null !== cache) cache.return = fiber, nextEffect = cache;
      else
        a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
          cache = nextEffect;
          var sibling = cache.sibling, returnFiber = cache.return;
          detachFiberAfterEffects(cache);
          if (cache === fiber) {
            nextEffect = null;
            break a;
          }
          if (null !== sibling) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            break a;
          }
          nextEffect = returnFiber;
        }
    }
  }
  var DefaultAsyncDispatcher = {
    getCacheForType: function(resourceType) {
      var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
      return cacheForType;
    },
    cacheSignal: function() {
      return readContext(CacheContext).controller.signal;
    }
  }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
  function requestUpdateLane() {
    return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
  }
  function requestDeferredLane() {
    if (0 === workInProgressDeferredLane)
      if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
        var lane = nextTransitionDeferredLane;
        nextTransitionDeferredLane <<= 1;
        0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
        workInProgressDeferredLane = lane;
      } else workInProgressDeferredLane = 536870912;
    lane = suspenseHandlerStackCursor.current;
    null !== lane && (lane.flags |= 32);
    return workInProgressDeferredLane;
  }
  function scheduleUpdateOnFiber(root2, fiber, lane) {
    if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
      prepareFreshStack(root2, 0), markRootSuspended(
        root2,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    markRootUpdated$1(root2, lane);
    if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
      root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
        root2,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      )), ensureRootIsScheduled(root2);
  }
  function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
    do {
      if (0 === exitStatus) {
        workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
        break;
      } else {
        forceSync = root$jscomp$0.current.alternate;
        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
          exitStatus = renderRootSync(root$jscomp$0, lanes, false);
          renderWasConcurrent = false;
          continue;
        }
        if (2 === exitStatus) {
          renderWasConcurrent = lanes;
          if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
            var JSCompiler_inline_result = 0;
          else
            JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
          if (0 !== JSCompiler_inline_result) {
            lanes = JSCompiler_inline_result;
            a: {
              var root2 = root$jscomp$0;
              exitStatus = workInProgressRootConcurrentErrors;
              var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
              wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
              JSCompiler_inline_result = renderRootSync(
                root2,
                JSCompiler_inline_result,
                false
              );
              if (2 !== JSCompiler_inline_result) {
                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                  root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                  workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                  exitStatus = 4;
                  break a;
                }
                renderWasConcurrent = workInProgressRootRecoverableErrors;
                workInProgressRootRecoverableErrors = exitStatus;
                null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                  workInProgressRootRecoverableErrors,
                  renderWasConcurrent
                ));
              }
              exitStatus = JSCompiler_inline_result;
            }
            renderWasConcurrent = false;
            if (2 !== exitStatus) continue;
          }
        }
        if (1 === exitStatus) {
          prepareFreshStack(root$jscomp$0, 0);
          markRootSuspended(root$jscomp$0, lanes, 0, true);
          break;
        }
        a: {
          shouldTimeSlice = root$jscomp$0;
          renderWasConcurrent = exitStatus;
          switch (renderWasConcurrent) {
            case 0:
            case 1:
              throw Error(formatProdErrorMessage(345));
            case 4:
              if ((lanes & 4194048) !== lanes) break;
            case 6:
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              break a;
            case 2:
              workInProgressRootRecoverableErrors = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(formatProdErrorMessage(329));
          }
          if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
            markRootSuspended(
              shouldTimeSlice,
              lanes,
              workInProgressDeferredLane,
              !workInProgressRootDidSkipSuspendedSiblings
            );
            if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
            pendingEffectsLanes = lanes;
            shouldTimeSlice.timeoutHandle = scheduleTimeout(
              commitRootWhenReady.bind(
                null,
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                "Throttled",
                -0,
                0
              ),
              exitStatus
            );
            break a;
          }
          commitRootWhenReady(
            shouldTimeSlice,
            forceSync,
            workInProgressRootRecoverableErrors,
            workInProgressTransitions,
            workInProgressRootDidIncludeRecursiveRenderUpdate,
            lanes,
            workInProgressDeferredLane,
            workInProgressRootInterleavedUpdatedLanes,
            workInProgressSuspendedRetryLanes,
            workInProgressRootDidSkipSuspendedSiblings,
            renderWasConcurrent,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (1);
    ensureRootIsScheduled(root$jscomp$0);
  }
  function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
    root2.timeoutHandle = -1;
    suspendedCommitReason = finishedWork.subtreeFlags;
    if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
      suspendedCommitReason = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: true,
        waitingForViewTransition: false,
        unsuspend: noop$1
      };
      accumulateSuspenseyCommitOnFiber(
        finishedWork,
        lanes,
        suspendedCommitReason
      );
      var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
      timeoutOffset = waitForCommitToBeReady(
        suspendedCommitReason,
        timeoutOffset
      );
      if (null !== timeoutOffset) {
        pendingEffectsLanes = lanes;
        root2.cancelPendingCommit = timeoutOffset(
          commitRoot.bind(
            null,
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            suspendedCommitReason,
            null,
            completedRenderStartTime,
            completedRenderEndTime
          )
        );
        markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
        return;
      }
    }
    commitRoot(
      root2,
      finishedWork,
      lanes,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    );
  }
  function isRenderConsistentWithExternalStores(finishedWork) {
    for (var node = finishedWork; ; ) {
      var tag = node.tag;
      if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
        for (var i2 = 0; i2 < tag.length; i2++) {
          var check = tag[i2], getSnapshot = check.getSnapshot;
          check = check.value;
          try {
            if (!objectIs(getSnapshot(), check)) return false;
          } catch (error) {
            return false;
          }
        }
      tag = node.child;
      if (node.subtreeFlags & 16384 && null !== tag)
        tag.return = node, node = tag;
      else {
        if (node === finishedWork) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === finishedWork) return true;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return true;
  }
  function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
    suspendedLanes &= ~workInProgressRootPingedLanes;
    suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
    root2.suspendedLanes |= suspendedLanes;
    root2.pingedLanes &= ~suspendedLanes;
    didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
    didAttemptEntireTree = root2.expirationTimes;
    for (var lanes = suspendedLanes; 0 < lanes; ) {
      var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
      didAttemptEntireTree[index$6] = -1;
      lanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
  }
  function flushSyncWork$1() {
    return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
  }
  function resetWorkInProgressStack() {
    if (null !== workInProgress) {
      if (0 === workInProgressSuspendedReason)
        var interruptedWork = workInProgress.return;
      else
        interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
      for (; null !== interruptedWork; )
        unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
      workInProgress = null;
    }
  }
  function prepareFreshStack(root2, lanes) {
    var timeoutHandle = root2.timeoutHandle;
    -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
    timeoutHandle = root2.cancelPendingCommit;
    null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
    pendingEffectsLanes = 0;
    resetWorkInProgressStack();
    workInProgressRoot = root2;
    workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
    workInProgressRootRenderLanes = lanes;
    workInProgressSuspendedReason = 0;
    workInProgressThrownValue = null;
    workInProgressRootDidSkipSuspendedSiblings = false;
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
    workInProgressRootDidAttachPingListener = false;
    workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
    workInProgressRootDidIncludeRecursiveRenderUpdate = false;
    0 !== (lanes & 8) && (lanes |= lanes & 32);
    var allEntangledLanes = root2.entangledLanes;
    if (0 !== allEntangledLanes)
      for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
        var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
        lanes |= root2[index$4];
        allEntangledLanes &= ~lane;
      }
    entangledRenderLanes = lanes;
    finishQueueingConcurrentUpdates();
    return timeoutHandle;
  }
  function handleThrow(root2, thrownValue) {
    currentlyRenderingFiber = null;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
    workInProgressThrownValue = thrownValue;
    null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
      root2,
      createCapturedValueAtFiber(thrownValue, root2.current)
    ));
  }
  function shouldRemainOnPreviousScreen() {
    var handler = suspenseHandlerStackCursor.current;
    return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
  }
  function pushDispatcher() {
    var prevDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
  }
  function pushAsyncDispatcher() {
    var prevAsyncDispatcher = ReactSharedInternals.A;
    ReactSharedInternals.A = DefaultAsyncDispatcher;
    return prevAsyncDispatcher;
  }
  function renderDidSuspendDelayIfPossible() {
    workInProgressRootExitStatus = 4;
    workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
    0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      false
    );
  }
  function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
    if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
      workInProgressTransitions = null, prepareFreshStack(root2, lanes);
    lanes = false;
    var exitStatus = workInProgressRootExitStatus;
    a: do
      try {
        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
          var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
          switch (workInProgressSuspendedReason) {
            case 8:
              resetWorkInProgressStack();
              exitStatus = 6;
              break a;
            case 3:
            case 2:
            case 9:
            case 6:
              null === suspenseHandlerStackCursor.current && (lanes = true);
              var reason = workInProgressSuspendedReason;
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                exitStatus = 0;
                break a;
              }
              break;
            default:
              reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
          }
        }
        workLoopSync();
        exitStatus = workInProgressRootExitStatus;
        break;
      } catch (thrownValue$165) {
        handleThrow(root2, thrownValue$165);
      }
    while (1);
    lanes && root2.shellSuspendCounter++;
    lastContextDependency = currentlyRenderingFiber$1 = null;
    executionContext = prevExecutionContext;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
    return exitStatus;
  }
  function workLoopSync() {
    for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
  }
  function renderRootConcurrent(root2, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
    workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
      root2,
      lanes
    );
    a: do
      try {
        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
          lanes = workInProgress;
          var thrownValue = workInProgressThrownValue;
          b: switch (workInProgressSuspendedReason) {
            case 1:
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
              break;
            case 2:
            case 9:
              if (isThenableResolved(thrownValue)) {
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                replaySuspendedUnitOfWork(lanes);
                break;
              }
              lanes = function() {
                2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                ensureRootIsScheduled(root2);
              };
              thrownValue.then(lanes, lanes);
              break a;
            case 3:
              workInProgressSuspendedReason = 7;
              break a;
            case 4:
              workInProgressSuspendedReason = 5;
              break a;
            case 7:
              isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
              break;
            case 5:
              var resource = null;
              switch (workInProgress.tag) {
                case 26:
                  resource = workInProgress.memoizedState;
                case 5:
                case 27:
                  var hostFiber = workInProgress;
                  if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    var sibling = hostFiber.sibling;
                    if (null !== sibling) workInProgress = sibling;
                    else {
                      var returnFiber = hostFiber.return;
                      null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                    }
                    break b;
                  }
              }
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
              break;
            case 6:
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
              break;
            case 8:
              resetWorkInProgressStack();
              workInProgressRootExitStatus = 6;
              break a;
            default:
              throw Error(formatProdErrorMessage(462));
          }
        }
        workLoopConcurrentByScheduler();
        break;
      } catch (thrownValue$167) {
        handleThrow(root2, thrownValue$167);
      }
    while (1);
    lastContextDependency = currentlyRenderingFiber$1 = null;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    executionContext = prevExecutionContext;
    if (null !== workInProgress) return 0;
    workInProgressRoot = null;
    workInProgressRootRenderLanes = 0;
    finishQueueingConcurrentUpdates();
    return workInProgressRootExitStatus;
  }
  function workLoopConcurrentByScheduler() {
    for (; null !== workInProgress && !shouldYield(); )
      performUnitOfWork(workInProgress);
  }
  function performUnitOfWork(unitOfWork) {
    var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function replaySuspendedUnitOfWork(unitOfWork) {
    var next = unitOfWork;
    var current = next.alternate;
    switch (next.tag) {
      case 15:
      case 0:
        next = replayFunctionComponent(
          current,
          next,
          next.pendingProps,
          next.type,
          void 0,
          workInProgressRootRenderLanes
        );
        break;
      case 11:
        next = replayFunctionComponent(
          current,
          next,
          next.pendingProps,
          next.type.render,
          next.ref,
          workInProgressRootRenderLanes
        );
        break;
      case 5:
        resetHooksOnUnwind(next);
      default:
        unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
    }
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
    lastContextDependency = currentlyRenderingFiber$1 = null;
    resetHooksOnUnwind(unitOfWork);
    thenableState$1 = null;
    thenableIndexCounter$1 = 0;
    var returnFiber = unitOfWork.return;
    try {
      if (throwException(
        root2,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )) {
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        );
        workInProgress = null;
        return;
      }
    } catch (error) {
      if (null !== returnFiber) throw workInProgress = returnFiber, error;
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      );
      workInProgress = null;
      return;
    }
    if (unitOfWork.flags & 32768) {
      if (isHydrating || 1 === suspendedReason) root2 = true;
      else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
        root2 = false;
      else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
        suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
      unwindUnitOfWork(unitOfWork, root2);
    } else completeUnitOfWork(unitOfWork);
  }
  function completeUnitOfWork(unitOfWork) {
    var completedWork = unitOfWork;
    do {
      if (0 !== (completedWork.flags & 32768)) {
        unwindUnitOfWork(
          completedWork,
          workInProgressRootDidSkipSuspendedSiblings
        );
        return;
      }
      unitOfWork = completedWork.return;
      var next = completeWork(
        completedWork.alternate,
        completedWork,
        entangledRenderLanes
      );
      if (null !== next) {
        workInProgress = next;
        return;
      }
      completedWork = completedWork.sibling;
      if (null !== completedWork) {
        workInProgress = completedWork;
        return;
      }
      workInProgress = completedWork = unitOfWork;
    } while (null !== completedWork);
    0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
  }
  function unwindUnitOfWork(unitOfWork, skipSiblings) {
    do {
      var next = unwindWork(unitOfWork.alternate, unitOfWork);
      if (null !== next) {
        next.flags &= 32767;
        workInProgress = next;
        return;
      }
      next = unitOfWork.return;
      null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
      if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
        workInProgress = unitOfWork;
        return;
      }
      workInProgress = unitOfWork = next;
    } while (null !== unitOfWork);
    workInProgressRootExitStatus = 6;
    workInProgress = null;
  }
  function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
    root2.cancelPendingCommit = null;
    do
      flushPendingEffects();
    while (0 !== pendingEffectsStatus);
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    if (null !== finishedWork) {
      if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
      didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
      didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
      markRootFinished(
        root2,
        lanes,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
      root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
      pendingFinishedWork = finishedWork;
      pendingEffectsRoot = root2;
      pendingEffectsLanes = lanes;
      pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
      pendingPassiveTransitions = transitions;
      pendingRecoverableErrors = recoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
        flushPassiveEffects();
        return null;
      })) : (root2.callbackNode = null, root2.callbackPriority = 0);
      recoverableErrors = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
        recoverableErrors = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        transitions = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        spawnedLane = executionContext;
        executionContext |= 4;
        try {
          commitBeforeMutationEffects(root2, finishedWork, lanes);
        } finally {
          executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
        }
      }
      pendingEffectsStatus = 1;
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
    }
  }
  function flushMutationEffects() {
    if (1 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
        rootMutationHasEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitMutationEffectsOnFiber(finishedWork, root2);
          var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
            priorFocusedElem.ownerDocument.documentElement,
            priorFocusedElem
          )) {
            if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
              var start = priorSelectionRange.start, end = priorSelectionRange.end;
              void 0 === end && (end = start);
              if ("selectionStart" in priorFocusedElem)
                priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                  end,
                  priorFocusedElem.value.length
                );
              else {
                var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                if (win.getSelection) {
                  var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                  !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                  var startMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    start$jscomp$0
                  ), endMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    end$jscomp$0
                  );
                  if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                    var range = doc.createRange();
                    range.setStart(startMarker.node, startMarker.offset);
                    selection.removeAllRanges();
                    start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                  }
                }
              }
            }
            doc = [];
            for (selection = priorFocusedElem; selection = selection.parentNode; )
              1 === selection.nodeType && doc.push({
                element: selection,
                left: selection.scrollLeft,
                top: selection.scrollTop
              });
            "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
            for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
              var info = doc[priorFocusedElem];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
          _enabled = !!eventsEnabled;
          selectionInformation = eventsEnabled = null;
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
        }
      }
      root2.current = finishedWork;
      pendingEffectsStatus = 2;
    }
  }
  function flushLayoutEffects() {
    if (2 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
      if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
        rootHasLayoutEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
        }
      }
      pendingEffectsStatus = 3;
    }
  }
  function flushSpawnedWork() {
    if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      requestPaint();
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
      var remainingLanes = root2.pendingLanes;
      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
      lanesToEventPriority(lanes);
      finishedWork = finishedWork.stateNode;
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
        try {
          injectedHook.onCommitFiberRoot(
            rendererID,
            finishedWork,
            void 0,
            128 === (finishedWork.current.flags & 128)
          );
        } catch (err) {
        }
      if (null !== recoverableErrors) {
        finishedWork = ReactSharedInternals.T;
        remainingLanes = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        ReactSharedInternals.T = null;
        try {
          for (var onRecoverableError = root2.onRecoverableError, i2 = 0; i2 < recoverableErrors.length; i2++) {
            var recoverableError = recoverableErrors[i2];
            onRecoverableError(recoverableError.value, {
              componentStack: recoverableError.stack
            });
          }
        } finally {
          ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
        }
      }
      0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
      ensureRootIsScheduled(root2);
      remainingLanes = root2.pendingLanes;
      0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
      flushSyncWorkAcrossRoots_impl(0);
    }
  }
  function releaseRootPooledCache(root2, remainingLanes) {
    0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
  }
  function flushPendingEffects() {
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
    return flushPassiveEffects();
  }
  function flushPassiveEffects() {
    if (5 !== pendingEffectsStatus) return false;
    var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
    pendingEffectsRemainingLanes = 0;
    var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
      ReactSharedInternals.T = null;
      renderPriority = pendingPassiveTransitions;
      pendingPassiveTransitions = null;
      var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
      pendingEffectsStatus = 0;
      pendingFinishedWork = pendingEffectsRoot = null;
      pendingEffectsLanes = 0;
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      commitPassiveUnmountOnFiber(root$jscomp$0.current);
      commitPassiveMountOnFiber(
        root$jscomp$0,
        root$jscomp$0.current,
        lanes,
        renderPriority
      );
      executionContext = prevExecutionContext;
      flushSyncWorkAcrossRoots_impl(0, false);
      if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
        try {
          injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
        } catch (err) {
        }
      return true;
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
    }
  }
  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
    rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
    null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
  }
  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
    if (3 === sourceFiber.tag)
      captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    else
      for (; null !== nearestMountedAncestor; ) {
        if (3 === nearestMountedAncestor.tag) {
          captureCommitPhaseErrorOnRoot(
            nearestMountedAncestor,
            sourceFiber,
            error
          );
          break;
        } else if (1 === nearestMountedAncestor.tag) {
          var instance = nearestMountedAncestor.stateNode;
          if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
            error = createClassErrorUpdate(2);
            instance = enqueueUpdate(nearestMountedAncestor, error, 2);
            null !== instance && (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
            break;
          }
        }
        nearestMountedAncestor = nearestMountedAncestor.return;
      }
  }
  function attachPingListener(root2, wakeable, lanes) {
    var pingCache = root2.pingCache;
    if (null === pingCache) {
      pingCache = root2.pingCache = new PossiblyWeakMap();
      var threadIDs = /* @__PURE__ */ new Set();
      pingCache.set(wakeable, threadIDs);
    } else
      threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
    threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
  }
  function pingSuspendedRoot(root2, wakeable, pingedLanes) {
    var pingCache = root2.pingCache;
    null !== pingCache && pingCache.delete(wakeable);
    root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
    root2.warmLanes &= ~pingedLanes;
    workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
    ensureRootIsScheduled(root2);
  }
  function retryTimedOutBoundary(boundaryFiber, retryLane) {
    0 === retryLane && (retryLane = claimNextRetryLane());
    boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
    null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
  }
  function retryDehydratedSuspenseBoundary(boundaryFiber) {
    var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
    null !== suspenseState && (retryLane = suspenseState.retryLane);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function resolveRetryWakeable(boundaryFiber, wakeable) {
    var retryLane = 0;
    switch (boundaryFiber.tag) {
      case 31:
      case 13:
        var retryCache = boundaryFiber.stateNode;
        var suspenseState = boundaryFiber.memoizedState;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        break;
      case 19:
        retryCache = boundaryFiber.stateNode;
        break;
      case 22:
        retryCache = boundaryFiber.stateNode._retryCache;
        break;
      default:
        throw Error(formatProdErrorMessage(314));
    }
    null !== retryCache && retryCache.delete(wakeable);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function scheduleCallback$1(priorityLevel, callback) {
    return scheduleCallback$3(priorityLevel, callback);
  }
  var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
  function ensureRootIsScheduled(root2) {
    root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
    mightHavePendingSyncWork = true;
    didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
  }
  function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
    if (!isFlushingWork && mightHavePendingSyncWork) {
      isFlushingWork = true;
      do {
        var didPerformSomeWork = false;
        for (var root$170 = firstScheduledRoot; null !== root$170; ) {
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$170.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
              JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
              JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
            }
            0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
          } else
            JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
              root$170,
              root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
              null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
            ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
          root$170 = root$170.next;
        }
      } while (didPerformSomeWork);
      isFlushingWork = false;
    }
  }
  function processRootScheduleInImmediateTask() {
    processRootScheduleInMicrotask();
  }
  function processRootScheduleInMicrotask() {
    mightHavePendingSyncWork = didScheduleMicrotask = false;
    var syncTransitionLanes = 0;
    0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
    for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
      var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
      if (0 === nextLanes)
        root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
      else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
        mightHavePendingSyncWork = true;
      root2 = next;
    }
    0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
    0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
  }
  function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
    for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
      var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
      if (-1 === expirationTime) {
        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
          expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
      } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
      lanes &= ~lane;
    }
    currentTime = workInProgressRoot;
    suspendedLanes = workInProgressRootRenderLanes;
    suspendedLanes = getNextLanes(
      root2,
      root2 === currentTime ? suspendedLanes : 0,
      null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
    );
    pingedLanes = root2.callbackNode;
    if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
      return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
    if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
      currentTime = suspendedLanes & -suspendedLanes;
      if (currentTime === root2.callbackPriority) return currentTime;
      null !== pingedLanes && cancelCallback$1(pingedLanes);
      switch (lanesToEventPriority(suspendedLanes)) {
        case 2:
        case 8:
          suspendedLanes = UserBlockingPriority;
          break;
        case 32:
          suspendedLanes = NormalPriority$1;
          break;
        case 268435456:
          suspendedLanes = IdlePriority;
          break;
        default:
          suspendedLanes = NormalPriority$1;
      }
      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
      suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
      root2.callbackPriority = currentTime;
      root2.callbackNode = suspendedLanes;
      return currentTime;
    }
    null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
    root2.callbackPriority = 2;
    root2.callbackNode = null;
    return 2;
  }
  function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
    if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
      return root2.callbackNode = null, root2.callbackPriority = 0, null;
    var originalCallbackNode = root2.callbackNode;
    if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
      return null;
    var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
    workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
      root2,
      root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
      null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
    );
    if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
    performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
    scheduleTaskForRootDuringMicrotask(root2, now());
    return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
  }
  function performSyncWorkOnRoot(root2, lanes) {
    if (flushPendingEffects()) return null;
    performWorkOnRoot(root2, lanes, true);
  }
  function scheduleImmediateRootScheduleTask() {
    scheduleMicrotask(function() {
      0 !== (executionContext & 6) ? scheduleCallback$3(
        ImmediatePriority,
        processRootScheduleInImmediateTask
      ) : processRootScheduleInMicrotask();
    });
  }
  function requestTransitionLane() {
    if (0 === currentEventTransitionLane) {
      var actionScopeLane = currentEntangledLane;
      0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
      currentEventTransitionLane = actionScopeLane;
    }
    return currentEventTransitionLane;
  }
  function coerceFormActionProp(actionProp) {
    return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
  }
  function createFormDataWithSubmitter(form, submitter) {
    var temp = submitter.ownerDocument.createElement("input");
    temp.name = submitter.name;
    temp.value = submitter.value;
    form.id && temp.setAttribute("form", form.id);
    submitter.parentNode.insertBefore(temp, submitter);
    form = new FormData(form);
    temp.parentNode.removeChild(temp);
    return form;
  }
  function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
    if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
      var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ), submitter = nativeEvent.submitter;
      submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
      var event = new SyntheticEvent(
        "action",
        "action",
        null,
        nativeEvent,
        nativeEventTarget
      );
      dispatchQueue.push({
        event,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (nativeEvent.defaultPrevented) {
                if (0 !== currentEventTransitionLane) {
                  var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                  startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    null,
                    formData
                  );
                }
              } else
                "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                  maybeTargetInst,
                  {
                    pending: true,
                    data: formData,
                    method: nativeEventTarget.method,
                    action
                  },
                  action,
                  formData
                ));
            },
            currentTarget: nativeEventTarget
          }
        ]
      });
    }
  }
  for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
    var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
    registerSimpleEvent(
      domEventName$jscomp$inline_1579,
      "on" + capitalizedEvent$jscomp$inline_1580
    );
  }
  registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
  registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
  registerSimpleEvent(ANIMATION_START, "onAnimationStart");
  registerSimpleEvent("dblclick", "onDoubleClick");
  registerSimpleEvent("focusin", "onFocus");
  registerSimpleEvent("focusout", "onBlur");
  registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
  registerSimpleEvent(TRANSITION_START, "onTransitionStart");
  registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
  registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
  registerTwoPhaseEvent(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  );
  registerTwoPhaseEvent(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  );
  registerTwoPhaseEvent("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  registerTwoPhaseEvent(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  );
  registerTwoPhaseEvent(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  );
  registerTwoPhaseEvent(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
  );
  function processDispatchQueue(dispatchQueue, eventSystemFlags) {
    eventSystemFlags = 0 !== (eventSystemFlags & 4);
    for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
      var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event;
      _dispatchQueue$i = _dispatchQueue$i.listeners;
      a: {
        var previousInstance = void 0;
        if (eventSystemFlags)
          for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
            var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped())
              break a;
            previousInstance = _dispatchListeners$i;
            event.currentTarget = currentTarget;
            try {
              previousInstance(event);
            } catch (error) {
              reportGlobalError(error);
            }
            event.currentTarget = null;
            previousInstance = instance;
          }
        else
          for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
            _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
            instance = _dispatchListeners$i.instance;
            currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped())
              break a;
            previousInstance = _dispatchListeners$i;
            event.currentTarget = currentTarget;
            try {
              previousInstance(event);
            } catch (error) {
              reportGlobalError(error);
            }
            event.currentTarget = null;
            previousInstance = instance;
          }
      }
    }
  }
  function listenToNonDelegatedEvent(domEventName, targetElement) {
    var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
    void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
    var listenerSetKey = domEventName + "__bubble";
    JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
  }
  function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
    var eventSystemFlags = 0;
    isCapturePhaseListener && (eventSystemFlags |= 4);
    addTrappedEventListener(
      target,
      domEventName,
      eventSystemFlags,
      isCapturePhaseListener
    );
  }
  var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
  function listenToAllSupportedEvents(rootContainerElement) {
    if (!rootContainerElement[listeningMarker]) {
      rootContainerElement[listeningMarker] = true;
      allNativeEvents.forEach(function(domEventName) {
        "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
      });
      var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
    }
  }
  function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
    switch (getEventPriority(domEventName)) {
      case 2:
        var listenerWrapper = dispatchDiscreteEvent;
        break;
      case 8:
        listenerWrapper = dispatchContinuousEvent;
        break;
      default:
        listenerWrapper = dispatchEvent;
    }
    eventSystemFlags = listenerWrapper.bind(
      null,
      domEventName,
      eventSystemFlags,
      targetContainer
    );
    listenerWrapper = void 0;
    !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
    isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      capture: true,
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
  }
  function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
    var ancestorInst = targetInst$jscomp$0;
    if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
      a: for (; ; ) {
        if (null === targetInst$jscomp$0) return;
        var nodeTag = targetInst$jscomp$0.tag;
        if (3 === nodeTag || 4 === nodeTag) {
          var container = targetInst$jscomp$0.stateNode.containerInfo;
          if (container === targetContainer) break;
          if (4 === nodeTag)
            for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
              var grandTag = nodeTag.tag;
              if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                return;
              nodeTag = nodeTag.return;
            }
          for (; null !== container; ) {
            nodeTag = getClosestInstanceFromNode(container);
            if (null === nodeTag) return;
            grandTag = nodeTag.tag;
            if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
              targetInst$jscomp$0 = ancestorInst = nodeTag;
              continue a;
            }
            container = container.parentNode;
          }
        }
        targetInst$jscomp$0 = targetInst$jscomp$0.return;
      }
    batchedUpdates$1(function() {
      var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
      a: {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (void 0 !== reactName) {
          var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (0 === getEventCharCode(nativeEvent)) break a;
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (2 === nativeEvent.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
            case "scrollend":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
            case "toggle":
            case "beforetoggle":
              SyntheticEventCtor = SyntheticToggleEvent;
          }
          var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
          inCapturePhase = [];
          for (var instance = targetInst, lastHostComponent; null !== instance; ) {
            var _instance = instance;
            lastHostComponent = _instance.stateNode;
            _instance = _instance.tag;
            5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
              createDispatchListener(instance, _instance, lastHostComponent)
            ));
            if (accumulateTargetOnly) break;
            instance = instance.return;
          }
          0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
        }
      }
      if (0 === (eventSystemFlags & 7)) {
        a: {
          reactName = "mouseover" === domEventName || "pointerover" === domEventName;
          SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
          if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
            break a;
          if (SyntheticEventCtor || reactName) {
            reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
            if (SyntheticEventCtor) {
              if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                reactEventType = null;
            } else SyntheticEventCtor = null, reactEventType = targetInst;
            if (SyntheticEventCtor !== reactEventType) {
              inCapturePhase = SyntheticMouseEvent;
              _instance = "onMouseLeave";
              reactEventName = "onMouseEnter";
              instance = "mouse";
              if ("pointerout" === domEventName || "pointerover" === domEventName)
                inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
              accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
              lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
              reactName = new inCapturePhase(
                _instance,
                instance + "leave",
                SyntheticEventCtor,
                nativeEvent,
                nativeEventTarget
              );
              reactName.target = accumulateTargetOnly;
              reactName.relatedTarget = lastHostComponent;
              _instance = null;
              getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
              accumulateTargetOnly = _instance;
              if (SyntheticEventCtor && reactEventType)
                b: {
                  inCapturePhase = getParent;
                  reactEventName = SyntheticEventCtor;
                  instance = reactEventType;
                  lastHostComponent = 0;
                  for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                    lastHostComponent++;
                  _instance = 0;
                  for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                    _instance++;
                  for (; 0 < lastHostComponent - _instance; )
                    reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                  for (; 0 < _instance - lastHostComponent; )
                    instance = inCapturePhase(instance), _instance--;
                  for (; lastHostComponent--; ) {
                    if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                      inCapturePhase = reactEventName;
                      break b;
                    }
                    reactEventName = inCapturePhase(reactEventName);
                    instance = inCapturePhase(instance);
                  }
                  inCapturePhase = null;
                }
              else inCapturePhase = null;
              null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                false
              );
              null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                true
              );
            }
          }
        }
        a: {
          reactName = targetInst ? getNodeFromInstance(targetInst) : window;
          SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
          if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
            var getTargetInstFunc = getTargetInstForChangeEvent;
          else if (isTextInputElement(reactName))
            if (isInputEventSupported)
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              var handleEventFunc = handleEventsForInputEventPolyfill;
            }
          else
            SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
          if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
            createAndAccumulateChangeEvent(
              dispatchQueue,
              getTargetInstFunc,
              nativeEvent,
              nativeEventTarget
            );
            break a;
          }
          handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
          "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
        }
        handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
              activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
            break;
          case "focusout":
            lastSelection = activeElementInst = activeElement = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) break;
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
        var fallbackData;
        if (canUseCompositionEvent)
          b: {
            switch (domEventName) {
              case "compositionstart":
                var eventType = "onCompositionStart";
                break b;
              case "compositionend":
                eventType = "onCompositionEnd";
                break b;
              case "compositionupdate":
                eventType = "onCompositionUpdate";
                break b;
            }
            eventType = void 0;
          }
        else
          isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
        eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
          eventType,
          domEventName,
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
        if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
          eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
            "onBeforeInput",
            "beforeinput",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({
            event: handleEventFunc,
            listeners: eventType
          }), handleEventFunc.data = fallbackData);
        extractEvents$1(
          dispatchQueue,
          domEventName,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
      }
      processDispatchQueue(dispatchQueue, eventSystemFlags);
    });
  }
  function createDispatchListener(instance, listener, currentTarget) {
    return {
      instance,
      listener,
      currentTarget
    };
  }
  function accumulateTwoPhaseListeners(targetFiber, reactName) {
    for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
      var _instance2 = targetFiber, stateNode = _instance2.stateNode;
      _instance2 = _instance2.tag;
      5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
        createDispatchListener(targetFiber, _instance2, stateNode)
      ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
        createDispatchListener(targetFiber, _instance2, stateNode)
      ));
      if (3 === targetFiber.tag) return listeners;
      targetFiber = targetFiber.return;
    }
    return [];
  }
  function getParent(inst) {
    if (null === inst) return null;
    do
      inst = inst.return;
    while (inst && 5 !== inst.tag && 27 !== inst.tag);
    return inst ? inst : null;
  }
  function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
    for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
      var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
      _instance3 = _instance3.tag;
      if (null !== alternate && alternate === common) break;
      5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
        createDispatchListener(target, stateNode, alternate)
      )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
        createDispatchListener(target, stateNode, alternate)
      )));
      target = target.return;
    }
    0 !== listeners.length && dispatchQueue.push({ event, listeners });
  }
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
  function normalizeMarkupForTextOrAttribute(markup) {
    return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
  }
  function checkForUnmatchedText(serverText, clientText) {
    clientText = normalizeMarkupForTextOrAttribute(clientText);
    return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
  }
  function setProp(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "children":
        "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
        break;
      case "className":
        setValueForKnownAttribute(domElement, "class", value);
        break;
      case "tabIndex":
        setValueForKnownAttribute(domElement, "tabindex", value);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        setValueForKnownAttribute(domElement, key, value);
        break;
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "data":
        if ("object" !== tag) {
          setValueForKnownAttribute(domElement, "data", value);
          break;
        }
      case "src":
      case "href":
        if ("" === value && ("a" !== tag || "href" !== key)) {
          domElement.removeAttribute(key);
          break;
        }
        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "action":
      case "formAction":
        if ("function" === typeof value) {
          domElement.setAttribute(
            key,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
            domElement,
            tag,
            "formEncType",
            props.formEncType,
            props,
            null
          ), setProp(
            domElement,
            tag,
            "formMethod",
            props.formMethod,
            props,
            null
          ), setProp(
            domElement,
            tag,
            "formTarget",
            props.formTarget,
            props,
            null
          )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
        if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$1);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value))
            throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "multiple":
        domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "muted":
        domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
          domElement.removeAttribute("xlink:href");
          break;
        }
        key = sanitizeURL("" + value);
        domElement.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          key
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
        break;
      case "capture":
      case "download":
        true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "rowSpan":
      case "start":
        null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
        break;
      case "popover":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        setValueForAttribute(domElement, "popover", value);
        break;
      case "xlinkActuate":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          value
        );
        break;
      case "xlinkArcrole":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          value
        );
        break;
      case "xlinkRole":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          value
        );
        break;
      case "xlinkShow":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          value
        );
        break;
      case "xlinkTitle":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          value
        );
        break;
      case "xlinkType":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          value
        );
        break;
      case "xmlBase":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          value
        );
        break;
      case "xmlLang":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          value
        );
        break;
      case "xmlSpace":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          value
        );
        break;
      case "is":
        setValueForAttribute(domElement, "is", value);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
          key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
    }
  }
  function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value))
            throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "children":
        "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$1);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!registrationNameDependencies.hasOwnProperty(key))
          a: {
            if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
              "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
              domElement.addEventListener(tag, value, props);
              break a;
            }
            key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
          }
    }
  }
  function setInitialProperties(domElement, tag, props) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        var hasSrc = false, hasSrcSet = false, propKey;
        for (propKey in props)
          if (props.hasOwnProperty(propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "src":
                  hasSrc = true;
                  break;
                case "srcSet":
                  hasSrcSet = true;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, propKey, propValue, props, null);
              }
          }
        hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
        hasSrc && setProp(domElement, tag, "src", props.src, props, null);
        return;
      case "input":
        listenToNonDelegatedEvent("invalid", domElement);
        var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
        for (hasSrc in props)
          if (props.hasOwnProperty(hasSrc)) {
            var propValue$184 = props[hasSrc];
            if (null != propValue$184)
              switch (hasSrc) {
                case "name":
                  hasSrcSet = propValue$184;
                  break;
                case "type":
                  propValue = propValue$184;
                  break;
                case "checked":
                  checked = propValue$184;
                  break;
                case "defaultChecked":
                  defaultChecked = propValue$184;
                  break;
                case "value":
                  propKey = propValue$184;
                  break;
                case "defaultValue":
                  defaultValue = propValue$184;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propValue$184)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(domElement, tag, hasSrc, propValue$184, props, null);
              }
          }
        initInput(
          domElement,
          propKey,
          defaultValue,
          checked,
          defaultChecked,
          propValue,
          hasSrcSet,
          false
        );
        return;
      case "select":
        listenToNonDelegatedEvent("invalid", domElement);
        hasSrc = propValue = propKey = null;
        for (hasSrcSet in props)
          if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
            switch (hasSrcSet) {
              case "value":
                propKey = defaultValue;
                break;
              case "defaultValue":
                propValue = defaultValue;
                break;
              case "multiple":
                hasSrc = defaultValue;
              default:
                setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
            }
        tag = propKey;
        props = propValue;
        domElement.multiple = !!hasSrc;
        null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
        return;
      case "textarea":
        listenToNonDelegatedEvent("invalid", domElement);
        propKey = hasSrcSet = hasSrc = null;
        for (propValue in props)
          if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
            switch (propValue) {
              case "value":
                hasSrc = defaultValue;
                break;
              case "defaultValue":
                hasSrcSet = defaultValue;
                break;
              case "children":
                propKey = defaultValue;
                break;
              case "dangerouslySetInnerHTML":
                if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                break;
              default:
                setProp(domElement, tag, propValue, defaultValue, props, null);
            }
        initTextarea(domElement, hasSrc, hasSrcSet, propKey);
        return;
      case "option":
        for (checked in props)
          if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
            switch (checked) {
              case "selected":
                domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                break;
              default:
                setProp(domElement, tag, checked, hasSrc, props, null);
            }
        return;
      case "dialog":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        listenToNonDelegatedEvent("cancel", domElement);
        listenToNonDelegatedEvent("close", domElement);
        break;
      case "iframe":
      case "object":
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "video":
      case "audio":
        for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
          listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
        break;
      case "image":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", domElement);
        break;
      case "embed":
      case "source":
      case "link":
        listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (defaultChecked in props)
          if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
            switch (defaultChecked) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, defaultChecked, hasSrc, props, null);
            }
        return;
      default:
        if (isCustomElement(tag)) {
          for (propValue$184 in props)
            props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
              domElement,
              tag,
              propValue$184,
              hasSrc,
              props,
              void 0
            ));
          return;
        }
    }
    for (defaultValue in props)
      props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
  }
  function updateProperties(domElement, tag, lastProps, nextProps) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
        for (propKey in lastProps) {
          var lastProp = lastProps[propKey];
          if (lastProps.hasOwnProperty(propKey) && null != lastProp)
            switch (propKey) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                lastDefaultValue = lastProp;
              default:
                nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
            }
        }
        for (var propKey$201 in nextProps) {
          var propKey = nextProps[propKey$201];
          lastProp = lastProps[propKey$201];
          if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
            switch (propKey$201) {
              case "type":
                type = propKey;
                break;
              case "name":
                name = propKey;
                break;
              case "checked":
                checked = propKey;
                break;
              case "defaultChecked":
                defaultChecked = propKey;
                break;
              case "value":
                value = propKey;
                break;
              case "defaultValue":
                defaultValue = propKey;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                propKey !== lastProp && setProp(
                  domElement,
                  tag,
                  propKey$201,
                  propKey,
                  nextProps,
                  lastProp
                );
            }
        }
        updateInput(
          domElement,
          value,
          defaultValue,
          lastDefaultValue,
          checked,
          defaultChecked,
          type,
          name
        );
        return;
      case "select":
        propKey = value = defaultValue = propKey$201 = null;
        for (type in lastProps)
          if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
            switch (type) {
              case "value":
                break;
              case "multiple":
                propKey = lastDefaultValue;
              default:
                nextProps.hasOwnProperty(type) || setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
            }
        for (name in nextProps)
          if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
            switch (name) {
              case "value":
                propKey$201 = type;
                break;
              case "defaultValue":
                defaultValue = type;
                break;
              case "multiple":
                value = type;
              default:
                type !== lastDefaultValue && setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
            }
        tag = defaultValue;
        lastProps = value;
        nextProps = propKey;
        null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
        return;
      case "textarea":
        propKey = propKey$201 = null;
        for (defaultValue in lastProps)
          if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
            switch (defaultValue) {
              case "value":
                break;
              case "children":
                break;
              default:
                setProp(domElement, tag, defaultValue, null, nextProps, name);
            }
        for (value in nextProps)
          if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
            switch (value) {
              case "value":
                propKey$201 = name;
                break;
              case "defaultValue":
                propKey = name;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (null != name) throw Error(formatProdErrorMessage(91));
                break;
              default:
                name !== type && setProp(domElement, tag, value, name, nextProps, type);
            }
        updateTextarea(domElement, propKey$201, propKey);
        return;
      case "option":
        for (var propKey$217 in lastProps)
          if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
            switch (propKey$217) {
              case "selected":
                domElement.selected = false;
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  propKey$217,
                  null,
                  nextProps,
                  propKey$201
                );
            }
        for (lastDefaultValue in nextProps)
          if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
            switch (lastDefaultValue) {
              case "selected":
                domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  lastDefaultValue,
                  propKey$201,
                  nextProps,
                  propKey
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var propKey$222 in lastProps)
          propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
        for (checked in nextProps)
          if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
            switch (checked) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey$201)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  checked,
                  propKey$201,
                  nextProps,
                  propKey
                );
            }
        return;
      default:
        if (isCustomElement(tag)) {
          for (var propKey$227 in lastProps)
            propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
              domElement,
              tag,
              propKey$227,
              void 0,
              nextProps,
              propKey$201
            );
          for (defaultChecked in nextProps)
            propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
              domElement,
              tag,
              defaultChecked,
              propKey$201,
              nextProps,
              propKey
            );
          return;
        }
    }
    for (var propKey$232 in lastProps)
      propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
    for (lastProp in nextProps)
      propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
  }
  function isLikelyStaticResource(initiatorType) {
    switch (initiatorType) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return true;
      default:
        return false;
    }
  }
  function estimateBandwidth() {
    if ("function" === typeof performance.getEntriesByType) {
      for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i2 = 0; i2 < resourceEntries.length; i2++) {
        var entry = resourceEntries[i2], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
        if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
          initiatorType = 0;
          duration = entry.responseEnd;
          for (i2 += 1; i2 < resourceEntries.length; i2++) {
            var overlapEntry = resourceEntries[i2], overlapStartTime = overlapEntry.startTime;
            if (overlapStartTime > duration) break;
            var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
            overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
          }
          --i2;
          bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
          count++;
          if (10 < count) break;
        }
      }
      if (0 < count) return bits / count / 1e6;
    }
    return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
  }
  var eventsEnabled = null, selectionInformation = null;
  function getOwnerDocumentFromRootContainer(rootContainerElement) {
    return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
  }
  function getOwnHostContext(namespaceURI) {
    switch (namespaceURI) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function getChildHostContextProd(parentNamespace, type) {
    if (0 === parentNamespace)
      switch (type) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
  }
  function shouldSetTextContent(type, props) {
    return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
  }
  var currentPopstateTransitionEvent = null;
  function shouldAttemptEagerTransition() {
    var event = window.event;
    if (event && "popstate" === event.type) {
      if (event === currentPopstateTransitionEvent) return false;
      currentPopstateTransitionEvent = event;
      return true;
    }
    currentPopstateTransitionEvent = null;
    return false;
  }
  var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
    return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
  } : scheduleTimeout;
  function handleErrorInNextTick(error) {
    setTimeout(function() {
      throw error;
    });
  }
  function isSingletonScope(type) {
    return "head" === type;
  }
  function clearHydrationBoundary(parentInstance, hydrationInstance) {
    var node = hydrationInstance, depth = 0;
    do {
      var nextNode = node.nextSibling;
      parentInstance.removeChild(node);
      if (nextNode && 8 === nextNode.nodeType)
        if (node = nextNode.data, "/$" === node || "/&" === node) {
          if (0 === depth) {
            parentInstance.removeChild(nextNode);
            retryIfBlockedOn(hydrationInstance);
            return;
          }
          depth--;
        } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
          depth++;
        else if ("html" === node)
          releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
        else if ("head" === node) {
          node = parentInstance.ownerDocument.head;
          releaseSingletonInstance(node);
          for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
            var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
            node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
            node$jscomp$0 = nextNode$jscomp$0;
          }
        } else
          "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
      node = nextNode;
    } while (node);
    retryIfBlockedOn(hydrationInstance);
  }
  function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
    var node = suspenseInstance;
    suspenseInstance = 0;
    do {
      var nextNode = node.nextSibling;
      1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
      if (nextNode && 8 === nextNode.nodeType)
        if (node = nextNode.data, "/$" === node)
          if (0 === suspenseInstance) break;
          else suspenseInstance--;
        else
          "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
      node = nextNode;
    } while (node);
  }
  function clearContainerSparingly(container) {
    var nextNode = container.firstChild;
    nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
    for (; nextNode; ) {
      var node = nextNode;
      nextNode = nextNode.nextSibling;
      switch (node.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          clearContainerSparingly(node);
          detachDeletedInstance(node);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if ("stylesheet" === node.rel.toLowerCase()) continue;
      }
      container.removeChild(node);
    }
  }
  function canHydrateInstance(instance, type, props, inRootOrSingleton) {
    for (; 1 === instance.nodeType; ) {
      var anyProps = props;
      if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
        if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
          break;
      } else if (!inRootOrSingleton)
        if ("input" === type && "hidden" === instance.type) {
          var name = null == anyProps.name ? null : "" + anyProps.name;
          if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
            return instance;
        } else return instance;
      else if (!instance[internalHoistableMarker])
        switch (type) {
          case "meta":
            if (!instance.hasAttribute("itemprop")) break;
            return instance;
          case "link":
            name = instance.getAttribute("rel");
            if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
              break;
            else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
              break;
            return instance;
          case "style":
            if (instance.hasAttribute("data-precedence")) break;
            return instance;
          case "script":
            name = instance.getAttribute("src");
            if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
              break;
            return instance;
          default:
            return instance;
        }
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) break;
    }
    return null;
  }
  function canHydrateTextInstance(instance, text, inRootOrSingleton) {
    if ("" === text) return null;
    for (; 3 !== instance.nodeType; ) {
      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
        return null;
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) return null;
    }
    return instance;
  }
  function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
    for (; 8 !== instance.nodeType; ) {
      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
        return null;
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) return null;
    }
    return instance;
  }
  function isSuspenseInstancePending(instance) {
    return "$?" === instance.data || "$~" === instance.data;
  }
  function isSuspenseInstanceFallback(instance) {
    return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
  }
  function registerSuspenseInstanceRetry(instance, callback) {
    var ownerDocument = instance.ownerDocument;
    if ("$~" === instance.data) instance._reactRetry = callback;
    else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
      callback();
    else {
      var listener = function() {
        callback();
        ownerDocument.removeEventListener("DOMContentLoaded", listener);
      };
      ownerDocument.addEventListener("DOMContentLoaded", listener);
      instance._reactRetry = listener;
    }
  }
  function getNextHydratable(node) {
    for (; null != node; node = node.nextSibling) {
      var nodeType = node.nodeType;
      if (1 === nodeType || 3 === nodeType) break;
      if (8 === nodeType) {
        nodeType = node.data;
        if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
          break;
        if ("/$" === nodeType || "/&" === nodeType) return null;
      }
    }
    return node;
  }
  var previousHydratableOnEnteringScopedSingleton = null;
  function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
    hydrationInstance = hydrationInstance.nextSibling;
    for (var depth = 0; hydrationInstance; ) {
      if (8 === hydrationInstance.nodeType) {
        var data = hydrationInstance.data;
        if ("/$" === data || "/&" === data) {
          if (0 === depth)
            return getNextHydratable(hydrationInstance.nextSibling);
          depth--;
        } else
          "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
      }
      hydrationInstance = hydrationInstance.nextSibling;
    }
    return null;
  }
  function getParentHydrationBoundary(targetInstance) {
    targetInstance = targetInstance.previousSibling;
    for (var depth = 0; targetInstance; ) {
      if (8 === targetInstance.nodeType) {
        var data = targetInstance.data;
        if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
          if (0 === depth) return targetInstance;
          depth--;
        } else "/$" !== data && "/&" !== data || depth++;
      }
      targetInstance = targetInstance.previousSibling;
    }
    return null;
  }
  function resolveSingletonInstance(type, props, rootContainerInstance) {
    props = getOwnerDocumentFromRootContainer(rootContainerInstance);
    switch (type) {
      case "html":
        type = props.documentElement;
        if (!type) throw Error(formatProdErrorMessage(452));
        return type;
      case "head":
        type = props.head;
        if (!type) throw Error(formatProdErrorMessage(453));
        return type;
      case "body":
        type = props.body;
        if (!type) throw Error(formatProdErrorMessage(454));
        return type;
      default:
        throw Error(formatProdErrorMessage(451));
    }
  }
  function releaseSingletonInstance(instance) {
    for (var attributes = instance.attributes; attributes.length; )
      instance.removeAttributeNode(attributes[0]);
    detachDeletedInstance(instance);
  }
  var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
  function getHoistableRoot(container) {
    return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
  }
  var previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: flushSyncWork,
    r: requestFormReset,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  function flushSyncWork() {
    var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
    return previousWasRendering || wasRendering;
  }
  function requestFormReset(form) {
    var formInst = getInstanceFromNode(form);
    null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
  }
  var globalDocument = "undefined" === typeof document ? null : document;
  function preconnectAs(rel, href, crossOrigin) {
    var ownerDocument = globalDocument;
    if (ownerDocument && "string" === typeof href && href) {
      var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
      limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
      "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
      preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
    }
  }
  function prefetchDNS(href) {
    previousDispatcher.D(href);
    preconnectAs("dns-prefetch", href, null);
  }
  function preconnect(href, crossOrigin) {
    previousDispatcher.C(href, crossOrigin);
    preconnectAs("preconnect", href, crossOrigin);
  }
  function preload(href, as, options2) {
    previousDispatcher.L(href, as, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href && as) {
      var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
      "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
        options2.imageSrcSet
      ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
        options2.imageSizes
      ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
      var key = preloadSelector;
      switch (as) {
        case "style":
          key = getStyleKey(href);
          break;
        case "script":
          key = getScriptKey(href);
      }
      preloadPropsMap.has(key) || (href = assign(
        {
          rel: "preload",
          href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
          as
        },
        options2
      ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
    }
  }
  function preloadModule(href, options2) {
    previousDispatcher.m(href, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          key = getScriptKey(href);
      }
      if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
              return;
        }
        as = ownerDocument.createElement("link");
        setInitialProperties(as, "link", href);
        markNodeAsHoistable(as);
        ownerDocument.head.appendChild(as);
      }
    }
  }
  function preinitStyle(href, precedence, options2) {
    previousDispatcher.S(href, precedence, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
      precedence = precedence || "default";
      var resource = styles.get(key);
      if (!resource) {
        var state = { loading: 0, preload: null };
        if (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
          state.loading = 5;
        else {
          href = assign(
            { rel: "stylesheet", href, "data-precedence": precedence },
            options2
          );
          (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
          var link = resource = ownerDocument.createElement("link");
          markNodeAsHoistable(link);
          setInitialProperties(link, "link", href);
          link._p = new Promise(function(resolve, reject) {
            link.onload = resolve;
            link.onerror = reject;
          });
          link.addEventListener("load", function() {
            state.loading |= 1;
          });
          link.addEventListener("error", function() {
            state.loading |= 2;
          });
          state.loading |= 4;
          insertStylesheet(resource, precedence, ownerDocument);
        }
        resource = {
          type: "stylesheet",
          instance: resource,
          count: 1,
          state
        };
        styles.set(key, resource);
      }
    }
  }
  function preinitScript(src, options2) {
    previousDispatcher.X(src, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function preinitModuleScript(src, options2) {
    previousDispatcher.M(src, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function getResource(type, currentProps, pendingProps, currentResource) {
    var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
    if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
    switch (type) {
      case "meta":
      case "title":
        return null;
      case "style":
        return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
          JSCompiler_inline_result
        ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
          type = getStyleKey(pendingProps.href);
          var styles$243 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, resource$244 = styles$243.get(type);
          resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
            rel: "preload",
            as: "style",
            href: pendingProps.href,
            crossOrigin: pendingProps.crossOrigin,
            integrity: pendingProps.integrity,
            media: pendingProps.media,
            hrefLang: pendingProps.hrefLang,
            referrerPolicy: pendingProps.referrerPolicy
          }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
            JSCompiler_inline_result,
            type,
            pendingProps,
            resource$244.state
          )));
          if (currentProps && null === currentResource)
            throw Error(formatProdErrorMessage(528, ""));
          return resource$244;
        }
        if (currentProps && null !== currentResource)
          throw Error(formatProdErrorMessage(529, ""));
        return null;
      case "script":
        return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
          JSCompiler_inline_result
        ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(formatProdErrorMessage(444, type));
    }
  }
  function getStyleKey(href) {
    return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
  }
  function getStylesheetSelectorFromKey(key) {
    return 'link[rel="stylesheet"][' + key + "]";
  }
  function stylesheetPropsFromRawProps(rawProps) {
    return assign({}, rawProps, {
      "data-precedence": rawProps.precedence,
      precedence: null
    });
  }
  function preloadStylesheet(ownerDocument, key, preloadProps, state) {
    ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
      return state.loading |= 1;
    }), key.addEventListener("error", function() {
      return state.loading |= 2;
    }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
  }
  function getScriptKey(src) {
    return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
  }
  function getScriptSelectorFromKey(key) {
    return "script[async]" + key;
  }
  function acquireResource(hoistableRoot, resource, props) {
    resource.count++;
    if (null === resource.instance)
      switch (resource.type) {
        case "style":
          var instance = hoistableRoot.querySelector(
            'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
          );
          if (instance)
            return resource.instance = instance, markNodeAsHoistable(instance), instance;
          var styleProps = assign({}, props, {
            "data-href": props.href,
            "data-precedence": props.precedence,
            href: null,
            precedence: null
          });
          instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
            "style"
          );
          markNodeAsHoistable(instance);
          setInitialProperties(instance, "style", styleProps);
          insertStylesheet(instance, props.precedence, hoistableRoot);
          return resource.instance = instance;
        case "stylesheet":
          styleProps = getStyleKey(props.href);
          var instance$249 = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(styleProps)
          );
          if (instance$249)
            return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
          instance = stylesheetPropsFromRawProps(props);
          (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
          instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
          markNodeAsHoistable(instance$249);
          var linkInstance = instance$249;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance$249, "link", instance);
          resource.state.loading |= 4;
          insertStylesheet(instance$249, props.precedence, hoistableRoot);
          return resource.instance = instance$249;
        case "script":
          instance$249 = getScriptKey(props.src);
          if (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$249)
          ))
            return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
          instance = props;
          if (styleProps = preloadPropsMap.get(instance$249))
            instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          styleProps = hoistableRoot.createElement("script");
          markNodeAsHoistable(styleProps);
          setInitialProperties(styleProps, "link", instance);
          hoistableRoot.head.appendChild(styleProps);
          return resource.instance = styleProps;
        case "void":
          return null;
        default:
          throw Error(formatProdErrorMessage(443, resource.type));
      }
    else
      "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
    return resource.instance;
  }
  function insertStylesheet(instance, precedence, root2) {
    for (var nodes = root2.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i2 = 0; i2 < nodes.length; i2++) {
      var node = nodes[i2];
      if (node.dataset.precedence === precedence) prior = node;
      else if (prior !== last) break;
    }
    prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
  }
  function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
    null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
    null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
    null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
  }
  function adoptPreloadPropsForScript(scriptProps, preloadProps) {
    null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
    null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
    null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
  }
  var tagCaches = null;
  function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
    if (null === tagCaches) {
      var cache = /* @__PURE__ */ new Map();
      var caches = tagCaches = /* @__PURE__ */ new Map();
      caches.set(ownerDocument, cache);
    } else
      caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
    if (cache.has(type)) return cache;
    cache.set(type, null);
    ownerDocument = ownerDocument.getElementsByTagName(type);
    for (caches = 0; caches < ownerDocument.length; caches++) {
      var node = ownerDocument[caches];
      if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
        var nodeKey = node.getAttribute(keyAttribute) || "";
        nodeKey = type + nodeKey;
        var existing = cache.get(nodeKey);
        existing ? existing.push(node) : cache.set(nodeKey, [node]);
      }
    }
    return cache;
  }
  function mountHoistable(hoistableRoot, type, instance) {
    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
    hoistableRoot.head.insertBefore(
      instance,
      "title" === type ? hoistableRoot.querySelector("head > title") : null
    );
  }
  function isHostHoistableType(type, props, hostContext) {
    if (1 === hostContext || null != props.itemProp) return false;
    switch (type) {
      case "meta":
      case "title":
        return true;
      case "style":
        if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
          break;
        return true;
      case "link":
        if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
          break;
        switch (props.rel) {
          case "stylesheet":
            return type = props.disabled, "string" === typeof props.precedence && null == type;
          default:
            return true;
        }
      case "script":
        if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
          return true;
    }
    return false;
  }
  function preloadResource(resource) {
    return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
  }
  function suspendResource(state, hoistableRoot, resource, props) {
    if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
      if (null === resource.instance) {
        var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
        if (instance) {
          hoistableRoot = instance._p;
          null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
          resource.state.loading |= 4;
          resource.instance = instance;
          markNodeAsHoistable(instance);
          return;
        }
        instance = hoistableRoot.ownerDocument || hoistableRoot;
        props = stylesheetPropsFromRawProps(props);
        (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
        instance = instance.createElement("link");
        markNodeAsHoistable(instance);
        var linkInstance = instance;
        linkInstance._p = new Promise(function(resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance, "link", props);
        resource.instance = instance;
      }
      null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
      state.stylesheets.set(resource, hoistableRoot);
      (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
    }
  }
  var estimatedBytesWithinLimit = 0;
  function waitForCommitToBeReady(state, timeoutOffset) {
    state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
    return 0 < state.count || 0 < state.imgCount ? function(commit) {
      var stylesheetTimer = setTimeout(function() {
        state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
        if (state.unsuspend) {
          var unsuspend = state.unsuspend;
          state.unsuspend = null;
          unsuspend();
        }
      }, 6e4 + timeoutOffset);
      0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
      var imgTimer = setTimeout(
        function() {
          state.waitingForImages = false;
          if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        },
        (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
      );
      state.unsuspend = commit;
      return function() {
        state.unsuspend = null;
        clearTimeout(stylesheetTimer);
        clearTimeout(imgTimer);
      };
    } : null;
  }
  function onUnsuspend() {
    this.count--;
    if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
      if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
      else if (this.unsuspend) {
        var unsuspend = this.unsuspend;
        this.unsuspend = null;
        unsuspend();
      }
    }
  }
  var precedencesByRoot = null;
  function insertSuspendedStylesheets(state, resources) {
    state.stylesheets = null;
    null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
  }
  function insertStylesheetIntoRoot(root2, resource) {
    if (!(resource.state.loading & 4)) {
      var precedences = precedencesByRoot.get(root2);
      if (precedences) var last = precedences.get(null);
      else {
        precedences = /* @__PURE__ */ new Map();
        precedencesByRoot.set(root2, precedences);
        for (var nodes = root2.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), i2 = 0; i2 < nodes.length; i2++) {
          var node = nodes[i2];
          if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
            precedences.set(node.dataset.precedence, node), last = node;
        }
        last && precedences.set(null, last);
      }
      nodes = resource.instance;
      node = nodes.getAttribute("data-precedence");
      i2 = precedences.get(node) || last;
      i2 === last && precedences.set(null, nodes);
      precedences.set(node, nodes);
      this.count++;
      last = onUnsuspend.bind(this);
      nodes.addEventListener("load", last);
      nodes.addEventListener("error", last);
      i2 ? i2.parentNode.insertBefore(nodes, i2.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
      resource.state.loading |= 4;
    }
  }
  var HostTransitionContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Provider: null,
    Consumer: null,
    _currentValue: sharedNotPendingObject,
    _currentValue2: sharedNotPendingObject,
    _threadCount: 0
  };
  function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
    this.tag = 1;
    this.containerInfo = containerInfo;
    this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
    this.callbackPriority = 0;
    this.expirationTimes = createLaneMap(-1);
    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = createLaneMap(0);
    this.hiddenUpdates = createLaneMap(null);
    this.identifierPrefix = identifierPrefix;
    this.onUncaughtError = onUncaughtError;
    this.onCaughtError = onCaughtError;
    this.onRecoverableError = onRecoverableError;
    this.pooledCache = null;
    this.pooledCacheLanes = 0;
    this.formState = formState;
    this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
    containerInfo = new FiberRootNode(
      containerInfo,
      tag,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      onDefaultTransitionIndicator,
      formState
    );
    tag = 1;
    true === isStrictMode && (tag |= 24);
    isStrictMode = createFiberImplClass(3, null, null, tag);
    containerInfo.current = isStrictMode;
    isStrictMode.stateNode = containerInfo;
    tag = createCache();
    tag.refCount++;
    containerInfo.pooledCache = tag;
    tag.refCount++;
    isStrictMode.memoizedState = {
      element: initialChildren,
      isDehydrated: hydrate,
      cache: tag
    };
    initializeUpdateQueue(isStrictMode);
    return containerInfo;
  }
  function getContextForSubtree(parentComponent) {
    if (!parentComponent) return emptyContextObject;
    parentComponent = emptyContextObject;
    return parentComponent;
  }
  function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
    parentComponent = getContextForSubtree(parentComponent);
    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = createUpdate(lane);
    container.payload = { element };
    callback = void 0 === callback ? null : callback;
    null !== callback && (container.callback = callback);
    element = enqueueUpdate(rootFiber, container, lane);
    null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
  }
  function markRetryLaneImpl(fiber, retryLane) {
    fiber = fiber.memoizedState;
    if (null !== fiber && null !== fiber.dehydrated) {
      var a2 = fiber.retryLane;
      fiber.retryLane = 0 !== a2 && a2 < retryLane ? a2 : retryLane;
    }
  }
  function markRetryLaneIfNotHydrated(fiber, retryLane) {
    markRetryLaneImpl(fiber, retryLane);
    (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
  }
  function attemptContinuousHydration(fiber) {
    if (13 === fiber.tag || 31 === fiber.tag) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
      markRetryLaneIfNotHydrated(fiber, 67108864);
    }
  }
  function attemptHydrationAtCurrentPriority(fiber) {
    if (13 === fiber.tag || 31 === fiber.tag) {
      var lane = requestUpdateLane();
      lane = getBumpedLaneForHydrationByLane(lane);
      var root2 = enqueueConcurrentRenderForLane(fiber, lane);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
      markRetryLaneIfNotHydrated(fiber, lane);
    }
  }
  var _enabled = true;
  function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (_enabled) {
      var blockedOn = findInstanceBlockingEvent(nativeEvent);
      if (null === blockedOn)
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer
        ), clearIfContinuousEvent(domEventName, nativeEvent);
      else if (queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ))
        nativeEvent.stopPropagation();
      else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
        for (; null !== blockedOn; ) {
          var fiber = getInstanceFromNode(blockedOn);
          if (null !== fiber)
            switch (fiber.tag) {
              case 3:
                fiber = fiber.stateNode;
                if (fiber.current.memoizedState.isDehydrated) {
                  var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                  if (0 !== lanes) {
                    var root2 = fiber;
                    root2.pendingLanes |= 2;
                    for (root2.entangledLanes |= 2; lanes; ) {
                      var lane = 1 << 31 - clz32(lanes);
                      root2.entanglements[1] |= lane;
                      lanes &= ~lane;
                    }
                    ensureRootIsScheduled(fiber);
                    0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                  }
                }
                break;
              case 31:
              case 13:
                root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
            }
          fiber = findInstanceBlockingEvent(nativeEvent);
          null === fiber && dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
          if (fiber === blockedOn) break;
          blockedOn = fiber;
        }
        null !== blockedOn && nativeEvent.stopPropagation();
      } else
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          null,
          targetContainer
        );
    }
  }
  function findInstanceBlockingEvent(nativeEvent) {
    nativeEvent = getEventTarget(nativeEvent);
    return findInstanceBlockingTarget(nativeEvent);
  }
  var return_targetInst = null;
  function findInstanceBlockingTarget(targetNode) {
    return_targetInst = null;
    targetNode = getClosestInstanceFromNode(targetNode);
    if (null !== targetNode) {
      var nearestMounted = getNearestMountedFiber(targetNode);
      if (null === nearestMounted) targetNode = null;
      else {
        var tag = nearestMounted.tag;
        if (13 === tag) {
          targetNode = getSuspenseInstanceFromFiber(nearestMounted);
          if (null !== targetNode) return targetNode;
          targetNode = null;
        } else if (31 === tag) {
          targetNode = getActivityInstanceFromFiber(nearestMounted);
          if (null !== targetNode) return targetNode;
          targetNode = null;
        } else if (3 === tag) {
          if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
            return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          targetNode = null;
        } else nearestMounted !== targetNode && (targetNode = null);
      }
    }
    return_targetInst = targetNode;
    return null;
  }
  function getEventPriority(domEventName) {
    switch (domEventName) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (getCurrentPriorityLevel()) {
          case ImmediatePriority:
            return 2;
          case UserBlockingPriority:
            return 8;
          case NormalPriority$1:
          case LowPriority:
            return 32;
          case IdlePriority:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function clearIfContinuousEvent(domEventName, nativeEvent) {
    switch (domEventName) {
      case "focusin":
      case "focusout":
        queuedFocus = null;
        break;
      case "dragenter":
      case "dragleave":
        queuedDrag = null;
        break;
      case "mouseover":
      case "mouseout":
        queuedMouse = null;
        break;
      case "pointerover":
      case "pointerout":
        queuedPointers.delete(nativeEvent.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        queuedPointerCaptures.delete(nativeEvent.pointerId);
    }
  }
  function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
      return existingQueuedEvent = {
        blockedOn,
        domEventName,
        eventSystemFlags,
        nativeEvent,
        targetContainers: [targetContainer]
      }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
    existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
    blockedOn = existingQueuedEvent.targetContainers;
    null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
    return existingQueuedEvent;
  }
  function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    switch (domEventName) {
      case "focusin":
        return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "dragenter":
        return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "mouseover":
        return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "pointerover":
        var pointerId = nativeEvent.pointerId;
        queuedPointers.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointers.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        );
        return true;
      case "gotpointercapture":
        return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ), true;
    }
    return false;
  }
  function attemptExplicitHydrationTarget(queuedTarget) {
    var targetInst = getClosestInstanceFromNode(queuedTarget.target);
    if (null !== targetInst) {
      var nearestMounted = getNearestMountedFiber(targetInst);
      if (null !== nearestMounted) {
        if (targetInst = nearestMounted.tag, 13 === targetInst) {
          if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
            queuedTarget.blockedOn = targetInst;
            runWithPriority(queuedTarget.priority, function() {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
            return;
          }
        } else if (31 === targetInst) {
          if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
            queuedTarget.blockedOn = targetInst;
            runWithPriority(queuedTarget.priority, function() {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
            return;
          }
        } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
          queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          return;
        }
      }
    }
    queuedTarget.blockedOn = null;
  }
  function attemptReplayContinuousQueuedEvent(queuedEvent) {
    if (null !== queuedEvent.blockedOn) return false;
    for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
      var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
      if (null === nextBlockedOn) {
        nextBlockedOn = queuedEvent.nativeEvent;
        var nativeEventClone = new nextBlockedOn.constructor(
          nextBlockedOn.type,
          nextBlockedOn
        );
        currentReplayingEvent = nativeEventClone;
        nextBlockedOn.target.dispatchEvent(nativeEventClone);
        currentReplayingEvent = null;
      } else
        return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
      targetContainers.shift();
    }
    return true;
  }
  function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
    attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
  }
  function replayUnblockedEvents() {
    hasScheduledReplayAttempt = false;
    null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
    null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
    null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
  }
  function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
    queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      replayUnblockedEvents
    )));
  }
  var lastScheduledReplayQueue = null;
  function scheduleReplayQueueIfNeeded(formReplayingQueue) {
    lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function() {
        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
        for (var i2 = 0; i2 < formReplayingQueue.length; i2 += 3) {
          var form = formReplayingQueue[i2], submitterOrAction = formReplayingQueue[i2 + 1], formData = formReplayingQueue[i2 + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst && (formReplayingQueue.splice(i2, 3), i2 -= 3, startHostTransition(
            formInst,
            {
              pending: true,
              data: formData,
              method: form.method,
              action: submitterOrAction
            },
            submitterOrAction,
            formData
          ));
        }
      }
    ));
  }
  function retryIfBlockedOn(unblocked) {
    function unblock(queuedEvent) {
      return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
    }
    null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
    null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
    null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
    queuedPointers.forEach(unblock);
    queuedPointerCaptures.forEach(unblock);
    for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length; i2++) {
      var queuedTarget = queuedExplicitHydrationTargets[i2];
      queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
    }
    for (; 0 < queuedExplicitHydrationTargets.length && (i2 = queuedExplicitHydrationTargets[0], null === i2.blockedOn); )
      attemptExplicitHydrationTarget(i2), null === i2.blockedOn && queuedExplicitHydrationTargets.shift();
    i2 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
    if (null != i2)
      for (queuedTarget = 0; queuedTarget < i2.length; queuedTarget += 3) {
        var form = i2[queuedTarget], submitterOrAction = i2[queuedTarget + 1], formProps = form[internalPropsKey] || null;
        if ("function" === typeof submitterOrAction)
          formProps || scheduleReplayQueueIfNeeded(i2);
        else if (formProps) {
          var action = null;
          if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
            if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
              action = formProps.formAction;
            else {
              if (null !== findInstanceBlockingTarget(form)) continue;
            }
          else action = formProps.action;
          "function" === typeof action ? i2[queuedTarget + 1] = action : (i2.splice(queuedTarget, 3), queuedTarget -= 3);
          scheduleReplayQueueIfNeeded(i2);
        }
      }
  }
  function defaultOnDefaultTransitionIndicator() {
    function handleNavigate(event) {
      event.canIntercept && "react-transition" === event.info && event.intercept({
        handler: function() {
          return new Promise(function(resolve) {
            return pendingResolve = resolve;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function handleNavigateComplete() {
      null !== pendingResolve && (pendingResolve(), pendingResolve = null);
      isCancelled || setTimeout(startFakeNavigation, 20);
    }
    function startFakeNavigation() {
      if (!isCancelled && !navigation.transition) {
        var currentEntry = navigation.currentEntry;
        currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
          state: currentEntry.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if ("object" === typeof navigation) {
      var isCancelled = false, pendingResolve = null;
      navigation.addEventListener("navigate", handleNavigate);
      navigation.addEventListener("navigatesuccess", handleNavigateComplete);
      navigation.addEventListener("navigateerror", handleNavigateComplete);
      setTimeout(startFakeNavigation, 100);
      return function() {
        isCancelled = true;
        navigation.removeEventListener("navigate", handleNavigate);
        navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
        navigation.removeEventListener("navigateerror", handleNavigateComplete);
        null !== pendingResolve && (pendingResolve(), pendingResolve = null);
      };
    }
  }
  function ReactDOMRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
    var root2 = this._internalRoot;
    if (null === root2) throw Error(formatProdErrorMessage(409));
    var current = root2.current, lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root2, null, null);
  };
  ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
    var root2 = this._internalRoot;
    if (null !== root2) {
      this._internalRoot = null;
      var container = root2.containerInfo;
      updateContainerImpl(root2.current, 2, null, root2, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
  function ReactDOMHydrationRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
    if (target) {
      var updatePriority = resolveUpdatePriority();
      target = { blockedOn: null, target, priority: updatePriority };
      for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i2].priority; i2++) ;
      queuedExplicitHydrationTargets.splice(i2, 0, target);
      0 === i2 && attemptExplicitHydrationTarget(target);
    }
  };
  var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
  if ("19.2.3" !== isomorphicReactPackageVersion$jscomp$inline_1840)
    throw Error(
      formatProdErrorMessage(
        527,
        isomorphicReactPackageVersion$jscomp$inline_1840,
        "19.2.3"
      )
    );
  ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
    var fiber = componentOrElement._reactInternals;
    if (void 0 === fiber) {
      if ("function" === typeof componentOrElement.render)
        throw Error(formatProdErrorMessage(188));
      componentOrElement = Object.keys(componentOrElement).join(",");
      throw Error(formatProdErrorMessage(268, componentOrElement));
    }
    componentOrElement = findCurrentFiberUsingSlowPath(fiber);
    componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
    componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
    return componentOrElement;
  };
  var internals$jscomp$inline_2347 = {
    bundleType: 0,
    version: "19.2.3",
    rendererPackageName: "react-dom",
    currentDispatcherRef: ReactSharedInternals,
    reconcilerVersion: "19.2.3"
  };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
      try {
        rendererID = hook$jscomp$inline_2348.inject(
          internals$jscomp$inline_2347
        ), injectedHook = hook$jscomp$inline_2348;
      } catch (err) {
      }
  }
  reactDomClient_production.createRoot = function(container, options2) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
    null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
    options2 = createFiberRoot(
      container,
      1,
      false,
      null,
      null,
      isStrictMode,
      identifierPrefix,
      null,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      defaultOnDefaultTransitionIndicator
    );
    container[internalContainerInstanceKey] = options2.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMRoot(options2);
  };
  reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
    null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
    initialChildren = createFiberRoot(
      container,
      1,
      true,
      initialChildren,
      null != options2 ? options2 : null,
      isStrictMode,
      identifierPrefix,
      formState,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      defaultOnDefaultTransitionIndicator
    );
    initialChildren.context = getContextForSubtree(null);
    options2 = initialChildren.current;
    isStrictMode = requestUpdateLane();
    isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
    identifierPrefix = createUpdate(isStrictMode);
    identifierPrefix.callback = null;
    enqueueUpdate(options2, identifierPrefix, isStrictMode);
    options2 = isStrictMode;
    initialChildren.current.lanes = options2;
    markRootUpdated$1(initialChildren, options2);
    ensureRootIsScheduled(initialChildren);
    container[internalContainerInstanceKey] = initialChildren.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMHydrationRoot(initialChildren);
  };
  reactDomClient_production.version = "19.2.3";
  return reactDomClient_production;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client.exports;
  hasRequiredClient = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    client.exports = requireReactDomClient_production();
  }
  return client.exports;
}
var clientExports = requireClient();
var PopStateEventType = "popstate";
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search, hash } = window2.location;
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(
    createBrowserLocation,
    createBrowserHref,
    null,
    options
  );
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...typeof to === "string" ? parsePath(to) : to,
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  };
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let { window: window2 = document.defaultView, v5Compat = false } = options;
  let globalHistory = window2.history;
  let action = "POP";
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
  }
  function getIndex() {
    let state = globalHistory.state || { idx: null };
    return state.idx;
  }
  function handlePop() {
    action = "POP";
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({ action, location: history.location, delta });
    }
  }
  function push(to, state) {
    action = "PUSH";
    let location = createLocation(history.location, to, state);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 1 });
    }
  }
  function replace2(to, state) {
    action = "REPLACE";
    let location = createLocation(history.location, to, state);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 0 });
    }
  }
  function createURL(to) {
    return createBrowserURLImpl(to);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
function createBrowserURLImpl(to, isAbsolute = false) {
  let base = "http://localhost";
  if (typeof window !== "undefined") {
    base = window.location.origin !== "null" ? window.location.origin : window.location.href;
  }
  invariant(base, "No window.location.(origin|href) available to create URL");
  let href = typeof to === "string" ? to : createPath(to);
  href = href.replace(/ $/, "%20");
  if (!isAbsolute && href.startsWith("//")) {
    href = base + href;
  }
  return new URL(href, base);
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i2],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
  let flattenRoute = (route, index, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
        return;
      }
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(
        route.children,
        branches,
        routesMeta,
        path,
        hasParentOptionalSegments
      );
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, true, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(
      a2.routesMeta.map((meta) => meta.childrenIndex),
      b2.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s2) => s2 === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname
    );
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase])
      ),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_2, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname;
  if (toPathname) {
    if (isAbsoluteUrl(toPathname)) {
      pathname = toPathname;
    } else {
      if (toPathname.includes("//")) {
        let oldPathname = toPathname;
        toPathname = toPathname.replace(/\/\/+/g, "/");
        warning(
          false,
          `Pathnames cannot have embedded double slashes - normalizing ${oldPathname} -> ${toPathname}`
        );
      }
      if (toPathname.startsWith("/")) {
        pathname = resolvePathname(toPathname.substring(1), "/");
      } else {
        pathname = resolvePathname(toPathname, fromPathname);
      }
    }
  } else {
    pathname = fromPathname;
  }
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match, index) => index === 0 || match.route.path && match.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = { ...toArg };
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
function getRoutePattern(matches) {
  return matches.map((m2) => m2.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
new Set(validRequestMethodsArr);
var DataRouterContext = reactExports.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = reactExports.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
reactExports.createContext(false);
var ViewTransitionContext = reactExports.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = reactExports.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = reactExports.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = reactExports.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext$1 = reactExports.createContext(
  null
);
LocationContext$1.displayName = "Location";
var RouteContext = reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = reactExports.createContext(null);
RouteErrorContext.displayName = "RouteError";
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
  let { hash, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({ pathname: joinedPathname, search, hash });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext$1) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return reactExports.useContext(LocationContext$1).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator2,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
reactExports.createContext(null);
function useResolvedPath(to, { relative } = {}) {
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return reactExports.useMemo(
    () => resolveTo(
      to,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, unstable_onError, future) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator: navigator2 } = reactExports.useContext(NavigationContext);
  let { matches: parentMatches } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, { pathname: remainingPathname });
  {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    unstable_onError,
    future
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(
      LocationContext$1.Provider,
      {
        value: {
          location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...location
          },
          navigationType: "POP"
          /* Pop */
        }
      },
      renderedMatches
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error
    );
    devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    } else {
      console.error(
        "React Router caught the following error during render",
        error
      );
    }
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
      RouteErrorContext.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function RenderedRoute({ routeContext, match, children }) {
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, unstable_onError = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m2) => m2.route.id && errors?.[m2.route.id] !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match = renderedMatches[i2];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  let onError = dataRouterState && unstable_onError ? (error, errorInfo) => {
    unstable_onError(error, {
      location: dataRouterState.location,
      params: dataRouterState.matches?.[0]?.params ?? {},
      unstable_pattern: getRoutePattern(dataRouterState.matches),
      errorInfo
    });
  } : void 0;
  return renderedMatches.reduceRight(
    (outlet, match, index) => {
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors && match.route.id ? errors[match.route.id] : void 0;
        errorElement = match.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match.route.Component) {
          children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
        } else if (match.route.element) {
          children = match.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ reactExports.createElement(
          RenderedRoute,
          {
            match,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          }
        );
      };
      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true },
          onError
        }
      ) : getChildren();
    },
    null
  );
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(
    "useRouteId"
    /* UseRouteId */
  );
}
function useRouteError() {
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(
    "useRouteError"
    /* UseRouteError */
  );
  let routeId = useCurrentRouteId(
    "useRouteError"
    /* UseRouteError */
  );
  if (error !== void 0) {
    return error;
  }
  return state.errors?.[routeId];
}
function useNavigateStable() {
  let { router } = useDataRouterContext(
    "useNavigate"
    /* UseNavigateStable */
  );
  let id = useCurrentRouteId(
    "useNavigate"
    /* UseNavigateStable */
  );
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    async (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        await router.navigate(to);
      } else {
        await router.navigate(to, { fromRouteId: id, ...options });
      }
    },
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
reactExports.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state,
  unstable_onError
}) {
  return useRoutesImpl(routes, void 0, state, unstable_onError, future);
}
function Route(props) {
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
  );
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP",
  navigator: navigator2,
  static: staticProp = false,
  unstable_useTransitions
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(
    () => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      unstable_useTransitions,
      future: {}
    }),
    [basename, navigator2, staticProp, unstable_useTransitions]
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext$1.Provider, { children, value: locationContext }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children, treePath)
      );
      return;
    }
    invariant(
      element.type === Route,
      `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    );
    invariant(
      !element.props.index || !element.props.children,
      "An index route cannot have child routes."
    );
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      middleware: element.props.middleware,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(
        element.props.children,
        treePath
      );
    }
    routes.push(route);
  });
  return routes;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return typeof HTMLElement !== "undefined" && object instanceof HTMLElement;
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e2) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name, type, value } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function singleFetchUrl(reqUrl, basename, extension) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = `_root.${extension}`;
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
  }
  return url;
}
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      route.module
    );
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(
      `Error loading route module \`${route.module}\`, reloading page...`
    );
    console.error(error);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
    void 0) ;
    window.location.reload();
    return new Promise(() => {
    });
  }
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(
    matches.map(async (match) => {
      let route = manifest.routes[match.route.id];
      if (route) {
        let mod = await loadRouteModule(route, routeModules);
        return mod.links ? mod.links() : [];
      }
      return [];
    })
  );
  return dedupeLinkDescriptors(
    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
      (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
    )
  );
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match, index) => isNew(match, index) || matchPathChanged(match, index)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map((match) => {
      let route = manifest.routes[match.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.clientActionModule) {
        hrefs = hrefs.concat(route.clientActionModule);
      }
      if (route.clientLoaderModule) {
        hrefs = hrefs.concat(route.clientLoaderModule);
      }
      if (includeHydrateFallback && route.hydrateFallbackModule) {
        hrefs = hrefs.concat(route.hydrateFallbackModule);
      }
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
function useDataRouterContext2() {
  let context = reactExports.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = reactExports.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = reactExports.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = reactExports.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = reactExports.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  reactExports.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function PrefetchPageLinks({ page, ...linkProps }) {
  let { router } = useDataRouterContext2();
  let matches = reactExports.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, { page, matches, ...linkProps });
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
  reactExports.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { basename } = useDataRouterContext2();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = reactExports.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m2) => {
      let manifestRoute = manifest.routes[m2.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m22) => m22.route.id === m2.route.id) && m2.route.id in loaderData && routeModules[m2.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m2.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename, "data");
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m2) => routesParams.has(m2.route.id)).map((m2) => m2.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    basename,
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = reactExports.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", { key: href, rel: "prefetch", as: "fetch", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", { key: href, rel: "modulepreload", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ reactExports.createElement("link", { key, nonce: linkProps.nonce, ...link })
  )));
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser) {
    window.__reactRouterVersion = // @ts-expect-error
    "7.10.1";
  }
} catch (e2) {
}
function BrowserRouter({
  basename,
  children,
  unstable_useTransitions,
  window: window2
}) {
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let setState = reactExports.useCallback(
    (newState) => {
      if (unstable_useTransitions === false) {
        setStateImpl(newState);
      } else {
        reactExports.startTransition(() => setStateImpl(newState));
      }
    },
    [unstable_useTransitions]
  );
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      unstable_useTransitions: unstable_useTransitions === true
    }
  );
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = reactExports.forwardRef(
  function LinkWithRef({
    onClick,
    discover = "render",
    prefetch = "none",
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition,
    ...rest
  }, forwardedRef) {
    let { basename, unstable_useTransitions } = reactExports.useContext(NavigationContext);
    let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && isAbsolute) {
      absoluteHref = to;
      if (isBrowser) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e2) {
          warning(
            false,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
          );
        }
      }
    }
    let href = useHref(to, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition,
      unstable_useTransitions
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ reactExports.createElement(
        "a",
        {
          ...rest,
          ...prefetchHandlers,
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href })) : link;
  }
);
Link.displayName = "Link";
var NavLink = reactExports.forwardRef(
  function NavLinkWithRef({
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children,
    ...rest
  }, ref) {
    let path = useResolvedPath(to, { relative: rest.relative });
    let location = useLocation();
    let routerState = reactExports.useContext(DataRouterStateContext);
    let { navigator: navigator2, basename } = reactExports.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ reactExports.createElement(
      Link,
      {
        ...rest,
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to,
        viewTransition
      },
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form = reactExports.forwardRef(
  ({
    discover = "render",
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace2,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    viewTransition,
    ...props
  }, forwardedRef) => {
    let { unstable_useTransitions } = reactExports.useContext(NavigationContext);
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = submitter?.getAttribute("formmethod") || method;
      let doSubmit = () => submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
      if (unstable_useTransitions && navigate !== false) {
        reactExports.startTransition(() => doSubmit());
      } else {
        doSubmit();
      }
    };
    return /* @__PURE__ */ reactExports.createElement(
      "form",
      {
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler,
        ...props,
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      }
    );
  }
);
Form.displayName = "Form";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition,
  unstable_useTransitions
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return reactExports.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        let doNavigate = () => navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
        if (unstable_useTransitions) {
          reactExports.startTransition(() => doNavigate());
        } else {
          doNavigate();
        }
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition,
      unstable_useTransitions
    ]
  );
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3(
    "useSubmit"
    /* UseSubmit */
  );
  let { basename } = reactExports.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  let routerFetch = router.fetch;
  let routerNavigate = router.navigate;
  return reactExports.useCallback(
    async (target, options = {}) => {
      let { action, method, encType, formData, body } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        await routerFetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        await routerNavigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    },
    [routerFetch, routerNavigate, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = reactExports.useContext(NavigationContext);
  let routeContext = reactExports.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = { ...useResolvedPath(action ? action : ".", { relative }) };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v2) => v2 === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v2) => v2).forEach((v2) => params.append("index", v2));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useViewTransitionState(to, { relative } = {}) {
  let vtContext = reactExports.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState"
    /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
const Layout = ({ children, darkMode, setDarkMode }) => {
  const [mobileMenuOpen, setMobileMenuOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `app ${darkMode ? "dark" : "light"}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: "header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", className: "logo", children: "Rafael Gomez" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `nav-links ${mobileMenuOpen ? "mobile-open" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "close-menu",
            onClick: () => setMobileMenuOpen(false),
            children: ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", onClick: () => setMobileMenuOpen(false), children: "Home" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/experience", onClick: () => setMobileMenuOpen(false), children: "Experience" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/projects", onClick: () => setMobileMenuOpen(false), children: "Projects" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/skills", onClick: () => setMobileMenuOpen(false), children: "Skills" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/compiler", onClick: () => setMobileMenuOpen(false), children: "Compiler" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/experimental", onClick: () => setMobileMenuOpen(false), children: "Experimental" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/contact", onClick: () => setMobileMenuOpen(false), children: "Contact" })
      ] }),
      mobileMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "menu-backdrop",
          onClick: () => setMobileMenuOpen(false)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nav-controls", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "mobile-toggle",
            onClick: () => setMobileMenuOpen(!mobileMenuOpen),
            children: ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "theme-toggle",
            onClick: () => setDarkMode(!darkMode),
            children: darkMode ? "" : ""
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "main", children })
  ] });
};
const Home = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "hero", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Rafael Gomez" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Software Engineer at AWS  MIT Graduate" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Building scalable cloud infrastructure with AWS CDK, DynamoDB, and Lambda" })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "about", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "About Me" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Software Engineer at Amazon Web Services with a strong foundation from MIT (4.8/5.0 GPA). Specialized in cloud architecture using AWS CDK, building SNS notification systems, DynamoDB caching solutions, and automated data processing pipelines with Lambda. Passionate about distributed systems and scalable infrastructure." })
  ] })
] });
const Experience = () => {
  const experiences = [
    {
      title: "Software Engineer",
      company: "Amazon Web Services (AWS)",
      duration: "September 2025 - Present",
      description: "Building tools using widgets, automated deployments, and infrastructure as code for the AWS Tag Policies team. Developing scalable solutions for resource tagging and policy management across AWS services."
    },
    {
      title: "Amazon SDE Intern",
      company: "Amazon",
      duration: "Summer 2024",
      description: "Used CDK to build an SNS notification consumer architecture that updates entries in a DynamoDB table, creating a self-updating L2 cache. Built a new API with throttling rates and authentication to update this cache."
    },
    {
      title: "Amazon Propel Intern",
      company: "Amazon",
      duration: "Summer 2023",
      description: "Created a new Java library for the Prime Video team that parsed different routing data files, validated them, and uploaded data to different DynamoDB tables. Automated the process using AWS Lambda and performed extensive testing with Mockito and JUnit libraries."
    }
  ];
  const education = [
    {
      degree: "Bachelor of Science in Computer Science and Engineering",
      school: "Massachusetts Institute of Technology (MIT)",
      details: "GPA: 4.8/5.0",
      duration: "Class of 2025"
    }
  ];
  const coursework = [
    "Operating Systems",
    "Software Performance Engineering",
    "Computer Language Engineering",
    "Advances in Computer Vision",
    "Software Construction",
    "Advanced Algorithms",
    "Computer Graphics",
    "Computation Structures",
    "Linear Algebra"
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "experience", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Experience" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "experience-list", children: experiences.map((exp, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "experience-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: exp.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: exp.company }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "duration", children: exp.duration }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "description", children: exp.description })
    ] }, index)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Education" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "education-list", children: education.map((edu, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "experience-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: edu.degree }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: edu.school }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "duration", children: edu.duration }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "description", children: edu.details })
    ] }, index)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Relevant Coursework" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "coursework-grid", children: coursework.map((course, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "coursework-item", children: course }, index)) })
  ] });
};
const Projects = () => {
  const projects = [
    {
      name: "C-like Language Compiler",
      tech: "Java, Antlr, Compiler Design",
      description: "Led development of a 10,000+ line codebase implementing a complete compiler. Verified user input semantics and grammar via Antlr parse generator. Implemented dataflow algorithms to improve runtime performance.",
      duration: "Spring 2025",
      link: "#"
    },
    {
      name: "Single Model X-ray Classifier",
      tech: "Python, Neural Networks, Computer Vision",
      description: "Built and trained a multi-headed residual neural network classifier to identify issues in patient X-ray scans using advanced computer vision techniques.",
      duration: "Spring 2024",
      link: "#"
    },
    {
      name: "Bouncy Animation System",
      tech: "C++, OpenGL, Physics Simulation",
      description: "Created a command-line real-time bouncy ball animation using C++ MIT OpenGL interface. Developed a general spring-gravity force system and integrator interfaces to model particle systems.",
      duration: "Fall 2023",
      link: "#"
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "projects", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Projects" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "project-grid", children: projects.map((project, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "project-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: project.name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "project-duration", children: project.duration }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "tech-stack", children: project.tech }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "project-description", children: project.description }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: project.link, children: "View Project" })
    ] }, index)) })
  ] });
};
const Skills = () => {
  const languages = [
    "Java",
    "C++",
    "TypeScript",
    "Python",
    "HTML",
    "CSS"
  ];
  const skills = [
    "React",
    "CDK",
    "Agile",
    "Git",
    "Mockito",
    "JUnit",
    "AWS Lambda",
    "DynamoDB",
    "S3",
    "MongoDB"
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "skills", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Technical Skills" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "skills-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Programming Languages" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skills-grid", children: languages.map((lang, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "skill-item", children: lang }, index)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "skills-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Technologies & Tools" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skills-grid", children: skills.map((skill, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "skill-item", children: skill }, index)) })
    ] })
  ] });
};
const KEYWORDS = /* @__PURE__ */ new Set([
  "import",
  "void",
  "int",
  "long",
  "bool",
  "if",
  "else",
  "for",
  "while",
  "return",
  "break",
  "continue",
  "len",
  "true",
  "false"
]);
const TOKEN_PATTERNS = [
  {
    type: "STRINGLITERAL",
    regex: /^"(?:[ -!#-\[\]-~]|\\["'\\tnrf])*"/
  },
  { type: "CHARLITERAL", regex: /^'(?:[ -!#-\[\]-~]|\\["'\\tnrf])'/ },
  { type: "BOOLEANLITERAL", regex: /^\b(true|false)\b/ },
  { type: "IDENTIFIER", regex: /^\b[a-zA-Z_][a-zA-Z0-9_]*\b/ },
  { type: "LONGLITERAL", regex: /^(0x[0-9a-fA-F]+L|\d+L)/ },
  { type: "INTLITERAL", regex: /^(0x[0-9a-fA-F]+|\d+)/ },
  // multi char operators first
  {
    type: "MULTIOP",
    regex: /^(==|!=|<=|>=|\|\||&&|\+=|-=|\*=|\/=|%=|\+\+|--)/
  },
  // single char operators
  { type: "SINGLEOP", regex: /^[;,+\*%/<>=\-!]/ }
];
function tokenize(source, filePath) {
  const lines = source.split("\n");
  let lineNumber = 0;
  let output = [];
  let hasError = false;
  let fullStack = [];
  let blockComment = false;
  for (let line of lines) {
    lineNumber++;
    if (blockComment) {
      if (line.includes("*/")) {
        line = line.substring(line.indexOf("*/") + 2);
        blockComment = false;
      } else {
        continue;
      }
    }
    while (line.includes("/*")) {
      if (line.includes("*/")) {
        line = line.replace(/\/\*[\s\S]*?\*\//g, "");
      } else {
        blockComment = true;
        line = line.substring(0, line.indexOf("/*"));
        break;
      }
    }
    line = line.replace(/\/\/.*/, "");
    if (line.trim() === "") {
      continue;
    }
    const tokenizedLineOutput = tokenizeLine(
      line,
      lineNumber,
      fullStack,
      hasError
    );
    output = output.concat(tokenizedLineOutput.lineOutput);
    hasError = hasError || tokenizedLineOutput.hasError;
    fullStack = tokenizedLineOutput.stack;
  }
  if (fullStack.length !== 0) {
    hasError = true;
  }
  let usedOutput = output.join("\n") + "\n";
  if (usedOutput == "\n") {
    usedOutput = "";
  }
  return hasError ? { output: usedOutput, hasError: true } : { output: usedOutput, hasError: false };
}
function tokenizeLine(line, lineNumber, stack, hasError) {
  let output = [];
  let column = 1;
  while (line.length > 0) {
    line = line.trimStart();
    let match = null;
    let tokenType = null;
    if (line.startsWith("{") || line.startsWith("(") || line.startsWith("[")) {
      stack.push(line[0]);
      output.push(`${lineNumber} ${line[0]}`);
      line = line.slice(1);
      continue;
    }
    if (line.startsWith("}") || line.startsWith(")") || line.startsWith("]")) {
      if (stack.length > 0) {
        let expected = stack.pop();
        if (expected === "{" && line[0] === "}" || expected === "(" && line[0] === ")" || expected === "[" && line[0] === "]") {
          output.push(`${lineNumber} ${line[0]}`);
          line = line.slice(1);
          continue;
        }
      } else {
        hasError = true;
        output.push(`line ${lineNumber}:${column}: unexpected closing`);
        line = line.slice(1);
        continue;
      }
      continue;
    }
    for (const { type, regex } of TOKEN_PATTERNS) {
      match = regex.exec(line);
      if (match) {
        tokenType = type;
        break;
      }
    }
    if (!match) {
      output.push(
        `line ${lineNumber}:${column}: unexpected char: ${line[0].charCodeAt(0).toString(16)}`
      );
      hasError = true;
      line = line.slice(1);
      column++;
      continue;
    }
    const tokenText = match[0];
    if (tokenType === "IDENTIFIER") {
      if (KEYWORDS.has(tokenText)) {
        output.push(`${lineNumber} ${tokenText}`);
      } else {
        output.push(`${lineNumber} ${"IDENTIFIER"} ${tokenText}`);
      }
    } else if (tokenType === "CHARLITERAL") {
      const tokenText2 = match[0];
      const charContent = tokenText2.slice(1, -1);
      if (charContent === "'" || charContent === '"') {
        hasError = true;
        output.push(
          `line ${lineNumber}:${column}: unexpected char: '${charContent}'`
        );
      } else {
        output.push(`${lineNumber} CHARLITERAL ${tokenText2}`);
      }
    } else if (tokenType === "STRINGLITERAL") {
      const tokenText2 = match[0];
      const stringContent = tokenText2.slice(1, -1);
      if (stringContent.includes("'") || stringContent.includes('"')) {
        let hasUnescapedQuote = false;
        for (let i2 = 0; i2 < stringContent.length; i2++) {
          if ((stringContent[i2] === "'" || stringContent[i2] === '"') && (i2 === 0 || stringContent[i2 - 1] !== "\\")) {
            hasUnescapedQuote = true;
            output.push(
              `line ${lineNumber}:${column + i2 + 1}: unescaped symbol: '${stringContent[i2]}'`
            );
          }
        }
        if (hasUnescapedQuote) {
          hasError = true;
        }
      }
      output.push(`${lineNumber} STRINGLITERAL ${tokenText2}`);
    } else if (tokenType === "SINGLEOP" || tokenType === "MULTIOP") {
      output.push(`${lineNumber} ${tokenText}`);
    } else {
      output.push(`${lineNumber} ${tokenType} ${tokenText}`);
    }
    line = line.slice(tokenText.length);
    column += tokenText.length;
    line = line.trimStart();
  }
  return { lineOutput: output, hasError, stack };
}
var t = { 763: () => {
} }, e = {};
function n(s2) {
  var i2 = e[s2];
  if (void 0 !== i2) return i2.exports;
  var r2 = e[s2] = { exports: {} };
  return t[s2](r2, r2.exports, n), r2.exports;
}
n.d = (t2, e2) => {
  for (var s2 in e2) n.o(e2, s2) && !n.o(t2, s2) && Object.defineProperty(t2, s2, { enumerable: true, get: e2[s2] });
}, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
var s = {};
n.d(s, { MG: () => $, fr: () => Lt, sR: () => Ae, Zo: () => ke, iH: () => Re, rt: () => Pt, jB: () => be, M8: () => le, $t: () => Ce, aq: () => me, pG: () => Ot, eP: () => Te, KU: () => xe, zW: () => Ie, IX: () => E, mY: () => _, a7: () => j, JG: () => Ut, ay: () => Xt, X2: () => ee, WU: () => de, Uw: () => ge, gw: () => pe, iX: () => Fe, re: () => se, Pg: () => Be, tD: () => ie, R$: () => te, Dj: () => Ft, m7: () => U, NZ: () => P, xo: () => b, ou: () => i, qC: () => ze, mD: () => d, Ay: () => Ye });
class i {
  constructor() {
    this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
  }
  getTokenSource() {
    return this.source[0];
  }
  getInputStream() {
    return this.source[1];
  }
  get text() {
    return this._text;
  }
  set text(t2) {
    this._text = t2;
  }
}
function r(t2, e2) {
  if (!Array.isArray(t2) || !Array.isArray(e2)) return false;
  if (t2 === e2) return true;
  if (t2.length !== e2.length) return false;
  for (let n2 = 0; n2 < t2.length; n2++) if (!(t2[n2] === e2[n2] || t2[n2].equals && t2[n2].equals(e2[n2]))) return false;
  return true;
}
i.INVALID_TYPE = 0, i.EPSILON = -2, i.MIN_USER_TOKEN_TYPE = 1, i.EOF = -1, i.DEFAULT_CHANNEL = 0, i.HIDDEN_CHANNEL = 1;
const o = Math.round(Math.random() * Math.pow(2, 32));
function a(t2) {
  if (!t2) return 0;
  const e2 = typeof t2, n2 = "string" === e2 ? t2 : !("object" !== e2 || !t2.toString) && t2.toString();
  if (!n2) return 0;
  let s2, i2;
  const r2 = 3 & n2.length, a2 = n2.length - r2;
  let l2 = o;
  const h2 = 3432918353, c2 = 461845907;
  let u2 = 0;
  for (; u2 < a2; ) i2 = 255 & n2.charCodeAt(u2) | (255 & n2.charCodeAt(++u2)) << 8 | (255 & n2.charCodeAt(++u2)) << 16 | (255 & n2.charCodeAt(++u2)) << 24, ++u2, i2 = (65535 & i2) * h2 + (((i2 >>> 16) * h2 & 65535) << 16) & 4294967295, i2 = i2 << 15 | i2 >>> 17, i2 = (65535 & i2) * c2 + (((i2 >>> 16) * c2 & 65535) << 16) & 4294967295, l2 ^= i2, l2 = l2 << 13 | l2 >>> 19, s2 = 5 * (65535 & l2) + ((5 * (l2 >>> 16) & 65535) << 16) & 4294967295, l2 = 27492 + (65535 & s2) + ((58964 + (s2 >>> 16) & 65535) << 16);
  switch (i2 = 0, r2) {
    case 3:
      i2 ^= (255 & n2.charCodeAt(u2 + 2)) << 16;
    case 2:
      i2 ^= (255 & n2.charCodeAt(u2 + 1)) << 8;
    case 1:
      i2 ^= 255 & n2.charCodeAt(u2), i2 = (65535 & i2) * h2 + (((i2 >>> 16) * h2 & 65535) << 16) & 4294967295, i2 = i2 << 15 | i2 >>> 17, i2 = (65535 & i2) * c2 + (((i2 >>> 16) * c2 & 65535) << 16) & 4294967295, l2 ^= i2;
  }
  return l2 ^= n2.length, l2 ^= l2 >>> 16, l2 = 2246822507 * (65535 & l2) + ((2246822507 * (l2 >>> 16) & 65535) << 16) & 4294967295, l2 ^= l2 >>> 13, l2 = 3266489909 * (65535 & l2) + ((3266489909 * (l2 >>> 16) & 65535) << 16) & 4294967295, l2 ^= l2 >>> 16, l2 >>> 0;
}
class l {
  constructor() {
    this.count = 0, this.hash = 0;
  }
  update() {
    for (let t2 = 0; t2 < arguments.length; t2++) {
      const e2 = arguments[t2];
      if (null != e2) if (Array.isArray(e2)) this.update.apply(this, e2);
      else {
        let t3 = 0;
        switch (typeof e2) {
          case "undefined":
          case "function":
            continue;
          case "number":
          case "boolean":
            t3 = e2;
            break;
          case "string":
            t3 = a(e2);
            break;
          default:
            e2.updateHashCode ? e2.updateHashCode(this) : console.log("No updateHashCode for " + e2.toString());
            continue;
        }
        t3 *= 3432918353, t3 = t3 << 15 | t3 >>> 17, t3 *= 461845907, this.count = this.count + 1;
        let n2 = this.hash ^ t3;
        n2 = n2 << 13 | n2 >>> 19, n2 = 5 * n2 + 3864292196, this.hash = n2;
      }
    }
  }
  finish() {
    let t2 = this.hash ^ 4 * this.count;
    return t2 ^= t2 >>> 16, t2 *= 2246822507, t2 ^= t2 >>> 13, t2 *= 3266489909, t2 ^= t2 >>> 16, t2;
  }
  static hashStuff() {
    const t2 = new l();
    return t2.update.apply(t2, arguments), t2.finish();
  }
}
function h(t2) {
  return t2 ? "string" == typeof t2 ? a(t2) : t2.hashCode() : -1;
}
function c(t2, e2) {
  return t2 && t2.equals ? t2.equals(e2) : t2 === e2;
}
function u(t2) {
  return null === t2 ? "null" : t2;
}
function d(t2) {
  return Array.isArray(t2) ? "[" + t2.map(u).join(", ") + "]" : "null";
}
class g {
  constructor(t2, e2) {
    this.buckets = new Array(16), this.threshold = Math.floor(12), this.itemCount = 0, this.hashFunction = t2 || h, this.equalsFunction = e2 || c;
  }
  get(t2) {
    if (null == t2) return t2;
    const e2 = this._getBucket(t2);
    if (!e2) return null;
    for (const n2 of e2) if (this.equalsFunction(n2, t2)) return n2;
    return null;
  }
  add(t2) {
    return this.getOrAdd(t2) === t2;
  }
  getOrAdd(t2) {
    this._expand();
    const e2 = this._getSlot(t2);
    let n2 = this.buckets[e2];
    if (!n2) return n2 = [t2], this.buckets[e2] = n2, this.itemCount++, t2;
    for (const e3 of n2) if (this.equalsFunction(e3, t2)) return e3;
    return n2.push(t2), this.itemCount++, t2;
  }
  has(t2) {
    return null != this.get(t2);
  }
  values() {
    return this.buckets.filter(((t2) => null != t2)).flat(1);
  }
  toString() {
    return d(this.values());
  }
  get length() {
    return this.itemCount;
  }
  _getSlot(t2) {
    return this.hashFunction(t2) & this.buckets.length - 1;
  }
  _getBucket(t2) {
    return this.buckets[this._getSlot(t2)];
  }
  _expand() {
    if (this.itemCount <= this.threshold) return;
    const t2 = this.buckets, e2 = 2 * this.buckets.length;
    this.buckets = new Array(e2), this.threshold = Math.floor(0.75 * e2);
    for (const e3 of t2) if (e3) for (const t3 of e3) {
      const e4 = this._getSlot(t3);
      let n2 = this.buckets[e4];
      n2 || (n2 = [], this.buckets[e4] = n2), n2.push(t3);
    }
  }
}
class p {
  hashCode() {
    const t2 = new l();
    return this.updateHashCode(t2), t2.finish();
  }
  evaluate(t2, e2) {
  }
  evalPrecedence(t2, e2) {
    return this;
  }
  static andContext(t2, e2) {
    if (null === t2 || t2 === p.NONE) return e2;
    if (null === e2 || e2 === p.NONE) return t2;
    const n2 = new f(t2, e2);
    return 1 === n2.opnds.length ? n2.opnds[0] : n2;
  }
  static orContext(t2, e2) {
    if (null === t2) return e2;
    if (null === e2) return t2;
    if (t2 === p.NONE || e2 === p.NONE) return p.NONE;
    const n2 = new x(t2, e2);
    return 1 === n2.opnds.length ? n2.opnds[0] : n2;
  }
}
class f extends p {
  constructor(t2, e2) {
    super();
    const n2 = new g();
    t2 instanceof f ? t2.opnds.map((function(t3) {
      n2.add(t3);
    })) : n2.add(t2), e2 instanceof f ? e2.opnds.map((function(t3) {
      n2.add(t3);
    })) : n2.add(e2);
    const s2 = T(n2);
    if (s2.length > 0) {
      let t3 = null;
      s2.map((function(e3) {
        (null === t3 || e3.precedence < t3.precedence) && (t3 = e3);
      })), n2.add(t3);
    }
    this.opnds = Array.from(n2.values());
  }
  equals(t2) {
    return this === t2 || t2 instanceof f && r(this.opnds, t2.opnds);
  }
  updateHashCode(t2) {
    t2.update(this.opnds, "AND");
  }
  evaluate(t2, e2) {
    for (let n2 = 0; n2 < this.opnds.length; n2++) if (!this.opnds[n2].evaluate(t2, e2)) return false;
    return true;
  }
  evalPrecedence(t2, e2) {
    let n2 = false;
    const s2 = [];
    for (let i3 = 0; i3 < this.opnds.length; i3++) {
      const r2 = this.opnds[i3], o2 = r2.evalPrecedence(t2, e2);
      if (n2 |= o2 !== r2, null === o2) return null;
      o2 !== p.NONE && s2.push(o2);
    }
    if (!n2) return this;
    if (0 === s2.length) return p.NONE;
    let i2 = null;
    return s2.map((function(t3) {
      i2 = null === i2 ? t3 : p.andContext(i2, t3);
    })), i2;
  }
  toString() {
    const t2 = this.opnds.map(((t3) => t3.toString()));
    return (t2.length > 3 ? t2.slice(3) : t2).join("&&");
  }
}
class x extends p {
  constructor(t2, e2) {
    super();
    const n2 = new g();
    t2 instanceof x ? t2.opnds.map((function(t3) {
      n2.add(t3);
    })) : n2.add(t2), e2 instanceof x ? e2.opnds.map((function(t3) {
      n2.add(t3);
    })) : n2.add(e2);
    const s2 = T(n2);
    if (s2.length > 0) {
      const t3 = s2.sort((function(t4, e4) {
        return t4.compareTo(e4);
      })), e3 = t3[t3.length - 1];
      n2.add(e3);
    }
    this.opnds = Array.from(n2.values());
  }
  equals(t2) {
    return this === t2 || t2 instanceof x && r(this.opnds, t2.opnds);
  }
  updateHashCode(t2) {
    t2.update(this.opnds, "OR");
  }
  evaluate(t2, e2) {
    for (let n2 = 0; n2 < this.opnds.length; n2++) if (this.opnds[n2].evaluate(t2, e2)) return true;
    return false;
  }
  evalPrecedence(t2, e2) {
    let n2 = false;
    const s2 = [];
    for (let i2 = 0; i2 < this.opnds.length; i2++) {
      const r2 = this.opnds[i2], o2 = r2.evalPrecedence(t2, e2);
      if (n2 |= o2 !== r2, o2 === p.NONE) return p.NONE;
      null !== o2 && s2.push(o2);
    }
    if (!n2) return this;
    if (0 === s2.length) return null;
    return null;
  }
  toString() {
    const t2 = this.opnds.map(((t3) => t3.toString()));
    return (t2.length > 3 ? t2.slice(3) : t2).join("||");
  }
}
function T(t2) {
  const e2 = [];
  return t2.values().map((function(t3) {
    t3 instanceof p.PrecedencePredicate && e2.push(t3);
  })), e2;
}
function S(t2, e2) {
  if (null === t2) {
    const t3 = { state: null, alt: null, context: null, semanticContext: null };
    return e2 && (t3.reachesIntoOuterContext = 0), t3;
  }
  {
    const n2 = {};
    return n2.state = t2.state || null, n2.alt = void 0 === t2.alt ? null : t2.alt, n2.context = t2.context || null, n2.semanticContext = t2.semanticContext || null, e2 && (n2.reachesIntoOuterContext = t2.reachesIntoOuterContext || 0, n2.precedenceFilterSuppressed = t2.precedenceFilterSuppressed || false), n2;
  }
}
class m {
  constructor(t2, e2) {
    this.checkContext(t2, e2), t2 = S(t2), e2 = S(e2, true), this.state = null !== t2.state ? t2.state : e2.state, this.alt = null !== t2.alt ? t2.alt : e2.alt, this.context = null !== t2.context ? t2.context : e2.context, this.semanticContext = null !== t2.semanticContext ? t2.semanticContext : null !== e2.semanticContext ? e2.semanticContext : p.NONE, this.reachesIntoOuterContext = e2.reachesIntoOuterContext, this.precedenceFilterSuppressed = e2.precedenceFilterSuppressed;
  }
  checkContext(t2, e2) {
    null !== t2.context && void 0 !== t2.context || null !== e2 && null !== e2.context && void 0 !== e2.context || (this.context = null);
  }
  hashCode() {
    const t2 = new l();
    return this.updateHashCode(t2), t2.finish();
  }
  updateHashCode(t2) {
    t2.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }
  equals(t2) {
    return this === t2 || t2 instanceof m && this.state.stateNumber === t2.state.stateNumber && this.alt === t2.alt && (null === this.context ? null === t2.context : this.context.equals(t2.context)) && this.semanticContext.equals(t2.semanticContext) && this.precedenceFilterSuppressed === t2.precedenceFilterSuppressed;
  }
  hashCodeForConfigSet() {
    const t2 = new l();
    return t2.update(this.state.stateNumber, this.alt, this.semanticContext), t2.finish();
  }
  equalsForConfigSet(t2) {
    return this === t2 || t2 instanceof m && this.state.stateNumber === t2.state.stateNumber && this.alt === t2.alt && this.semanticContext.equals(t2.semanticContext);
  }
  toString() {
    return "(" + this.state + "," + this.alt + (null !== this.context ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== p.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
}
class E {
  constructor(t2, e2) {
    this.start = t2, this.stop = e2;
  }
  clone() {
    return new E(this.start, this.stop);
  }
  contains(t2) {
    return t2 >= this.start && t2 < this.stop;
  }
  toString() {
    return this.start === this.stop - 1 ? this.start.toString() : this.start.toString() + ".." + (this.stop - 1).toString();
  }
  get length() {
    return this.stop - this.start;
  }
}
E.INVALID_INTERVAL = new E(-1, -2);
class _ {
  constructor() {
    this.intervals = null, this.readOnly = false;
  }
  first(t2) {
    return null === this.intervals || 0 === this.intervals.length ? i.INVALID_TYPE : this.intervals[0].start;
  }
  addOne(t2) {
    this.addInterval(new E(t2, t2 + 1));
  }
  addRange(t2, e2) {
    this.addInterval(new E(t2, e2 + 1));
  }
  addInterval(t2) {
    if (null === this.intervals) this.intervals = [], this.intervals.push(t2.clone());
    else {
      for (let e2 = 0; e2 < this.intervals.length; e2++) {
        const n2 = this.intervals[e2];
        if (t2.stop < n2.start) return void this.intervals.splice(e2, 0, t2);
        if (t2.stop === n2.start) return void (this.intervals[e2] = new E(t2.start, n2.stop));
        if (t2.start <= n2.stop) return this.intervals[e2] = new E(Math.min(n2.start, t2.start), Math.max(n2.stop, t2.stop)), void this.reduce(e2);
      }
      this.intervals.push(t2.clone());
    }
  }
  addSet(t2) {
    return null !== t2.intervals && t2.intervals.forEach(((t3) => this.addInterval(t3)), this), this;
  }
  reduce(t2) {
    if (t2 < this.intervals.length - 1) {
      const e2 = this.intervals[t2], n2 = this.intervals[t2 + 1];
      e2.stop >= n2.stop ? (this.intervals.splice(t2 + 1, 1), this.reduce(t2)) : e2.stop >= n2.start && (this.intervals[t2] = new E(e2.start, n2.stop), this.intervals.splice(t2 + 1, 1));
    }
  }
  complement(t2, e2) {
    const n2 = new _();
    return n2.addInterval(new E(t2, e2 + 1)), null !== this.intervals && this.intervals.forEach(((t3) => n2.removeRange(t3))), n2;
  }
  contains(t2) {
    if (null === this.intervals) return false;
    for (let e2 = 0; e2 < this.intervals.length; e2++) if (this.intervals[e2].contains(t2)) return true;
    return false;
  }
  removeRange(t2) {
    if (t2.start === t2.stop - 1) this.removeOne(t2.start);
    else if (null !== this.intervals) {
      let e2 = 0;
      for (let n2 = 0; n2 < this.intervals.length; n2++) {
        const n3 = this.intervals[e2];
        if (t2.stop <= n3.start) return;
        if (t2.start > n3.start && t2.stop < n3.stop) {
          this.intervals[e2] = new E(n3.start, t2.start);
          const s2 = new E(t2.stop, n3.stop);
          return void this.intervals.splice(e2, 0, s2);
        }
        t2.start <= n3.start && t2.stop >= n3.stop ? (this.intervals.splice(e2, 1), e2 -= 1) : t2.start < n3.stop ? this.intervals[e2] = new E(n3.start, t2.start) : t2.stop < n3.stop && (this.intervals[e2] = new E(t2.stop, n3.stop)), e2 += 1;
      }
    }
  }
  removeOne(t2) {
    if (null !== this.intervals) for (let e2 = 0; e2 < this.intervals.length; e2++) {
      const n2 = this.intervals[e2];
      if (t2 < n2.start) return;
      if (t2 === n2.start && t2 === n2.stop - 1) return void this.intervals.splice(e2, 1);
      if (t2 === n2.start) return void (this.intervals[e2] = new E(n2.start + 1, n2.stop));
      if (t2 === n2.stop - 1) return void (this.intervals[e2] = new E(n2.start, n2.stop - 1));
      if (t2 < n2.stop - 1) {
        const s2 = new E(n2.start, t2);
        return n2.start = t2 + 1, void this.intervals.splice(e2, 0, s2);
      }
    }
  }
  toString(t2, e2, n2) {
    return t2 = t2 || null, e2 = e2 || null, n2 = n2 || false, null === this.intervals ? "{}" : null !== t2 || null !== e2 ? this.toTokenString(t2, e2) : n2 ? this.toCharString() : this.toIndexString();
  }
  toCharString() {
    const t2 = [];
    for (let e2 = 0; e2 < this.intervals.length; e2++) {
      const n2 = this.intervals[e2];
      n2.stop === n2.start + 1 ? n2.start === i.EOF ? t2.push("<EOF>") : t2.push("'" + String.fromCharCode(n2.start) + "'") : t2.push("'" + String.fromCharCode(n2.start) + "'..'" + String.fromCharCode(n2.stop - 1) + "'");
    }
    return t2.length > 1 ? "{" + t2.join(", ") + "}" : t2[0];
  }
  toIndexString() {
    const t2 = [];
    for (let e2 = 0; e2 < this.intervals.length; e2++) {
      const n2 = this.intervals[e2];
      n2.stop === n2.start + 1 ? n2.start === i.EOF ? t2.push("<EOF>") : t2.push(n2.start.toString()) : t2.push(n2.start.toString() + ".." + (n2.stop - 1).toString());
    }
    return t2.length > 1 ? "{" + t2.join(", ") + "}" : t2[0];
  }
  toTokenString(t2, e2) {
    const n2 = [];
    for (let s2 = 0; s2 < this.intervals.length; s2++) {
      const i2 = this.intervals[s2];
      for (let s3 = i2.start; s3 < i2.stop; s3++) n2.push(this.elementName(t2, e2, s3));
    }
    return n2.length > 1 ? "{" + n2.join(", ") + "}" : n2[0];
  }
  elementName(t2, e2, n2) {
    return n2 === i.EOF ? "<EOF>" : n2 === i.EPSILON ? "<EPSILON>" : t2[n2] || e2[n2];
  }
  get length() {
    return this.intervals.map(((t2) => t2.length)).reduce(((t2, e2) => t2 + e2));
  }
}
class C {
  constructor() {
    this.atn = null, this.stateNumber = C.INVALID_STATE_NUMBER, this.stateType = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = false, this.transitions = [], this.nextTokenWithinRule = null;
  }
  toString() {
    return this.stateNumber;
  }
  equals(t2) {
    return t2 instanceof C && this.stateNumber === t2.stateNumber;
  }
  isNonGreedyExitState() {
    return false;
  }
  addTransition(t2, e2) {
    void 0 === e2 && (e2 = -1), 0 === this.transitions.length ? this.epsilonOnlyTransitions = t2.isEpsilon : this.epsilonOnlyTransitions !== t2.isEpsilon && (this.epsilonOnlyTransitions = false), -1 === e2 ? this.transitions.push(t2) : this.transitions.splice(e2, 1, t2);
  }
}
C.INVALID_TYPE = 0, C.BASIC = 1, C.RULE_START = 2, C.BLOCK_START = 3, C.PLUS_BLOCK_START = 4, C.STAR_BLOCK_START = 5, C.TOKEN_START = 6, C.RULE_STOP = 7, C.BLOCK_END = 8, C.STAR_LOOP_BACK = 9, C.STAR_LOOP_ENTRY = 10, C.PLUS_LOOP_BACK = 11, C.LOOP_END = 12, C.serializationNames = ["INVALID", "BASIC", "RULE_START", "BLOCK_START", "PLUS_BLOCK_START", "STAR_BLOCK_START", "TOKEN_START", "RULE_STOP", "BLOCK_END", "STAR_LOOP_BACK", "STAR_LOOP_ENTRY", "PLUS_LOOP_BACK", "LOOP_END"], C.INVALID_STATE_NUMBER = -1;
class A extends C {
  constructor() {
    return super(), this.stateType = C.RULE_STOP, this;
  }
}
class N {
  constructor(t2) {
    if (null == t2) throw "target cannot be null.";
    this.target = t2, this.isEpsilon = false, this.label = null;
  }
}
N.EPSILON = 1, N.RANGE = 2, N.RULE = 3, N.PREDICATE = 4, N.ATOM = 5, N.ACTION = 6, N.SET = 7, N.NOT_SET = 8, N.WILDCARD = 9, N.PRECEDENCE = 10, N.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"], N.serializationTypes = { EpsilonTransition: N.EPSILON, RangeTransition: N.RANGE, RuleTransition: N.RULE, PredicateTransition: N.PREDICATE, AtomTransition: N.ATOM, ActionTransition: N.ACTION, SetTransition: N.SET, NotSetTransition: N.NOT_SET, WildcardTransition: N.WILDCARD, PrecedencePredicateTransition: N.PRECEDENCE };
class k extends N {
  constructor(t2, e2, n2, s2) {
    super(t2), this.ruleIndex = e2, this.precedence = n2, this.followState = s2, this.serializationType = N.RULE, this.isEpsilon = true;
  }
  matches(t2, e2, n2) {
    return false;
  }
}
class I extends N {
  constructor(t2, e2) {
    super(t2), this.serializationType = N.SET, null != e2 ? this.label = e2 : (this.label = new _(), this.label.addOne(i.INVALID_TYPE));
  }
  matches(t2, e2, n2) {
    return this.label.contains(t2);
  }
  toString() {
    return this.label.toString();
  }
}
class y extends I {
  constructor(t2, e2) {
    super(t2, e2), this.serializationType = N.NOT_SET;
  }
  matches(t2, e2, n2) {
    return t2 >= e2 && t2 <= n2 && !super.matches(t2, e2, n2);
  }
  toString() {
    return "~" + super.toString();
  }
}
class L extends N {
  constructor(t2) {
    super(t2), this.serializationType = N.WILDCARD;
  }
  matches(t2, e2, n2) {
    return t2 >= e2 && t2 <= n2;
  }
  toString() {
    return ".";
  }
}
class O extends N {
  constructor(t2) {
    super(t2);
  }
}
class R {
}
class w extends R {
}
class v extends w {
}
class P extends v {
  get ruleContext() {
    throw new Error("missing interface implementation");
  }
}
class b extends v {
}
class D extends b {
}
const F = { toStringTree: function(t2, e2, n2) {
  e2 = e2 || null, null !== (n2 = n2 || null) && (e2 = n2.ruleNames);
  let s2 = F.getNodeText(t2, e2);
  s2 = (function(t3) {
    return t3 = t3.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
  })(s2);
  const i2 = t2.getChildCount();
  if (0 === i2) return s2;
  let r2 = "(" + s2 + " ";
  i2 > 0 && (s2 = F.toStringTree(t2.getChild(0), e2), r2 = r2.concat(s2));
  for (let n3 = 1; n3 < i2; n3++) s2 = F.toStringTree(t2.getChild(n3), e2), r2 = r2.concat(" " + s2);
  return r2 = r2.concat(")"), r2;
}, getNodeText: function(t2, e2, n2) {
  if (e2 = e2 || null, null !== (n2 = n2 || null) && (e2 = n2.ruleNames), null !== e2) {
    if (t2 instanceof P) {
      const n3 = t2.ruleContext.getAltNumber();
      return 0 != n3 ? e2[t2.ruleIndex] + ":" + n3 : e2[t2.ruleIndex];
    }
    if (t2 instanceof D) return t2.toString();
    if (t2 instanceof b && null !== t2.symbol) return t2.symbol.text;
  }
  const s2 = t2.getPayload();
  return s2 instanceof i ? s2.text : t2.getPayload().toString();
}, getChildren: function(t2) {
  const e2 = [];
  for (let n2 = 0; n2 < t2.getChildCount(); n2++) e2.push(t2.getChild(n2));
  return e2;
}, getAncestors: function(t2) {
  let e2 = [];
  for (t2 = t2.getParent(); null !== t2; ) e2 = [t2].concat(e2), t2 = t2.getParent();
  return e2;
}, findAllTokenNodes: function(t2, e2) {
  return F.findAllNodes(t2, e2, true);
}, findAllRuleNodes: function(t2, e2) {
  return F.findAllNodes(t2, e2, false);
}, findAllNodes: function(t2, e2, n2) {
  const s2 = [];
  return F._findAllNodes(t2, e2, n2, s2), s2;
}, _findAllNodes: function(t2, e2, n2, s2) {
  n2 && t2 instanceof b ? t2.symbol.type === e2 && s2.push(t2) : !n2 && t2 instanceof P && t2.ruleIndex === e2 && s2.push(t2);
  for (let i2 = 0; i2 < t2.getChildCount(); i2++) F._findAllNodes(t2.getChild(i2), e2, n2, s2);
}, descendants: function(t2) {
  let e2 = [t2];
  for (let n2 = 0; n2 < t2.getChildCount(); n2++) e2 = e2.concat(F.descendants(t2.getChild(n2)));
  return e2;
} }, M = F;
class U extends P {
  constructor(t2, e2) {
    super(), this.parentCtx = t2 || null, this.invokingState = e2 || -1;
  }
  depth() {
    let t2 = 0, e2 = this;
    for (; null !== e2; ) e2 = e2.parentCtx, t2 += 1;
    return t2;
  }
  isEmpty() {
    return -1 === this.invokingState;
  }
  getSourceInterval() {
    return E.INVALID_INTERVAL;
  }
  get ruleContext() {
    return this;
  }
  getPayload() {
    return this;
  }
  getText() {
    return 0 === this.getChildCount() ? "" : this.children.map((function(t2) {
      return t2.getText();
    })).join("");
  }
  getAltNumber() {
    return 0;
  }
  setAltNumber(t2) {
  }
  getChild(t2) {
    return null;
  }
  getChildCount() {
    return 0;
  }
  accept(t2) {
    return t2.visitChildren(this);
  }
  toStringTree(t2, e2) {
    return M.toStringTree(this, t2, e2);
  }
  toString(t2, e2) {
    t2 = t2 || null, e2 = e2 || null;
    let n2 = this, s2 = "[";
    for (; null !== n2 && n2 !== e2; ) {
      if (null === t2) n2.isEmpty() || (s2 += n2.invokingState);
      else {
        const e3 = n2.ruleIndex;
        s2 += e3 >= 0 && e3 < t2.length ? t2[e3] : "" + e3;
      }
      null === n2.parentCtx || null === t2 && n2.parentCtx.isEmpty() || (s2 += " "), n2 = n2.parentCtx;
    }
    return s2 += "]", s2;
  }
}
class B {
  constructor(t2) {
    this.cachedHashCode = t2;
  }
  isEmpty() {
    return this === B.EMPTY;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === B.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t2) {
    t2.update(this.cachedHashCode);
  }
}
B.EMPTY = null, B.EMPTY_RETURN_STATE = 2147483647, B.globalNodeCount = 1, B.id = B.globalNodeCount, B.trace_atn_sim = false;
class z extends B {
  constructor(t2, e2) {
    const n2 = new l();
    return n2.update(t2, e2), super(n2.finish()), this.parents = t2, this.returnStates = e2, this;
  }
  isEmpty() {
    return this.returnStates[0] === B.EMPTY_RETURN_STATE;
  }
  getParent(t2) {
    return this.parents[t2];
  }
  getReturnState(t2) {
    return this.returnStates[t2];
  }
  equals(t2) {
    return this === t2 || t2 instanceof z && this.hashCode() === t2.hashCode() && r(this.returnStates, t2.returnStates) && r(this.parents, t2.parents);
  }
  toString() {
    if (this.isEmpty()) return "[]";
    {
      let t2 = "[";
      for (let e2 = 0; e2 < this.returnStates.length; e2++) e2 > 0 && (t2 += ", "), this.returnStates[e2] !== B.EMPTY_RETURN_STATE ? (t2 += this.returnStates[e2], null !== this.parents[e2] ? t2 = t2 + " " + this.parents[e2] : t2 += "null") : t2 += "$";
      return t2 + "]";
    }
  }
  get length() {
    return this.returnStates.length;
  }
}
class V extends B {
  constructor(t2, e2) {
    let n2 = 0;
    const s2 = new l();
    null !== t2 ? s2.update(t2, e2) : s2.update(1), n2 = s2.finish(), super(n2), this.parentCtx = t2, this.returnState = e2;
  }
  getParent(t2) {
    return this.parentCtx;
  }
  getReturnState(t2) {
    return this.returnState;
  }
  equals(t2) {
    return this === t2 || t2 instanceof V && this.hashCode() === t2.hashCode() && this.returnState === t2.returnState && (null == this.parentCtx ? null == t2.parentCtx : this.parentCtx.equals(t2.parentCtx));
  }
  toString() {
    const t2 = null === this.parentCtx ? "" : this.parentCtx.toString();
    return 0 === t2.length ? this.returnState === B.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : this.returnState + " " + t2;
  }
  get length() {
    return 1;
  }
  static create(t2, e2) {
    return e2 === B.EMPTY_RETURN_STATE && null === t2 ? B.EMPTY : new V(t2, e2);
  }
}
class q extends V {
  constructor() {
    super(null, B.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent(t2) {
    return null;
  }
  getReturnState(t2) {
    return this.returnState;
  }
  equals(t2) {
    return this === t2;
  }
  toString() {
    return "$";
  }
}
B.EMPTY = new q();
class H {
  constructor(t2, e2) {
    this.buckets = new Array(16), this.threshold = Math.floor(12), this.itemCount = 0, this.hashFunction = t2 || h, this.equalsFunction = e2 || c;
  }
  set(t2, e2) {
    this._expand();
    const n2 = this._getSlot(t2);
    let s2 = this.buckets[n2];
    if (!s2) return s2 = [[t2, e2]], this.buckets[n2] = s2, this.itemCount++, e2;
    const i2 = s2.find(((e3) => this.equalsFunction(e3[0], t2)), this);
    if (i2) {
      const t3 = i2[1];
      return i2[1] = e2, t3;
    }
    return s2.push([t2, e2]), this.itemCount++, e2;
  }
  containsKey(t2) {
    const e2 = this._getBucket(t2);
    return !!e2 && !!e2.find(((e3) => this.equalsFunction(e3[0], t2)), this);
  }
  get(t2) {
    const e2 = this._getBucket(t2);
    if (!e2) return null;
    const n2 = e2.find(((e3) => this.equalsFunction(e3[0], t2)), this);
    return n2 ? n2[1] : null;
  }
  entries() {
    return this.buckets.filter(((t2) => null != t2)).flat(1);
  }
  getKeys() {
    return this.entries().map(((t2) => t2[0]));
  }
  getValues() {
    return this.entries().map(((t2) => t2[1]));
  }
  toString() {
    return "[" + this.entries().map(((t2) => "{" + t2[0] + ":" + t2[1] + "}")).join(", ") + "]";
  }
  get length() {
    return this.itemCount;
  }
  _getSlot(t2) {
    return this.hashFunction(t2) & this.buckets.length - 1;
  }
  _getBucket(t2) {
    return this.buckets[this._getSlot(t2)];
  }
  _expand() {
    if (this.itemCount <= this.threshold) return;
    const t2 = this.buckets, e2 = 2 * this.buckets.length;
    this.buckets = new Array(e2), this.threshold = Math.floor(0.75 * e2);
    for (const e3 of t2) if (e3) for (const t3 of e3) {
      const e4 = this._getSlot(t3[0]);
      let n2 = this.buckets[e4];
      n2 || (n2 = [], this.buckets[e4] = n2), n2.push(t3);
    }
  }
}
function K(t2, e2) {
  if (null == e2 && (e2 = U.EMPTY), null === e2.parentCtx || e2 === U.EMPTY) return B.EMPTY;
  const n2 = K(t2, e2.parentCtx), s2 = t2.states[e2.invokingState].transitions[0];
  return V.create(n2, s2.followState.stateNumber);
}
function Y(t2, e2, n2) {
  if (t2.isEmpty()) return t2;
  let s2 = n2.get(t2) || null;
  if (null !== s2) return s2;
  if (s2 = e2.get(t2), null !== s2) return n2.set(t2, s2), s2;
  let i2 = false, r2 = [];
  for (let s3 = 0; s3 < r2.length; s3++) {
    const o3 = Y(t2.getParent(s3), e2, n2);
    if (i2 || o3 !== t2.getParent(s3)) {
      if (!i2) {
        r2 = [];
        for (let e3 = 0; e3 < t2.length; e3++) r2[e3] = t2.getParent(e3);
        i2 = true;
      }
      r2[s3] = o3;
    }
  }
  if (!i2) return e2.add(t2), n2.set(t2, t2), t2;
  let o2 = null;
  return o2 = 0 === r2.length ? B.EMPTY : 1 === r2.length ? V.create(r2[0], t2.getReturnState(0)) : new z(r2, t2.returnStates), e2.add(o2), n2.set(o2, o2), n2.set(t2, o2), o2;
}
function G(t2, e2, n2, s2) {
  if (t2 === e2) return t2;
  if (t2 instanceof V && e2 instanceof V) return (function(t3, e3, n3, s3) {
    if (null !== s3) {
      let n4 = s3.get(t3, e3);
      if (null !== n4) return n4;
      if (n4 = s3.get(e3, t3), null !== n4) return n4;
    }
    const i2 = (function(t4, e4, n4) {
      if (n4) {
        if (t4 === B.EMPTY) return B.EMPTY;
        if (e4 === B.EMPTY) return B.EMPTY;
      } else {
        if (t4 === B.EMPTY && e4 === B.EMPTY) return B.EMPTY;
        if (t4 === B.EMPTY) {
          const t5 = [e4.returnState, B.EMPTY_RETURN_STATE], n5 = [e4.parentCtx, null];
          return new z(n5, t5);
        }
        if (e4 === B.EMPTY) {
          const e5 = [t4.returnState, B.EMPTY_RETURN_STATE], n5 = [t4.parentCtx, null];
          return new z(n5, e5);
        }
      }
      return null;
    })(t3, e3, n3);
    if (null !== i2) return null !== s3 && s3.set(t3, e3, i2), i2;
    if (t3.returnState === e3.returnState) {
      const i3 = G(t3.parentCtx, e3.parentCtx, n3, s3);
      if (i3 === t3.parentCtx) return t3;
      if (i3 === e3.parentCtx) return e3;
      const r2 = V.create(i3, t3.returnState);
      return null !== s3 && s3.set(t3, e3, r2), r2;
    }
    {
      let n4 = null;
      if ((t3 === e3 || null !== t3.parentCtx && t3.parentCtx === e3.parentCtx) && (n4 = t3.parentCtx), null !== n4) {
        const i4 = [t3.returnState, e3.returnState];
        t3.returnState > e3.returnState && (i4[0] = e3.returnState, i4[1] = t3.returnState);
        const r3 = new z([n4, n4], i4);
        return null !== s3 && s3.set(t3, e3, r3), r3;
      }
      const i3 = [t3.returnState, e3.returnState];
      let r2 = [t3.parentCtx, e3.parentCtx];
      t3.returnState > e3.returnState && (i3[0] = e3.returnState, i3[1] = t3.returnState, r2 = [e3.parentCtx, t3.parentCtx]);
      const o2 = new z(r2, i3);
      return null !== s3 && s3.set(t3, e3, o2), o2;
    }
  })(t2, e2, n2, s2);
  if (n2) {
    if (t2 instanceof q) return t2;
    if (e2 instanceof q) return e2;
  }
  return t2 instanceof V && (t2 = new z([t2.getParent()], [t2.returnState])), e2 instanceof V && (e2 = new z([e2.getParent()], [e2.returnState])), (function(t3, e3, n3, s3) {
    if (null !== s3) {
      let n4 = s3.get(t3, e3);
      if (null !== n4) return B.trace_atn_sim && console.log("mergeArrays a=" + t3 + ",b=" + e3 + " -> previous"), n4;
      if (n4 = s3.get(e3, t3), null !== n4) return B.trace_atn_sim && console.log("mergeArrays a=" + t3 + ",b=" + e3 + " -> previous"), n4;
    }
    let i2 = 0, r2 = 0, o2 = 0, a2 = new Array(t3.returnStates.length + e3.returnStates.length).fill(0), l2 = new Array(t3.returnStates.length + e3.returnStates.length).fill(null);
    for (; i2 < t3.returnStates.length && r2 < e3.returnStates.length; ) {
      const h3 = t3.parents[i2], c2 = e3.parents[r2];
      if (t3.returnStates[i2] === e3.returnStates[r2]) {
        const e4 = t3.returnStates[i2];
        e4 === B.EMPTY_RETURN_STATE && null === h3 && null === c2 || null !== h3 && null !== c2 && h3 === c2 ? (l2[o2] = h3, a2[o2] = e4) : (l2[o2] = G(h3, c2, n3, s3), a2[o2] = e4), i2 += 1, r2 += 1;
      } else t3.returnStates[i2] < e3.returnStates[r2] ? (l2[o2] = h3, a2[o2] = t3.returnStates[i2], i2 += 1) : (l2[o2] = c2, a2[o2] = e3.returnStates[r2], r2 += 1);
      o2 += 1;
    }
    if (i2 < t3.returnStates.length) for (let e4 = i2; e4 < t3.returnStates.length; e4++) l2[o2] = t3.parents[e4], a2[o2] = t3.returnStates[e4], o2 += 1;
    else for (let t4 = r2; t4 < e3.returnStates.length; t4++) l2[o2] = e3.parents[t4], a2[o2] = e3.returnStates[t4], o2 += 1;
    if (o2 < l2.length) {
      if (1 === o2) {
        const n4 = V.create(l2[0], a2[0]);
        return null !== s3 && s3.set(t3, e3, n4), n4;
      }
      l2 = l2.slice(0, o2), a2 = a2.slice(0, o2);
    }
    const h2 = new z(l2, a2);
    return h2.equals(t3) ? (null !== s3 && s3.set(t3, e3, t3), B.trace_atn_sim && console.log("mergeArrays a=" + t3 + ",b=" + e3 + " -> a"), t3) : h2.equals(e3) ? (null !== s3 && s3.set(t3, e3, e3), B.trace_atn_sim && console.log("mergeArrays a=" + t3 + ",b=" + e3 + " -> b"), e3) : ((function(t4) {
      const e4 = new H();
      for (let n4 = 0; n4 < t4.length; n4++) {
        const s4 = t4[n4];
        e4.containsKey(s4) || e4.set(s4, s4);
      }
      for (let n4 = 0; n4 < t4.length; n4++) t4[n4] = e4.get(t4[n4]);
    })(l2), null !== s3 && s3.set(t3, e3, h2), B.trace_atn_sim && console.log("mergeArrays a=" + t3 + ",b=" + e3 + " -> " + h2), h2);
  })(t2, e2, n2, s2);
}
class W {
  constructor() {
    this.data = new Uint32Array(1);
  }
  set(t2) {
    W._checkIndex(t2), this._resize(t2), this.data[t2 >>> 5] |= 1 << t2 % 32;
  }
  get(t2) {
    W._checkIndex(t2);
    const e2 = t2 >>> 5;
    return !(e2 >= this.data.length || !(this.data[e2] & 1 << t2 % 32));
  }
  clear(t2) {
    W._checkIndex(t2);
    const e2 = t2 >>> 5;
    e2 < this.data.length && (this.data[e2] &= ~(1 << t2));
  }
  or(t2) {
    const e2 = Math.min(this.data.length, t2.data.length);
    for (let n2 = 0; n2 < e2; ++n2) this.data[n2] |= t2.data[n2];
    if (this.data.length < t2.data.length) {
      this._resize((t2.data.length << 5) - 1);
      const n2 = t2.data.length;
      for (let s2 = e2; s2 < n2; ++s2) this.data[s2] = t2.data[s2];
    }
  }
  values() {
    const t2 = new Array(this.length);
    let e2 = 0;
    const n2 = this.data.length;
    for (let s2 = 0; s2 < n2; ++s2) {
      let n3 = this.data[s2];
      for (; 0 !== n3; ) {
        const i2 = n3 & -n3;
        t2[e2++] = (s2 << 5) + W._bitCount(i2 - 1), n3 ^= i2;
      }
    }
    return t2;
  }
  minValue() {
    for (let t2 = 0; t2 < this.data.length; ++t2) {
      let e2 = this.data[t2];
      if (0 !== e2) {
        let n2 = 0;
        for (; !(1 & e2); ) n2++, e2 >>= 1;
        return n2 + 32 * t2;
      }
    }
    return 0;
  }
  hashCode() {
    return l.hashStuff(this.values());
  }
  equals(t2) {
    return t2 instanceof W && r(this.data, t2.data);
  }
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  get length() {
    return this.data.map(((t2) => W._bitCount(t2))).reduce(((t2, e2) => t2 + e2), 0);
  }
  _resize(t2) {
    const e2 = t2 + 32 >>> 5;
    if (e2 <= this.data.length) return;
    const n2 = new Uint32Array(e2);
    n2.set(this.data), n2.fill(0, this.data.length), this.data = n2;
  }
  static _checkIndex(t2) {
    if (t2 < 0) throw new RangeError("index cannot be negative");
  }
  static _bitCount(t2) {
    return t2 = (t2 = (858993459 & (t2 -= t2 >> 1 & 1431655765)) + (t2 >> 2 & 858993459)) + (t2 >> 4) & 252645135, t2 += t2 >> 8, 0 + (t2 += t2 >> 16) & 63;
  }
}
class j {
  constructor(t2) {
    this.atn = t2;
  }
  getDecisionLookahead(t2) {
    if (null === t2) return null;
    const e2 = t2.transitions.length, n2 = [];
    for (let s2 = 0; s2 < e2; s2++) {
      n2[s2] = new _();
      const e3 = new g(), i2 = false;
      this._LOOK(t2.transition(s2).target, null, B.EMPTY, n2[s2], e3, new W(), i2, false), (0 === n2[s2].length || n2[s2].contains(j.HIT_PRED)) && (n2[s2] = null);
    }
    return n2;
  }
  LOOK(t2, e2, n2) {
    const s2 = new _(), i2 = null !== (n2 = n2 || null) ? K(t2.atn, n2) : null;
    return this._LOOK(t2, e2, i2, s2, new g(), new W(), true, true), s2;
  }
  _LOOK(t2, e2, n2, s2, r2, o2, a2, l2) {
    const h2 = new m({ state: t2, alt: 0, context: n2 }, null);
    if (!r2.has(h2)) {
      if (r2.add(h2), t2 === e2) {
        if (null === n2) return void s2.addOne(i.EPSILON);
        if (n2.isEmpty() && l2) return void s2.addOne(i.EOF);
      }
      if (t2 instanceof A) {
        if (null === n2) return void s2.addOne(i.EPSILON);
        if (n2.isEmpty() && l2) return void s2.addOne(i.EOF);
        if (n2 !== B.EMPTY) {
          const i2 = o2.get(t2.ruleIndex);
          try {
            o2.clear(t2.ruleIndex);
            for (let t3 = 0; t3 < n2.length; t3++) {
              const i3 = this.atn.states[n2.getReturnState(t3)];
              this._LOOK(i3, e2, n2.getParent(t3), s2, r2, o2, a2, l2);
            }
          } finally {
            i2 && o2.set(t2.ruleIndex);
          }
          return;
        }
      }
      for (let h3 = 0; h3 < t2.transitions.length; h3++) {
        const c2 = t2.transitions[h3];
        if (c2.constructor === k) {
          if (o2.get(c2.target.ruleIndex)) continue;
          const t3 = V.create(n2, c2.followState.stateNumber);
          try {
            o2.set(c2.target.ruleIndex), this._LOOK(c2.target, e2, t3, s2, r2, o2, a2, l2);
          } finally {
            o2.clear(c2.target.ruleIndex);
          }
        } else if (c2 instanceof O) a2 ? this._LOOK(c2.target, e2, n2, s2, r2, o2, a2, l2) : s2.addOne(j.HIT_PRED);
        else if (c2.isEpsilon) this._LOOK(c2.target, e2, n2, s2, r2, o2, a2, l2);
        else if (c2.constructor === L) s2.addRange(i.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
        else {
          let t3 = c2.label;
          null !== t3 && (c2 instanceof y && (t3 = t3.complement(i.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), s2.addSet(t3));
        }
      }
    }
  }
}
j.HIT_PRED = i.INVALID_TYPE;
class $ {
  constructor(t2, e2) {
    this.grammarType = t2, this.maxTokenType = e2, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = null, this.modeNameToStartState = {}, this.ruleToTokenType = null, this.lexerActions = null, this.modeToStartState = [];
  }
  nextTokensInContext(t2, e2) {
    return new j(this).LOOK(t2, null, e2);
  }
  nextTokensNoContext(t2) {
    return null !== t2.nextTokenWithinRule || (t2.nextTokenWithinRule = this.nextTokensInContext(t2, null), t2.nextTokenWithinRule.readOnly = true), t2.nextTokenWithinRule;
  }
  nextTokens(t2, e2) {
    return void 0 === e2 ? this.nextTokensNoContext(t2) : this.nextTokensInContext(t2, e2);
  }
  addState(t2) {
    null !== t2 && (t2.atn = this, t2.stateNumber = this.states.length), this.states.push(t2);
  }
  removeState(t2) {
    this.states[t2.stateNumber] = null;
  }
  defineDecisionState(t2) {
    return this.decisionToState.push(t2), t2.decision = this.decisionToState.length - 1, t2.decision;
  }
  getDecisionState(t2) {
    return 0 === this.decisionToState.length ? null : this.decisionToState[t2];
  }
  getExpectedTokens(t2, e2) {
    if (t2 < 0 || t2 >= this.states.length) throw "Invalid state number.";
    const n2 = this.states[t2];
    let s2 = this.nextTokens(n2);
    if (!s2.contains(i.EPSILON)) return s2;
    const r2 = new _();
    for (r2.addSet(s2), r2.removeOne(i.EPSILON); null !== e2 && e2.invokingState >= 0 && s2.contains(i.EPSILON); ) {
      const t3 = this.states[e2.invokingState].transitions[0];
      s2 = this.nextTokens(t3.followState), r2.addSet(s2), r2.removeOne(i.EPSILON), e2 = e2.parentCtx;
    }
    return s2.contains(i.EPSILON) && r2.addOne(i.EOF), r2;
  }
}
$.INVALID_ALT_NUMBER = 0;
class X extends C {
  constructor() {
    super(), this.stateType = C.BASIC;
  }
}
class J extends C {
  constructor() {
    return super(), this.decision = -1, this.nonGreedy = false, this;
  }
}
class Z extends J {
  constructor() {
    return super(), this.endState = null, this;
  }
}
class Q extends C {
  constructor() {
    return super(), this.stateType = C.BLOCK_END, this.startState = null, this;
  }
}
class tt extends C {
  constructor() {
    return super(), this.stateType = C.LOOP_END, this.loopBackState = null, this;
  }
}
class et extends C {
  constructor() {
    return super(), this.stateType = C.RULE_START, this.stopState = null, this.isPrecedenceRule = false, this;
  }
}
class nt extends J {
  constructor() {
    return super(), this.stateType = C.TOKEN_START, this;
  }
}
class st extends J {
  constructor() {
    return super(), this.stateType = C.PLUS_LOOP_BACK, this;
  }
}
class it extends C {
  constructor() {
    return super(), this.stateType = C.STAR_LOOP_BACK, this;
  }
}
class rt extends J {
  constructor() {
    return super(), this.stateType = C.STAR_LOOP_ENTRY, this.loopBackState = null, this.isPrecedenceDecision = null, this;
  }
}
class ot extends Z {
  constructor() {
    return super(), this.stateType = C.PLUS_BLOCK_START, this.loopBackState = null, this;
  }
}
class at extends Z {
  constructor() {
    return super(), this.stateType = C.STAR_BLOCK_START, this;
  }
}
class lt extends Z {
  constructor() {
    return super(), this.stateType = C.BLOCK_START, this;
  }
}
class ht extends N {
  constructor(t2, e2) {
    super(t2), this.label_ = e2, this.label = this.makeLabel(), this.serializationType = N.ATOM;
  }
  makeLabel() {
    const t2 = new _();
    return t2.addOne(this.label_), t2;
  }
  matches(t2, e2, n2) {
    return this.label_ === t2;
  }
  toString() {
    return this.label_;
  }
}
class ct extends N {
  constructor(t2, e2, n2) {
    super(t2), this.serializationType = N.RANGE, this.start = e2, this.stop = n2, this.label = this.makeLabel();
  }
  makeLabel() {
    const t2 = new _();
    return t2.addRange(this.start, this.stop), t2;
  }
  matches(t2, e2, n2) {
    return t2 >= this.start && t2 <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
}
class ut extends N {
  constructor(t2, e2, n2, s2) {
    super(t2), this.serializationType = N.ACTION, this.ruleIndex = e2, this.actionIndex = void 0 === n2 ? -1 : n2, this.isCtxDependent = void 0 !== s2 && s2, this.isEpsilon = true;
  }
  matches(t2, e2, n2) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
}
class dt extends N {
  constructor(t2, e2) {
    super(t2), this.serializationType = N.EPSILON, this.isEpsilon = true, this.outermostPrecedenceReturn = e2;
  }
  matches(t2, e2, n2) {
    return false;
  }
  toString() {
    return "epsilon";
  }
}
class gt extends p {
  constructor(t2, e2, n2) {
    super(), this.ruleIndex = void 0 === t2 ? -1 : t2, this.predIndex = void 0 === e2 ? -1 : e2, this.isCtxDependent = void 0 !== n2 && n2;
  }
  evaluate(t2, e2) {
    const n2 = this.isCtxDependent ? e2 : null;
    return t2.sempred(n2, this.ruleIndex, this.predIndex);
  }
  updateHashCode(t2) {
    t2.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  equals(t2) {
    return this === t2 || t2 instanceof gt && this.ruleIndex === t2.ruleIndex && this.predIndex === t2.predIndex && this.isCtxDependent === t2.isCtxDependent;
  }
  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }
}
p.NONE = new gt();
class pt extends O {
  constructor(t2, e2, n2, s2) {
    super(t2), this.serializationType = N.PREDICATE, this.ruleIndex = e2, this.predIndex = n2, this.isCtxDependent = s2, this.isEpsilon = true;
  }
  matches(t2, e2, n2) {
    return false;
  }
  getPredicate() {
    return new gt(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
}
class ft extends p {
  constructor(t2) {
    super(), this.precedence = void 0 === t2 ? 0 : t2;
  }
  evaluate(t2, e2) {
    return t2.precpred(e2, this.precedence);
  }
  evalPrecedence(t2, e2) {
    return t2.precpred(e2, this.precedence) ? p.NONE : null;
  }
  compareTo(t2) {
    return this.precedence - t2.precedence;
  }
  updateHashCode(t2) {
    t2.update(this.precedence);
  }
  equals(t2) {
    return this === t2 || t2 instanceof ft && this.precedence === t2.precedence;
  }
  toString() {
    return "{" + this.precedence + ">=prec}?";
  }
}
p.PrecedencePredicate = ft;
class xt extends O {
  constructor(t2, e2) {
    super(t2), this.serializationType = N.PRECEDENCE, this.precedence = e2, this.isEpsilon = true;
  }
  matches(t2, e2, n2) {
    return false;
  }
  getPredicate() {
    return new ft(this.precedence);
  }
  toString() {
    return this.precedence + " >= _p";
  }
}
class Tt {
  constructor(t2) {
    void 0 === t2 && (t2 = null), this.readOnly = false, this.verifyATN = null === t2 || t2.verifyATN, this.generateRuleBypassTransitions = null !== t2 && t2.generateRuleBypassTransitions;
  }
}
Tt.defaultOptions = new Tt(), Tt.defaultOptions.readOnly = true;
class St {
  constructor(t2) {
    this.actionType = t2, this.isPositionDependent = false;
  }
  hashCode() {
    const t2 = new l();
    return this.updateHashCode(t2), t2.finish();
  }
  updateHashCode(t2) {
    t2.update(this.actionType);
  }
  equals(t2) {
    return this === t2;
  }
}
class mt extends St {
  constructor() {
    super(6);
  }
  execute(t2) {
    t2.skip();
  }
  toString() {
    return "skip";
  }
}
mt.INSTANCE = new mt();
class Et extends St {
  constructor(t2) {
    super(0), this.channel = t2;
  }
  execute(t2) {
    t2._channel = this.channel;
  }
  updateHashCode(t2) {
    t2.update(this.actionType, this.channel);
  }
  equals(t2) {
    return this === t2 || t2 instanceof Et && this.channel === t2.channel;
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
}
class _t extends St {
  constructor(t2, e2) {
    super(1), this.ruleIndex = t2, this.actionIndex = e2, this.isPositionDependent = true;
  }
  execute(t2) {
    t2.action(null, this.ruleIndex, this.actionIndex);
  }
  updateHashCode(t2) {
    t2.update(this.actionType, this.ruleIndex, this.actionIndex);
  }
  equals(t2) {
    return this === t2 || t2 instanceof _t && this.ruleIndex === t2.ruleIndex && this.actionIndex === t2.actionIndex;
  }
}
class Ct extends St {
  constructor() {
    super(3);
  }
  execute(t2) {
    t2.more();
  }
  toString() {
    return "more";
  }
}
Ct.INSTANCE = new Ct();
class At extends St {
  constructor(t2) {
    super(7), this.type = t2;
  }
  execute(t2) {
    t2.type = this.type;
  }
  updateHashCode(t2) {
    t2.update(this.actionType, this.type);
  }
  equals(t2) {
    return this === t2 || t2 instanceof At && this.type === t2.type;
  }
  toString() {
    return "type(" + this.type + ")";
  }
}
class Nt extends St {
  constructor(t2) {
    super(5), this.mode = t2;
  }
  execute(t2) {
    t2.pushMode(this.mode);
  }
  updateHashCode(t2) {
    t2.update(this.actionType, this.mode);
  }
  equals(t2) {
    return this === t2 || t2 instanceof Nt && this.mode === t2.mode;
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
}
class kt extends St {
  constructor() {
    super(4);
  }
  execute(t2) {
    t2.popMode();
  }
  toString() {
    return "popMode";
  }
}
kt.INSTANCE = new kt();
class It extends St {
  constructor(t2) {
    super(2), this.mode = t2;
  }
  execute(t2) {
    t2.setMode(this.mode);
  }
  updateHashCode(t2) {
    t2.update(this.actionType, this.mode);
  }
  equals(t2) {
    return this === t2 || t2 instanceof It && this.mode === t2.mode;
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
}
function yt(t2, e2) {
  const n2 = [];
  return n2[t2 - 1] = e2, n2.map((function(t3) {
    return e2;
  }));
}
class Lt {
  constructor(t2) {
    null == t2 && (t2 = Tt.defaultOptions), this.deserializationOptions = t2, this.stateFactories = null, this.actionFactories = null;
  }
  deserialize(t2) {
    const e2 = this.reset(t2);
    this.checkVersion(e2), e2 && this.skipUUID();
    const n2 = this.readATN();
    this.readStates(n2, e2), this.readRules(n2, e2), this.readModes(n2);
    const s2 = [];
    return this.readSets(n2, s2, this.readInt.bind(this)), e2 && this.readSets(n2, s2, this.readInt32.bind(this)), this.readEdges(n2, s2), this.readDecisions(n2), this.readLexerActions(n2, e2), this.markPrecedenceDecisions(n2), this.verifyATN(n2), this.deserializationOptions.generateRuleBypassTransitions && 1 === n2.grammarType && (this.generateRuleBypassTransitions(n2), this.verifyATN(n2)), n2;
  }
  reset(t2) {
    if (3 === (t2.charCodeAt ? t2.charCodeAt(0) : t2[0])) {
      const e2 = function(t3) {
        const e3 = t3.charCodeAt(0);
        return e3 > 1 ? e3 - 2 : e3 + 65534;
      }, n2 = t2.split("").map(e2);
      return n2[0] = t2.charCodeAt(0), this.data = n2, this.pos = 0, true;
    }
    return this.data = t2, this.pos = 0, false;
  }
  skipUUID() {
    let t2 = 0;
    for (; t2++ < 8; ) this.readInt();
  }
  checkVersion(t2) {
    const e2 = this.readInt();
    if (!t2 && 4 !== e2) throw "Could not deserialize ATN with version " + e2 + " (expected 4).";
  }
  readATN() {
    const t2 = this.readInt(), e2 = this.readInt();
    return new $(t2, e2);
  }
  readStates(t2, e2) {
    let n2, s2, i2;
    const r2 = [], o2 = [], a2 = this.readInt();
    for (let n3 = 0; n3 < a2; n3++) {
      const n4 = this.readInt();
      if (n4 === C.INVALID_TYPE) {
        t2.addState(null);
        continue;
      }
      let s3 = this.readInt();
      e2 && 65535 === s3 && (s3 = -1);
      const i3 = this.stateFactory(n4, s3);
      if (n4 === C.LOOP_END) {
        const t3 = this.readInt();
        r2.push([i3, t3]);
      } else if (i3 instanceof Z) {
        const t3 = this.readInt();
        o2.push([i3, t3]);
      }
      t2.addState(i3);
    }
    for (n2 = 0; n2 < r2.length; n2++) s2 = r2[n2], s2[0].loopBackState = t2.states[s2[1]];
    for (n2 = 0; n2 < o2.length; n2++) s2 = o2[n2], s2[0].endState = t2.states[s2[1]];
    let l2 = this.readInt();
    for (n2 = 0; n2 < l2; n2++) i2 = this.readInt(), t2.states[i2].nonGreedy = true;
    let h2 = this.readInt();
    for (n2 = 0; n2 < h2; n2++) i2 = this.readInt(), t2.states[i2].isPrecedenceRule = true;
  }
  readRules(t2, e2) {
    let n2;
    const s2 = this.readInt();
    for (0 === t2.grammarType && (t2.ruleToTokenType = yt(s2, 0)), t2.ruleToStartState = yt(s2, 0), n2 = 0; n2 < s2; n2++) {
      const s3 = this.readInt();
      if (t2.ruleToStartState[n2] = t2.states[s3], 0 === t2.grammarType) {
        let s4 = this.readInt();
        e2 && 65535 === s4 && (s4 = i.EOF), t2.ruleToTokenType[n2] = s4;
      }
    }
    for (t2.ruleToStopState = yt(s2, 0), n2 = 0; n2 < t2.states.length; n2++) {
      const e3 = t2.states[n2];
      e3 instanceof A && (t2.ruleToStopState[e3.ruleIndex] = e3, t2.ruleToStartState[e3.ruleIndex].stopState = e3);
    }
  }
  readModes(t2) {
    const e2 = this.readInt();
    for (let n2 = 0; n2 < e2; n2++) {
      let e3 = this.readInt();
      t2.modeToStartState.push(t2.states[e3]);
    }
  }
  readSets(t2, e2, n2) {
    const s2 = this.readInt();
    for (let t3 = 0; t3 < s2; t3++) {
      const t4 = new _();
      e2.push(t4);
      const s3 = this.readInt();
      0 !== this.readInt() && t4.addOne(-1);
      for (let e3 = 0; e3 < s3; e3++) {
        const e4 = n2(), s4 = n2();
        t4.addRange(e4, s4);
      }
    }
  }
  readEdges(t2, e2) {
    let n2, s2, i2, r2, o2;
    const a2 = this.readInt();
    for (n2 = 0; n2 < a2; n2++) {
      const n3 = this.readInt(), s3 = this.readInt(), i3 = this.readInt(), o3 = this.readInt(), a3 = this.readInt(), l2 = this.readInt();
      r2 = this.edgeFactory(t2, i3, n3, s3, o3, a3, l2, e2), t2.states[n3].addTransition(r2);
    }
    for (n2 = 0; n2 < t2.states.length; n2++) for (i2 = t2.states[n2], s2 = 0; s2 < i2.transitions.length; s2++) {
      const e3 = i2.transitions[s2];
      if (!(e3 instanceof k)) continue;
      let n3 = -1;
      t2.ruleToStartState[e3.target.ruleIndex].isPrecedenceRule && 0 === e3.precedence && (n3 = e3.target.ruleIndex), r2 = new dt(e3.followState, n3), t2.ruleToStopState[e3.target.ruleIndex].addTransition(r2);
    }
    for (n2 = 0; n2 < t2.states.length; n2++) {
      if (i2 = t2.states[n2], i2 instanceof Z) {
        if (null === i2.endState) throw "IllegalState";
        if (null !== i2.endState.startState) throw "IllegalState";
        i2.endState.startState = i2;
      }
      if (i2 instanceof st) for (s2 = 0; s2 < i2.transitions.length; s2++) o2 = i2.transitions[s2].target, o2 instanceof ot && (o2.loopBackState = i2);
      else if (i2 instanceof it) for (s2 = 0; s2 < i2.transitions.length; s2++) o2 = i2.transitions[s2].target, o2 instanceof rt && (o2.loopBackState = i2);
    }
  }
  readDecisions(t2) {
    const e2 = this.readInt();
    for (let n2 = 0; n2 < e2; n2++) {
      const e3 = this.readInt(), s2 = t2.states[e3];
      t2.decisionToState.push(s2), s2.decision = n2;
    }
  }
  readLexerActions(t2, e2) {
    if (0 === t2.grammarType) {
      const n2 = this.readInt();
      t2.lexerActions = yt(n2, null);
      for (let s2 = 0; s2 < n2; s2++) {
        const n3 = this.readInt();
        let i2 = this.readInt();
        e2 && 65535 === i2 && (i2 = -1);
        let r2 = this.readInt();
        e2 && 65535 === r2 && (r2 = -1), t2.lexerActions[s2] = this.lexerActionFactory(n3, i2, r2);
      }
    }
  }
  generateRuleBypassTransitions(t2) {
    let e2;
    const n2 = t2.ruleToStartState.length;
    for (e2 = 0; e2 < n2; e2++) t2.ruleToTokenType[e2] = t2.maxTokenType + e2 + 1;
    for (e2 = 0; e2 < n2; e2++) this.generateRuleBypassTransition(t2, e2);
  }
  generateRuleBypassTransition(t2, e2) {
    let n2, s2;
    const i2 = new lt();
    i2.ruleIndex = e2, t2.addState(i2);
    const r2 = new Q();
    r2.ruleIndex = e2, t2.addState(r2), i2.endState = r2, t2.defineDecisionState(i2), r2.startState = i2;
    let o2 = null, a2 = null;
    if (t2.ruleToStartState[e2].isPrecedenceRule) {
      for (a2 = null, n2 = 0; n2 < t2.states.length; n2++) if (s2 = t2.states[n2], this.stateIsEndStateFor(s2, e2)) {
        a2 = s2, o2 = s2.loopBackState.transitions[0];
        break;
      }
      if (null === o2) throw "Couldn't identify final state of the precedence rule prefix section.";
    } else a2 = t2.ruleToStopState[e2];
    for (n2 = 0; n2 < t2.states.length; n2++) {
      s2 = t2.states[n2];
      for (let t3 = 0; t3 < s2.transitions.length; t3++) {
        const e3 = s2.transitions[t3];
        e3 !== o2 && e3.target === a2 && (e3.target = r2);
      }
    }
    const l2 = t2.ruleToStartState[e2], h2 = l2.transitions.length;
    for (; h2 > 0; ) i2.addTransition(l2.transitions[h2 - 1]), l2.transitions = l2.transitions.slice(-1);
    t2.ruleToStartState[e2].addTransition(new dt(i2)), r2.addTransition(new dt(a2));
    const c2 = new X();
    t2.addState(c2), c2.addTransition(new ht(r2, t2.ruleToTokenType[e2])), i2.addTransition(new dt(c2));
  }
  stateIsEndStateFor(t2, e2) {
    if (t2.ruleIndex !== e2) return null;
    if (!(t2 instanceof rt)) return null;
    const n2 = t2.transitions[t2.transitions.length - 1].target;
    return n2 instanceof tt && n2.epsilonOnlyTransitions && n2.transitions[0].target instanceof A ? t2 : null;
  }
  markPrecedenceDecisions(t2) {
    for (let e2 = 0; e2 < t2.states.length; e2++) {
      const n2 = t2.states[e2];
      if (n2 instanceof rt && t2.ruleToStartState[n2.ruleIndex].isPrecedenceRule) {
        const t3 = n2.transitions[n2.transitions.length - 1].target;
        t3 instanceof tt && t3.epsilonOnlyTransitions && t3.transitions[0].target instanceof A && (n2.isPrecedenceDecision = true);
      }
    }
  }
  verifyATN(t2) {
    if (this.deserializationOptions.verifyATN) for (let e2 = 0; e2 < t2.states.length; e2++) {
      const n2 = t2.states[e2];
      if (null !== n2) if (this.checkCondition(n2.epsilonOnlyTransitions || n2.transitions.length <= 1), n2 instanceof ot) this.checkCondition(null !== n2.loopBackState);
      else if (n2 instanceof rt) if (this.checkCondition(null !== n2.loopBackState), this.checkCondition(2 === n2.transitions.length), n2.transitions[0].target instanceof at) this.checkCondition(n2.transitions[1].target instanceof tt), this.checkCondition(!n2.nonGreedy);
      else {
        if (!(n2.transitions[0].target instanceof tt)) throw "IllegalState";
        this.checkCondition(n2.transitions[1].target instanceof at), this.checkCondition(n2.nonGreedy);
      }
      else n2 instanceof it ? (this.checkCondition(1 === n2.transitions.length), this.checkCondition(n2.transitions[0].target instanceof rt)) : n2 instanceof tt ? this.checkCondition(null !== n2.loopBackState) : n2 instanceof et ? this.checkCondition(null !== n2.stopState) : n2 instanceof Z ? this.checkCondition(null !== n2.endState) : n2 instanceof Q ? this.checkCondition(null !== n2.startState) : n2 instanceof J ? this.checkCondition(n2.transitions.length <= 1 || n2.decision >= 0) : this.checkCondition(n2.transitions.length <= 1 || n2 instanceof A);
    }
  }
  checkCondition(t2, e2) {
    if (!t2) throw null == e2 && (e2 = "IllegalState"), e2;
  }
  readInt() {
    return this.data[this.pos++];
  }
  readInt32() {
    return this.readInt() | this.readInt() << 16;
  }
  edgeFactory(t2, e2, n2, s2, r2, o2, a2, l2) {
    const h2 = t2.states[s2];
    switch (e2) {
      case N.EPSILON:
        return new dt(h2);
      case N.RANGE:
        return new ct(h2, 0 !== a2 ? i.EOF : r2, o2);
      case N.RULE:
        return new k(t2.states[r2], o2, a2, h2);
      case N.PREDICATE:
        return new pt(h2, r2, o2, 0 !== a2);
      case N.PRECEDENCE:
        return new xt(h2, r2);
      case N.ATOM:
        return new ht(h2, 0 !== a2 ? i.EOF : r2);
      case N.ACTION:
        return new ut(h2, r2, o2, 0 !== a2);
      case N.SET:
        return new I(h2, l2[r2]);
      case N.NOT_SET:
        return new y(h2, l2[r2]);
      case N.WILDCARD:
        return new L(h2);
      default:
        throw "The specified transition type: " + e2 + " is not valid.";
    }
  }
  stateFactory(t2, e2) {
    if (null === this.stateFactories) {
      const t3 = [];
      t3[C.INVALID_TYPE] = null, t3[C.BASIC] = () => new X(), t3[C.RULE_START] = () => new et(), t3[C.BLOCK_START] = () => new lt(), t3[C.PLUS_BLOCK_START] = () => new ot(), t3[C.STAR_BLOCK_START] = () => new at(), t3[C.TOKEN_START] = () => new nt(), t3[C.RULE_STOP] = () => new A(), t3[C.BLOCK_END] = () => new Q(), t3[C.STAR_LOOP_BACK] = () => new it(), t3[C.STAR_LOOP_ENTRY] = () => new rt(), t3[C.PLUS_LOOP_BACK] = () => new st(), t3[C.LOOP_END] = () => new tt(), this.stateFactories = t3;
    }
    if (t2 > this.stateFactories.length || null === this.stateFactories[t2]) throw "The specified state type " + t2 + " is not valid.";
    {
      const n2 = this.stateFactories[t2]();
      if (null !== n2) return n2.ruleIndex = e2, n2;
    }
  }
  lexerActionFactory(t2, e2, n2) {
    if (null === this.actionFactories) {
      const t3 = [];
      t3[0] = (t4, e3) => new Et(t4), t3[1] = (t4, e3) => new _t(t4, e3), t3[2] = (t4, e3) => new It(t4), t3[3] = (t4, e3) => Ct.INSTANCE, t3[4] = (t4, e3) => kt.INSTANCE, t3[5] = (t4, e3) => new Nt(t4), t3[6] = (t4, e3) => mt.INSTANCE, t3[7] = (t4, e3) => new At(t4), this.actionFactories = t3;
    }
    if (t2 > this.actionFactories.length || null === this.actionFactories[t2]) throw "The specified lexer action type " + t2 + " is not valid.";
    return this.actionFactories[t2](e2, n2);
  }
}
class Ot {
  syntaxError(t2, e2, n2, s2, i2, r2) {
  }
  reportAmbiguity(t2, e2, n2, s2, i2, r2, o2) {
  }
  reportAttemptingFullContext(t2, e2, n2, s2, i2, r2) {
  }
  reportContextSensitivity(t2, e2, n2, s2, i2, r2) {
  }
}
class Rt extends Ot {
  constructor() {
    super();
  }
  syntaxError(t2, e2, n2, s2, i2, r2) {
    console.error("line " + n2 + ":" + s2 + " " + i2);
  }
}
Rt.INSTANCE = new Rt();
class wt extends Ot {
  constructor(t2) {
    if (super(), null === t2) throw "delegates";
    return this.delegates = t2, this;
  }
  syntaxError(t2, e2, n2, s2, i2, r2) {
    this.delegates.map(((o2) => o2.syntaxError(t2, e2, n2, s2, i2, r2)));
  }
  reportAmbiguity(t2, e2, n2, s2, i2, r2, o2) {
    this.delegates.map(((a2) => a2.reportAmbiguity(t2, e2, n2, s2, i2, r2, o2)));
  }
  reportAttemptingFullContext(t2, e2, n2, s2, i2, r2) {
    this.delegates.map(((o2) => o2.reportAttemptingFullContext(t2, e2, n2, s2, i2, r2)));
  }
  reportContextSensitivity(t2, e2, n2, s2, i2, r2) {
    this.delegates.map(((o2) => o2.reportContextSensitivity(t2, e2, n2, s2, i2, r2)));
  }
}
class vt {
  constructor() {
    this._listeners = [Rt.INSTANCE], this._interp = null, this._stateNumber = -1;
  }
  checkVersion(t2) {
    const e2 = "4.13.2";
    e2 !== t2 && console.log("ANTLR runtime and generated code versions disagree: " + e2 + "!=" + t2);
  }
  addErrorListener(t2) {
    this._listeners.push(t2);
  }
  removeErrorListeners() {
    this._listeners = [];
  }
  getLiteralNames() {
    return Object.getPrototypeOf(this).constructor.literalNames || [];
  }
  getSymbolicNames() {
    return Object.getPrototypeOf(this).constructor.symbolicNames || [];
  }
  getTokenNames() {
    if (!this.tokenNames) {
      const t2 = this.getLiteralNames(), e2 = this.getSymbolicNames(), n2 = t2.length > e2.length ? t2.length : e2.length;
      this.tokenNames = [];
      for (let s2 = 0; s2 < n2; s2++) this.tokenNames[s2] = t2[s2] || e2[s2] || "<INVALID";
    }
    return this.tokenNames;
  }
  getTokenTypeMap() {
    const t2 = this.getTokenNames();
    if (null === t2) throw "The current recognizer does not provide a list of token names.";
    let e2 = this.tokenTypeMapCache[t2];
    return void 0 === e2 && (e2 = t2.reduce((function(t3, e3, n2) {
      t3[e3] = n2;
    })), e2.EOF = i.EOF, this.tokenTypeMapCache[t2] = e2), e2;
  }
  getRuleIndexMap() {
    const t2 = this.ruleNames;
    if (null === t2) throw "The current recognizer does not provide a list of rule names.";
    let e2 = this.ruleIndexMapCache[t2];
    return void 0 === e2 && (e2 = t2.reduce((function(t3, e3, n2) {
      t3[e3] = n2;
    })), this.ruleIndexMapCache[t2] = e2), e2;
  }
  getTokenType(t2) {
    const e2 = this.getTokenTypeMap()[t2];
    return void 0 !== e2 ? e2 : i.INVALID_TYPE;
  }
  getErrorHeader(t2) {
    return "line " + t2.getOffendingToken().line + ":" + t2.getOffendingToken().column;
  }
  getTokenErrorDisplay(t2) {
    if (null === t2) return "<no token>";
    let e2 = t2.text;
    return null === e2 && (e2 = t2.type === i.EOF ? "<EOF>" : "<" + t2.type + ">"), e2 = e2.replace("\n", "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + e2 + "'";
  }
  getErrorListenerDispatch() {
    return console.warn("Calling deprecated method in Recognizer class: getErrorListenerDispatch()"), this.getErrorListener();
  }
  getErrorListener() {
    return new wt(this._listeners);
  }
  sempred(t2, e2, n2) {
    return true;
  }
  precpred(t2, e2) {
    return true;
  }
  get atn() {
    return this._interp.atn;
  }
  get state() {
    return this._stateNumber;
  }
  set state(t2) {
    this._stateNumber = t2;
  }
}
vt.tokenTypeMapCache = {}, vt.ruleIndexMapCache = {};
class Pt extends i {
  constructor(t2, e2, n2, s2, r2) {
    super(), this.source = void 0 !== t2 ? t2 : Pt.EMPTY_SOURCE, this.type = void 0 !== e2 ? e2 : null, this.channel = void 0 !== n2 ? n2 : i.DEFAULT_CHANNEL, this.start = void 0 !== s2 ? s2 : -1, this.stop = void 0 !== r2 ? r2 : -1, this.tokenIndex = -1, null !== this.source[0] ? (this.line = t2[0].line, this.column = t2[0].column) : this.column = -1;
  }
  clone() {
    const t2 = new Pt(this.source, this.type, this.channel, this.start, this.stop);
    return t2.tokenIndex = this.tokenIndex, t2.line = this.line, t2.column = this.column, t2.text = this.text, t2;
  }
  cloneWithType(t2) {
    const e2 = new Pt(this.source, t2, this.channel, this.start, this.stop);
    return e2.tokenIndex = this.tokenIndex, e2.line = this.line, e2.column = this.column, t2 === i.EOF && (e2.text = ""), e2;
  }
  toString() {
    let t2 = this.text;
    return t2 = null !== t2 ? t2.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t") : "<no text>", "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + t2 + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (null !== this._text) return this._text;
    const t2 = this.getInputStream();
    if (null === t2) return null;
    const e2 = t2.size;
    return this.start < e2 && this.stop < e2 ? t2.getText(this.start, this.stop) : "<EOF>";
  }
  set text(t2) {
    this._text = t2;
  }
}
Pt.EMPTY_SOURCE = [null, null];
class bt {
}
class Dt extends bt {
  constructor(t2) {
    super(), this.copyText = void 0 !== t2 && t2;
  }
  create(t2, e2, n2, s2, i2, r2, o2, a2) {
    const l2 = new Pt(t2, e2, s2, i2, r2);
    return l2.line = o2, l2.column = a2, null !== n2 ? l2.text = n2 : this.copyText && null !== t2[1] && (l2.text = t2[1].getText(i2, r2)), l2;
  }
  createThin(t2, e2) {
    const n2 = new Pt(null, t2);
    return n2.text = e2, n2;
  }
}
Dt.DEFAULT = new Dt();
class Ft extends Error {
  constructor(t2) {
    super(t2.message), Error.captureStackTrace && Error.captureStackTrace(this, Ft), this.message = t2.message, this.recognizer = t2.recognizer, this.input = t2.input, this.ctx = t2.ctx, this.offendingToken = null, this.offendingState = -1, null !== this.recognizer && (this.offendingState = this.recognizer.state);
  }
  getExpectedTokens() {
    return null !== this.recognizer ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
  }
  toString() {
    return this.message;
  }
}
class Mt extends Ft {
  constructor(t2, e2, n2, s2) {
    super({ message: "", recognizer: t2, input: e2, ctx: null }), this.startIndex = n2, this.deadEndConfigs = s2;
  }
  toString() {
    let t2 = "";
    return this.startIndex >= 0 && this.startIndex < this.input.size && (t2 = this.input.getText(new E(this.startIndex, this.startIndex))), "LexerNoViableAltException" + t2;
  }
}
class Ut extends vt {
  constructor(t2) {
    super(), this._input = t2, this._factory = Dt.DEFAULT, this._tokenFactorySourcePair = [this, t2], this._interp = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = false, this._channel = i.DEFAULT_CHANNEL, this._type = i.INVALID_TYPE, this._modeStack = [], this._mode = Ut.DEFAULT_MODE, this._text = null;
  }
  reset() {
    null !== this._input && this._input.seek(0), this._token = null, this._type = i.INVALID_TYPE, this._channel = i.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = false, this._mode = Ut.DEFAULT_MODE, this._modeStack = [], this._interp.reset();
  }
  nextToken() {
    if (null === this._input) throw "nextToken requires a non-null input stream.";
    const t2 = this._input.mark();
    try {
      for (; ; ) {
        if (this._hitEOF) return this.emitEOF(), this._token;
        this._token = null, this._channel = i.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this._interp.column, this._tokenStartLine = this._interp.line, this._text = null;
        let t3 = false;
        for (; ; ) {
          this._type = i.INVALID_TYPE;
          let e2 = Ut.SKIP;
          try {
            e2 = this._interp.match(this._input, this._mode);
          } catch (t4) {
            if (!(t4 instanceof Ft)) throw console.log(t4.stack), t4;
            this.notifyListeners(t4), this.recover(t4);
          }
          if (this._input.LA(1) === i.EOF && (this._hitEOF = true), this._type === i.INVALID_TYPE && (this._type = e2), this._type === Ut.SKIP) {
            t3 = true;
            break;
          }
          if (this._type !== Ut.MORE) break;
        }
        if (!t3) return null === this._token && this.emit(), this._token;
      }
    } finally {
      this._input.release(t2);
    }
  }
  skip() {
    this._type = Ut.SKIP;
  }
  more() {
    this._type = Ut.MORE;
  }
  mode(t2) {
    console.warn("Calling deprecated method in Lexer class: mode(...)"), this.setMode(t2);
  }
  setMode(t2) {
    this._mode = t2;
  }
  getMode() {
    return this._mode;
  }
  getModeStack() {
    return this._modeStack;
  }
  pushMode(t2) {
    this._interp.debug && console.log("pushMode " + t2), this._modeStack.push(this._mode), this.setMode(t2);
  }
  popMode() {
    if (0 === this._modeStack.length) throw "Empty Stack";
    return this._interp.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.setMode(this._modeStack.pop()), this._mode;
  }
  emitToken(t2) {
    this._token = t2;
  }
  emit() {
    const t2 = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
    return this.emitToken(t2), t2;
  }
  emitEOF() {
    const t2 = this.column, e2 = this.line, n2 = this._factory.create(this._tokenFactorySourcePair, i.EOF, null, i.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, e2, t2);
    return this.emitToken(n2), n2;
  }
  getCharIndex() {
    return this._input.index;
  }
  getAllTokens() {
    const t2 = [];
    let e2 = this.nextToken();
    for (; e2.type !== i.EOF; ) t2.push(e2), e2 = this.nextToken();
    return t2;
  }
  notifyListeners(t2) {
    const e2 = this._tokenStartCharIndex, n2 = this._input.index, s2 = this._input.getText(e2, n2), i2 = "token recognition error at: '" + this.getErrorDisplay(s2) + "'";
    this.getErrorListener().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, i2, t2);
  }
  getErrorDisplay(t2) {
    const e2 = [];
    for (let n2 = 0; n2 < t2.length; n2++) e2.push(t2[n2]);
    return e2.join("");
  }
  getErrorDisplayForChar(t2) {
    return t2.charCodeAt(0) === i.EOF ? "<EOF>" : "\n" === t2 ? "\\n" : "	" === t2 ? "\\t" : "\r" === t2 ? "\\r" : t2;
  }
  getCharErrorDisplay(t2) {
    return "'" + this.getErrorDisplayForChar(t2) + "'";
  }
  recover(t2) {
    this._input.LA(1) !== i.EOF && (t2 instanceof Mt ? this._interp.consume(this._input) : this._input.consume());
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(t2) {
    this._input = null, this._tokenFactorySourcePair = [this, this._input], this.reset(), this._input = t2, this._tokenFactorySourcePair = [this, this._input];
  }
  get sourceName() {
    return this._input.sourceName;
  }
  get type() {
    return this._type;
  }
  set type(t2) {
    this._type = t2;
  }
  get line() {
    return this._interp.line;
  }
  set line(t2) {
    this._interp.line = t2;
  }
  get column() {
    return this._interp.column;
  }
  set column(t2) {
    this._interp.column = t2;
  }
  get text() {
    return null !== this._text ? this._text : this._interp.getText(this._input);
  }
  set text(t2) {
    this._text = t2;
  }
}
function Bt(t2) {
  return t2.hashCodeForConfigSet();
}
function zt(t2, e2) {
  return t2 === e2 || null !== t2 && null !== e2 && t2.equalsForConfigSet(e2);
}
Ut.DEFAULT_MODE = 0, Ut.MORE = -2, Ut.SKIP = -3, Ut.DEFAULT_TOKEN_CHANNEL = i.DEFAULT_CHANNEL, Ut.HIDDEN = i.HIDDEN_CHANNEL, Ut.MIN_CHAR_VALUE = 0, Ut.MAX_CHAR_VALUE = 1114111;
class Vt {
  constructor(t2) {
    this.configLookup = new g(Bt, zt), this.fullCtx = void 0 === t2 || t2, this.readOnly = false, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = false, this.dipsIntoOuterContext = false, this.cachedHashCode = -1;
  }
  add(t2, e2) {
    if (void 0 === e2 && (e2 = null), this.readOnly) throw "This set is readonly";
    t2.semanticContext !== p.NONE && (this.hasSemanticContext = true), t2.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = true);
    const n2 = this.configLookup.getOrAdd(t2);
    if (n2 === t2) return this.cachedHashCode = -1, this.configs.push(t2), true;
    const s2 = !this.fullCtx, i2 = G(n2.context, t2.context, s2, e2);
    return n2.reachesIntoOuterContext = Math.max(n2.reachesIntoOuterContext, t2.reachesIntoOuterContext), t2.precedenceFilterSuppressed && (n2.precedenceFilterSuppressed = true), n2.context = i2, true;
  }
  getStates() {
    const t2 = new g();
    for (let e2 = 0; e2 < this.configs.length; e2++) t2.add(this.configs[e2].state);
    return t2;
  }
  getPredicates() {
    const t2 = [];
    for (let e2 = 0; e2 < this.configs.length; e2++) {
      const n2 = this.configs[e2].semanticContext;
      n2 !== p.NONE && t2.push(n2.semanticContext);
    }
    return t2;
  }
  optimizeConfigs(t2) {
    if (this.readOnly) throw "This set is readonly";
    if (0 !== this.configLookup.length) for (let e2 = 0; e2 < this.configs.length; e2++) {
      const n2 = this.configs[e2];
      n2.context = t2.getCachedContext(n2.context);
    }
  }
  addAll(t2) {
    for (let e2 = 0; e2 < t2.length; e2++) this.add(t2[e2]);
    return false;
  }
  equals(t2) {
    return this === t2 || t2 instanceof Vt && r(this.configs, t2.configs) && this.fullCtx === t2.fullCtx && this.uniqueAlt === t2.uniqueAlt && this.conflictingAlts === t2.conflictingAlts && this.hasSemanticContext === t2.hasSemanticContext && this.dipsIntoOuterContext === t2.dipsIntoOuterContext;
  }
  hashCode() {
    const t2 = new l();
    return t2.update(this.configs), t2.finish();
  }
  updateHashCode(t2) {
    this.readOnly ? (-1 === this.cachedHashCode && (this.cachedHashCode = this.hashCode()), t2.update(this.cachedHashCode)) : t2.update(this.hashCode());
  }
  isEmpty() {
    return 0 === this.configs.length;
  }
  contains(t2) {
    if (null === this.configLookup) throw "This method is not implemented for readonly sets.";
    return this.configLookup.contains(t2);
  }
  containsFast(t2) {
    if (null === this.configLookup) throw "This method is not implemented for readonly sets.";
    return this.configLookup.containsFast(t2);
  }
  clear() {
    if (this.readOnly) throw "This set is readonly";
    this.configs = [], this.cachedHashCode = -1, this.configLookup = new g();
  }
  setReadonly(t2) {
    this.readOnly = t2, t2 && (this.configLookup = null);
  }
  toString() {
    return d(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== $.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (null !== this.conflictingAlts ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  get items() {
    return this.configs;
  }
  get length() {
    return this.configs.length;
  }
}
class qt {
  constructor(t2, e2) {
    return null === t2 && (t2 = -1), null === e2 && (e2 = new Vt()), this.stateNumber = t2, this.configs = e2, this.edges = null, this.isAcceptState = false, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = false, this.predicates = null, this;
  }
  getAltSet() {
    const t2 = new g();
    if (null !== this.configs) for (let e2 = 0; e2 < this.configs.length; e2++) {
      const n2 = this.configs[e2];
      t2.add(n2.alt);
    }
    return 0 === t2.length ? null : t2;
  }
  equals(t2) {
    return this === t2 || t2 instanceof qt && this.configs.equals(t2.configs);
  }
  toString() {
    let t2 = this.stateNumber + ":" + this.configs;
    return this.isAcceptState && (t2 += "=>", null !== this.predicates ? t2 += this.predicates : t2 += this.prediction), t2;
  }
  hashCode() {
    const t2 = new l();
    return t2.update(this.configs), t2.finish();
  }
}
class Ht {
  constructor(t2, e2) {
    return this.atn = t2, this.sharedContextCache = e2, this;
  }
  getCachedContext(t2) {
    if (null === this.sharedContextCache) return t2;
    const e2 = new H();
    return Y(t2, this.sharedContextCache, e2);
  }
}
Ht.ERROR = new qt(2147483647, new Vt());
class Kt extends Vt {
  constructor() {
    super(), this.configLookup = new g();
  }
}
class Yt extends m {
  constructor(t2, e2) {
    super(t2, e2);
    const n2 = t2.lexerActionExecutor || null;
    return this.lexerActionExecutor = n2 || (null !== e2 ? e2.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = null !== e2 && this.checkNonGreedyDecision(e2, this.state), this.hashCodeForConfigSet = Yt.prototype.hashCode, this.equalsForConfigSet = Yt.prototype.equals, this;
  }
  updateHashCode(t2) {
    t2.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }
  equals(t2) {
    return this === t2 || t2 instanceof Yt && this.passedThroughNonGreedyDecision === t2.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(t2.lexerActionExecutor) : !t2.lexerActionExecutor) && super.equals(t2);
  }
  checkNonGreedyDecision(t2, e2) {
    return t2.passedThroughNonGreedyDecision || e2 instanceof J && e2.nonGreedy;
  }
}
class Gt extends St {
  constructor(t2, e2) {
    super(e2.actionType), this.offset = t2, this.action = e2, this.isPositionDependent = true;
  }
  execute(t2) {
    this.action.execute(t2);
  }
  updateHashCode(t2) {
    t2.update(this.actionType, this.offset, this.action);
  }
  equals(t2) {
    return this === t2 || t2 instanceof Gt && this.offset === t2.offset && this.action === t2.action;
  }
}
class Wt {
  constructor(t2) {
    return this.lexerActions = null === t2 ? [] : t2, this.cachedHashCode = l.hashStuff(t2), this;
  }
  fixOffsetBeforeMatch(t2) {
    let e2 = null;
    for (let n2 = 0; n2 < this.lexerActions.length; n2++) !this.lexerActions[n2].isPositionDependent || this.lexerActions[n2] instanceof Gt || (null === e2 && (e2 = this.lexerActions.concat([])), e2[n2] = new Gt(t2, this.lexerActions[n2]));
    return null === e2 ? this : new Wt(e2);
  }
  execute(t2, e2, n2) {
    let s2 = false;
    const i2 = e2.index;
    try {
      for (let r2 = 0; r2 < this.lexerActions.length; r2++) {
        let o2 = this.lexerActions[r2];
        if (o2 instanceof Gt) {
          const t3 = o2.offset;
          e2.seek(n2 + t3), o2 = o2.action, s2 = n2 + t3 !== i2;
        } else o2.isPositionDependent && (e2.seek(i2), s2 = false);
        o2.execute(t2);
      }
    } finally {
      s2 && e2.seek(i2);
    }
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t2) {
    t2.update(this.cachedHashCode);
  }
  equals(t2) {
    if (this === t2) return true;
    if (t2 instanceof Wt) {
      if (this.cachedHashCode != t2.cachedHashCode) return false;
      if (this.lexerActions.length != t2.lexerActions.length) return false;
      {
        const e2 = this.lexerActions.length;
        for (let n2 = 0; n2 < e2; ++n2) if (!this.lexerActions[n2].equals(t2.lexerActions[n2])) return false;
        return true;
      }
    }
    return false;
  }
  static append(t2, e2) {
    if (null === t2) return new Wt([e2]);
    const n2 = t2.lexerActions.concat([e2]);
    return new Wt(n2);
  }
}
function jt(t2) {
  t2.index = -1, t2.line = 0, t2.column = -1, t2.dfaState = null;
}
class $t {
  constructor() {
    jt(this);
  }
  reset() {
    jt(this);
  }
}
class Xt extends Ht {
  constructor(t2, e2, n2, s2) {
    super(e2, s2), this.decisionToDFA = n2, this.recog = t2, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Ut.DEFAULT_MODE, this.prevAccept = new $t();
  }
  copyState(t2) {
    this.column = t2.column, this.line = t2.line, this.mode = t2.mode, this.startIndex = t2.startIndex;
  }
  match(t2, e2) {
    this.mode = e2;
    const n2 = t2.mark();
    try {
      this.startIndex = t2.index, this.prevAccept.reset();
      const n3 = this.decisionToDFA[e2];
      return null === n3.s0 ? this.matchATN(t2) : this.execATN(t2, n3.s0);
    } finally {
      t2.release(n2);
    }
  }
  reset() {
    this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Ut.DEFAULT_MODE;
  }
  matchATN(t2) {
    const e2 = this.atn.modeToStartState[this.mode];
    Xt.debug && console.log("matchATN mode " + this.mode + " start: " + e2);
    const n2 = this.mode, s2 = this.computeStartState(t2, e2), i2 = s2.hasSemanticContext;
    s2.hasSemanticContext = false;
    const r2 = this.addDFAState(s2);
    i2 || (this.decisionToDFA[this.mode].s0 = r2);
    const o2 = this.execATN(t2, r2);
    return Xt.debug && console.log("DFA after matchATN: " + this.decisionToDFA[n2].toLexerString()), o2;
  }
  execATN(t2, e2) {
    Xt.debug && console.log("start state closure=" + e2.configs), e2.isAcceptState && this.captureSimState(this.prevAccept, t2, e2);
    let n2 = t2.LA(1), s2 = e2;
    for (; ; ) {
      Xt.debug && console.log("execATN loop starting closure: " + s2.configs);
      let e3 = this.getExistingTargetState(s2, n2);
      if (null === e3 && (e3 = this.computeTargetState(t2, s2, n2)), e3 === Ht.ERROR) break;
      if (n2 !== i.EOF && this.consume(t2), e3.isAcceptState && (this.captureSimState(this.prevAccept, t2, e3), n2 === i.EOF)) break;
      n2 = t2.LA(1), s2 = e3;
    }
    return this.failOrAccept(this.prevAccept, t2, s2.configs, n2);
  }
  getExistingTargetState(t2, e2) {
    if (null === t2.edges || e2 < Xt.MIN_DFA_EDGE || e2 > Xt.MAX_DFA_EDGE) return null;
    let n2 = t2.edges[e2 - Xt.MIN_DFA_EDGE];
    return void 0 === n2 && (n2 = null), Xt.debug && null !== n2 && console.log("reuse state " + t2.stateNumber + " edge to " + n2.stateNumber), n2;
  }
  computeTargetState(t2, e2, n2) {
    const s2 = new Kt();
    return this.getReachableConfigSet(t2, e2.configs, s2, n2), 0 === s2.items.length ? (s2.hasSemanticContext || this.addDFAEdge(e2, n2, Ht.ERROR), Ht.ERROR) : this.addDFAEdge(e2, n2, null, s2);
  }
  failOrAccept(t2, e2, n2, s2) {
    if (null !== this.prevAccept.dfaState) {
      const n3 = t2.dfaState.lexerActionExecutor;
      return this.accept(e2, n3, this.startIndex, t2.index, t2.line, t2.column), t2.dfaState.prediction;
    }
    if (s2 === i.EOF && e2.index === this.startIndex) return i.EOF;
    throw new Mt(this.recog, e2, this.startIndex, n2);
  }
  getReachableConfigSet(t2, e2, n2, s2) {
    let r2 = $.INVALID_ALT_NUMBER;
    for (let o2 = 0; o2 < e2.items.length; o2++) {
      const a2 = e2.items[o2], l2 = a2.alt === r2;
      if (!l2 || !a2.passedThroughNonGreedyDecision) {
        Xt.debug && console.log("testing %s at %s\n", this.getTokenName(s2), a2.toString(this.recog, true));
        for (let e3 = 0; e3 < a2.state.transitions.length; e3++) {
          const o3 = a2.state.transitions[e3], h2 = this.getReachableTarget(o3, s2);
          if (null !== h2) {
            let e4 = a2.lexerActionExecutor;
            null !== e4 && (e4 = e4.fixOffsetBeforeMatch(t2.index - this.startIndex));
            const o4 = s2 === i.EOF, c2 = new Yt({ state: h2, lexerActionExecutor: e4 }, a2);
            this.closure(t2, c2, n2, l2, true, o4) && (r2 = a2.alt);
          }
        }
      }
    }
  }
  accept(t2, e2, n2, s2, i2, r2) {
    Xt.debug && console.log("ACTION %s\n", e2), t2.seek(s2), this.line = i2, this.column = r2, null !== e2 && null !== this.recog && e2.execute(this.recog, t2, n2);
  }
  getReachableTarget(t2, e2) {
    return t2.matches(e2, 0, Ut.MAX_CHAR_VALUE) ? t2.target : null;
  }
  computeStartState(t2, e2) {
    const n2 = B.EMPTY, s2 = new Kt();
    for (let i2 = 0; i2 < e2.transitions.length; i2++) {
      const r2 = e2.transitions[i2].target, o2 = new Yt({ state: r2, alt: i2 + 1, context: n2 }, null);
      this.closure(t2, o2, s2, false, false, false);
    }
    return s2;
  }
  closure(t2, e2, n2, s2, i2, r2) {
    let o2 = null;
    if (Xt.debug && console.log("closure(" + e2.toString(this.recog, true) + ")"), e2.state instanceof A) {
      if (Xt.debug && (null !== this.recog ? console.log("closure at %s rule stop %s\n", this.recog.ruleNames[e2.state.ruleIndex], e2) : console.log("closure at rule stop %s\n", e2)), null === e2.context || e2.context.hasEmptyPath()) {
        if (null === e2.context || e2.context.isEmpty()) return n2.add(e2), true;
        n2.add(new Yt({ state: e2.state, context: B.EMPTY }, e2)), s2 = true;
      }
      if (null !== e2.context && !e2.context.isEmpty()) {
        for (let a2 = 0; a2 < e2.context.length; a2++) if (e2.context.getReturnState(a2) !== B.EMPTY_RETURN_STATE) {
          const l2 = e2.context.getParent(a2), h2 = this.atn.states[e2.context.getReturnState(a2)];
          o2 = new Yt({ state: h2, context: l2 }, e2), s2 = this.closure(t2, o2, n2, s2, i2, r2);
        }
      }
      return s2;
    }
    e2.state.epsilonOnlyTransitions || s2 && e2.passedThroughNonGreedyDecision || n2.add(e2);
    for (let a2 = 0; a2 < e2.state.transitions.length; a2++) {
      const l2 = e2.state.transitions[a2];
      o2 = this.getEpsilonTarget(t2, e2, l2, n2, i2, r2), null !== o2 && (s2 = this.closure(t2, o2, n2, s2, i2, r2));
    }
    return s2;
  }
  getEpsilonTarget(t2, e2, n2, s2, r2, o2) {
    let a2 = null;
    if (n2.serializationType === N.RULE) {
      const t3 = V.create(e2.context, n2.followState.stateNumber);
      a2 = new Yt({ state: n2.target, context: t3 }, e2);
    } else {
      if (n2.serializationType === N.PRECEDENCE) throw "Precedence predicates are not supported in lexers.";
      if (n2.serializationType === N.PREDICATE) Xt.debug && console.log("EVAL rule " + n2.ruleIndex + ":" + n2.predIndex), s2.hasSemanticContext = true, this.evaluatePredicate(t2, n2.ruleIndex, n2.predIndex, r2) && (a2 = new Yt({ state: n2.target }, e2));
      else if (n2.serializationType === N.ACTION) if (null === e2.context || e2.context.hasEmptyPath()) {
        const t3 = Wt.append(e2.lexerActionExecutor, this.atn.lexerActions[n2.actionIndex]);
        a2 = new Yt({ state: n2.target, lexerActionExecutor: t3 }, e2);
      } else a2 = new Yt({ state: n2.target }, e2);
      else n2.serializationType === N.EPSILON ? a2 = new Yt({ state: n2.target }, e2) : n2.serializationType !== N.ATOM && n2.serializationType !== N.RANGE && n2.serializationType !== N.SET || o2 && n2.matches(i.EOF, 0, Ut.MAX_CHAR_VALUE) && (a2 = new Yt({ state: n2.target }, e2));
    }
    return a2;
  }
  evaluatePredicate(t2, e2, n2, s2) {
    if (null === this.recog) return true;
    if (!s2) return this.recog.sempred(null, e2, n2);
    const i2 = this.column, r2 = this.line, o2 = t2.index, a2 = t2.mark();
    try {
      return this.consume(t2), this.recog.sempred(null, e2, n2);
    } finally {
      this.column = i2, this.line = r2, t2.seek(o2), t2.release(a2);
    }
  }
  captureSimState(t2, e2, n2) {
    t2.index = e2.index, t2.line = this.line, t2.column = this.column, t2.dfaState = n2;
  }
  addDFAEdge(t2, e2, n2, s2) {
    if (void 0 === n2 && (n2 = null), void 0 === s2 && (s2 = null), null === n2 && null !== s2) {
      const t3 = s2.hasSemanticContext;
      if (s2.hasSemanticContext = false, n2 = this.addDFAState(s2), t3) return n2;
    }
    return e2 < Xt.MIN_DFA_EDGE || e2 > Xt.MAX_DFA_EDGE || (Xt.debug && console.log("EDGE " + t2 + " -> " + n2 + " upon " + e2), null === t2.edges && (t2.edges = []), t2.edges[e2 - Xt.MIN_DFA_EDGE] = n2), n2;
  }
  addDFAState(t2) {
    const e2 = new qt(null, t2);
    let n2 = null;
    for (let e3 = 0; e3 < t2.items.length; e3++) {
      const s3 = t2.items[e3];
      if (s3.state instanceof A) {
        n2 = s3;
        break;
      }
    }
    null !== n2 && (e2.isAcceptState = true, e2.lexerActionExecutor = n2.lexerActionExecutor, e2.prediction = this.atn.ruleToTokenType[n2.state.ruleIndex]);
    const s2 = this.decisionToDFA[this.mode], i2 = s2.states.get(e2);
    if (null !== i2) return i2;
    const r2 = e2;
    return r2.stateNumber = s2.states.length, t2.setReadonly(true), r2.configs = t2, s2.states.add(r2), r2;
  }
  getDFA(t2) {
    return this.decisionToDFA[t2];
  }
  getText(t2) {
    return t2.getText(this.startIndex, t2.index - 1);
  }
  consume(t2) {
    t2.LA(1) === "\n".charCodeAt(0) ? (this.line += 1, this.column = 0) : this.column += 1, t2.consume();
  }
  getTokenName(t2) {
    return -1 === t2 ? "EOF" : "'" + String.fromCharCode(t2) + "'";
  }
}
Xt.debug = false, Xt.dfa_debug = false, Xt.MIN_DFA_EDGE = 0, Xt.MAX_DFA_EDGE = 127;
class Jt {
  constructor(t2, e2) {
    this.alt = e2, this.pred = t2;
  }
  toString() {
    return "(" + this.pred + ", " + this.alt + ")";
  }
}
class Zt {
  constructor() {
    this.data = {};
  }
  get(t2) {
    return this.data["k-" + t2] || null;
  }
  set(t2, e2) {
    this.data["k-" + t2] = e2;
  }
  values() {
    return Object.keys(this.data).filter(((t2) => t2.startsWith("k-"))).map(((t2) => this.data[t2]), this);
  }
}
const Qt = { SLL: 0, LL: 1, LL_EXACT_AMBIG_DETECTION: 2, hasSLLConflictTerminatingPrediction: function(t2, e2) {
  if (Qt.allConfigsInRuleStopStates(e2)) return true;
  if (t2 === Qt.SLL && e2.hasSemanticContext) {
    const t3 = new Vt();
    for (let n3 = 0; n3 < e2.items.length; n3++) {
      let s2 = e2.items[n3];
      s2 = new m({ semanticContext: p.NONE }, s2), t3.add(s2);
    }
    e2 = t3;
  }
  const n2 = Qt.getConflictingAltSubsets(e2);
  return Qt.hasConflictingAltSet(n2) && !Qt.hasStateAssociatedWithOneAlt(e2);
}, hasConfigInRuleStopState: function(t2) {
  for (let e2 = 0; e2 < t2.items.length; e2++) if (t2.items[e2].state instanceof A) return true;
  return false;
}, allConfigsInRuleStopStates: function(t2) {
  for (let e2 = 0; e2 < t2.items.length; e2++) if (!(t2.items[e2].state instanceof A)) return false;
  return true;
}, resolvesToJustOneViableAlt: function(t2) {
  return Qt.getSingleViableAlt(t2);
}, allSubsetsConflict: function(t2) {
  return !Qt.hasNonConflictingAltSet(t2);
}, hasNonConflictingAltSet: function(t2) {
  for (let e2 = 0; e2 < t2.length; e2++) if (1 === t2[e2].length) return true;
  return false;
}, hasConflictingAltSet: function(t2) {
  for (let e2 = 0; e2 < t2.length; e2++) if (t2[e2].length > 1) return true;
  return false;
}, allSubsetsEqual: function(t2) {
  let e2 = null;
  for (let n2 = 0; n2 < t2.length; n2++) {
    const s2 = t2[n2];
    if (null === e2) e2 = s2;
    else if (s2 !== e2) return false;
  }
  return true;
}, getUniqueAlt: function(t2) {
  const e2 = Qt.getAlts(t2);
  return 1 === e2.length ? e2.minValue() : $.INVALID_ALT_NUMBER;
}, getAlts: function(t2) {
  const e2 = new W();
  return t2.map((function(t3) {
    e2.or(t3);
  })), e2;
}, getConflictingAltSubsets: function(t2) {
  const e2 = new H();
  return e2.hashFunction = function(t3) {
    l.hashStuff(t3.state.stateNumber, t3.context);
  }, e2.equalsFunction = function(t3, e3) {
    return t3.state.stateNumber === e3.state.stateNumber && t3.context.equals(e3.context);
  }, t2.items.map((function(t3) {
    let n2 = e2.get(t3);
    null === n2 && (n2 = new W(), e2.set(t3, n2)), n2.set(t3.alt);
  })), e2.getValues();
}, getStateToAltMap: function(t2) {
  const e2 = new Zt();
  return t2.items.map((function(t3) {
    let n2 = e2.get(t3.state);
    null === n2 && (n2 = new W(), e2.set(t3.state, n2)), n2.set(t3.alt);
  })), e2;
}, hasStateAssociatedWithOneAlt: function(t2) {
  const e2 = Qt.getStateToAltMap(t2).values();
  for (let t3 = 0; t3 < e2.length; t3++) if (1 === e2[t3].length) return true;
  return false;
}, getSingleViableAlt: function(t2) {
  let e2 = null;
  for (let n2 = 0; n2 < t2.length; n2++) {
    const s2 = t2[n2].minValue();
    if (null === e2) e2 = s2;
    else if (e2 !== s2) return $.INVALID_ALT_NUMBER;
  }
  return e2;
} }, te = Qt;
class ee extends Ft {
  constructor(t2, e2, n2, s2, i2, r2) {
    r2 = r2 || t2._ctx, s2 = s2 || t2.getCurrentToken(), n2 = n2 || t2.getCurrentToken(), e2 = e2 || t2.getInputStream(), super({ message: "", recognizer: t2, input: e2, ctx: r2 }), this.deadEndConfigs = i2, this.startToken = n2, this.offendingToken = s2;
  }
}
class ne {
  constructor(t2) {
    this.defaultMapCtor = t2 || H, this.cacheMap = new this.defaultMapCtor();
  }
  get(t2, e2) {
    const n2 = this.cacheMap.get(t2) || null;
    return null === n2 ? null : n2.get(e2) || null;
  }
  set(t2, e2, n2) {
    let s2 = this.cacheMap.get(t2) || null;
    null === s2 && (s2 = new this.defaultMapCtor(), this.cacheMap.set(t2, s2)), s2.set(e2, n2);
  }
}
class se extends Ht {
  constructor(t2, e2, n2, s2) {
    super(e2, s2), this.parser = t2, this.decisionToDFA = n2, this.predictionMode = te.LL, this._input = null, this._startIndex = 0, this._outerContext = null, this._dfa = null, this.mergeCache = null, this.debug = false, this.debug_closure = false, this.debug_add = false, this.trace_atn_sim = false, this.dfa_debug = false, this.retry_debug = false;
  }
  reset() {
  }
  adaptivePredict(t2, e2, n2) {
    (this.debug || this.trace_atn_sim) && console.log("adaptivePredict decision " + e2 + " exec LA(1)==" + this.getLookaheadName(t2) + " line " + t2.LT(1).line + ":" + t2.LT(1).column), this._input = t2, this._startIndex = t2.index, this._outerContext = n2;
    const s2 = this.decisionToDFA[e2];
    this._dfa = s2;
    const i2 = t2.mark(), r2 = t2.index;
    try {
      let e3;
      if (e3 = s2.precedenceDfa ? s2.getPrecedenceStartState(this.parser.getPrecedence()) : s2.s0, null === e3) {
        null === n2 && (n2 = U.EMPTY), this.debug && console.log("predictATN decision " + s2.decision + " exec LA(1)==" + this.getLookaheadName(t2) + ", outerContext=" + n2.toString(this.parser.ruleNames));
        const i4 = false;
        let r3 = this.computeStartState(s2.atnStartState, U.EMPTY, i4);
        s2.precedenceDfa ? (s2.s0.configs = r3, r3 = this.applyPrecedenceFilter(r3), e3 = this.addDFAState(s2, new qt(null, r3)), s2.setPrecedenceStartState(this.parser.getPrecedence(), e3)) : (e3 = this.addDFAState(s2, new qt(null, r3)), s2.s0 = e3);
      }
      const i3 = this.execATN(s2, e3, t2, r2, n2);
      return this.debug && console.log("DFA after predictATN: " + s2.toString(this.parser.literalNames, this.parser.symbolicNames)), i3;
    } finally {
      this._dfa = null, this.mergeCache = null, t2.seek(r2), t2.release(i2);
    }
  }
  execATN(t2, e2, n2, s2, r2) {
    let o2;
    (this.debug || this.trace_atn_sim) && console.log("execATN decision " + t2.decision + ", DFA state " + e2 + ", LA(1)==" + this.getLookaheadName(n2) + " line " + n2.LT(1).line + ":" + n2.LT(1).column);
    let a2 = e2;
    this.debug && console.log("s0 = " + e2);
    let l2 = n2.LA(1);
    for (; ; ) {
      let e3 = this.getExistingTargetState(a2, l2);
      if (null === e3 && (e3 = this.computeTargetState(t2, a2, l2)), e3 === Ht.ERROR) {
        const t3 = this.noViableAlt(n2, r2, a2.configs, s2);
        if (n2.seek(s2), o2 = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(a2.configs, r2), o2 !== $.INVALID_ALT_NUMBER) return o2;
        throw t3;
      }
      if (e3.requiresFullContext && this.predictionMode !== te.SLL) {
        let i2 = null;
        if (null !== e3.predicates) {
          this.debug && console.log("DFA state has preds in DFA sim LL failover");
          const t3 = n2.index;
          if (t3 !== s2 && n2.seek(s2), i2 = this.evalSemanticContext(e3.predicates, r2, true), 1 === i2.length) return this.debug && console.log("Full LL avoided"), i2.minValue();
          t3 !== s2 && n2.seek(t3);
        }
        this.dfa_debug && console.log("ctx sensitive state " + r2 + " in " + e3);
        const a3 = true, l3 = this.computeStartState(t2.atnStartState, r2, a3);
        return this.reportAttemptingFullContext(t2, i2, e3.configs, s2, n2.index), o2 = this.execATNWithFullContext(t2, e3, l3, n2, s2, r2), o2;
      }
      if (e3.isAcceptState) {
        if (null === e3.predicates) return e3.prediction;
        const i2 = n2.index;
        n2.seek(s2);
        const o3 = this.evalSemanticContext(e3.predicates, r2, true);
        if (0 === o3.length) throw this.noViableAlt(n2, r2, e3.configs, s2);
        return 1 === o3.length || this.reportAmbiguity(t2, e3, s2, i2, false, o3, e3.configs), o3.minValue();
      }
      a2 = e3, l2 !== i.EOF && (n2.consume(), l2 = n2.LA(1));
    }
  }
  getExistingTargetState(t2, e2) {
    const n2 = t2.edges;
    return null === n2 ? null : n2[e2 + 1] || null;
  }
  computeTargetState(t2, e2, n2) {
    const s2 = this.computeReachSet(e2.configs, n2, false);
    if (null === s2) return this.addDFAEdge(t2, e2, n2, Ht.ERROR), Ht.ERROR;
    let i2 = new qt(null, s2);
    const r2 = this.getUniqueAlt(s2);
    if (this.debug) {
      const t3 = te.getConflictingAltSubsets(s2);
      console.log("SLL altSubSets=" + d(t3) + ", configs=" + s2 + ", predict=" + r2 + ", allSubsetsConflict=" + te.allSubsetsConflict(t3) + ", conflictingAlts=" + this.getConflictingAlts(s2));
    }
    return r2 !== $.INVALID_ALT_NUMBER ? (i2.isAcceptState = true, i2.configs.uniqueAlt = r2, i2.prediction = r2) : te.hasSLLConflictTerminatingPrediction(this.predictionMode, s2) && (i2.configs.conflictingAlts = this.getConflictingAlts(s2), i2.requiresFullContext = true, i2.isAcceptState = true, i2.prediction = i2.configs.conflictingAlts.minValue()), i2.isAcceptState && i2.configs.hasSemanticContext && (this.predicateDFAState(i2, this.atn.getDecisionState(t2.decision)), null !== i2.predicates && (i2.prediction = $.INVALID_ALT_NUMBER)), i2 = this.addDFAEdge(t2, e2, n2, i2), i2;
  }
  predicateDFAState(t2, e2) {
    const n2 = e2.transitions.length, s2 = this.getConflictingAltsOrUniqueAlt(t2.configs), i2 = this.getPredsForAmbigAlts(s2, t2.configs, n2);
    null !== i2 ? (t2.predicates = this.getPredicatePredictions(s2, i2), t2.prediction = $.INVALID_ALT_NUMBER) : t2.prediction = s2.minValue();
  }
  execATNWithFullContext(t2, e2, n2, s2, r2, o2) {
    (this.debug || this.trace_atn_sim) && console.log("execATNWithFullContext " + n2);
    let a2, l2 = false, h2 = n2;
    s2.seek(r2);
    let c2 = s2.LA(1), u2 = -1;
    for (; ; ) {
      if (a2 = this.computeReachSet(h2, c2, true), null === a2) {
        const t4 = this.noViableAlt(s2, o2, h2, r2);
        s2.seek(r2);
        const e3 = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(h2, o2);
        if (e3 !== $.INVALID_ALT_NUMBER) return e3;
        throw t4;
      }
      const t3 = te.getConflictingAltSubsets(a2);
      if (this.debug && console.log("LL altSubSets=" + t3 + ", predict=" + te.getUniqueAlt(t3) + ", resolvesToJustOneViableAlt=" + te.resolvesToJustOneViableAlt(t3)), a2.uniqueAlt = this.getUniqueAlt(a2), a2.uniqueAlt !== $.INVALID_ALT_NUMBER) {
        u2 = a2.uniqueAlt;
        break;
      }
      if (this.predictionMode !== te.LL_EXACT_AMBIG_DETECTION) {
        if (u2 = te.resolvesToJustOneViableAlt(t3), u2 !== $.INVALID_ALT_NUMBER) break;
      } else if (te.allSubsetsConflict(t3) && te.allSubsetsEqual(t3)) {
        l2 = true, u2 = te.getSingleViableAlt(t3);
        break;
      }
      h2 = a2, c2 !== i.EOF && (s2.consume(), c2 = s2.LA(1));
    }
    return a2.uniqueAlt !== $.INVALID_ALT_NUMBER ? (this.reportContextSensitivity(t2, u2, a2, r2, s2.index), u2) : (this.reportAmbiguity(t2, e2, r2, s2.index, l2, null, a2), u2);
  }
  computeReachSet(t2, e2, n2) {
    this.debug && console.log("in computeReachSet, starting closure: " + t2), null === this.mergeCache && (this.mergeCache = new ne());
    const s2 = new Vt(n2);
    let r2 = null;
    for (let o3 = 0; o3 < t2.items.length; o3++) {
      const a2 = t2.items[o3];
      if (this.debug && console.log("testing " + this.getTokenName(e2) + " at " + a2), a2.state instanceof A) (n2 || e2 === i.EOF) && (null === r2 && (r2 = []), r2.push(a2), this.debug_add && console.log("added " + a2 + " to skippedStopStates"));
      else for (let t3 = 0; t3 < a2.state.transitions.length; t3++) {
        const n3 = a2.state.transitions[t3], i2 = this.getReachableTarget(n3, e2);
        if (null !== i2) {
          const t4 = new m({ state: i2 }, a2);
          s2.add(t4, this.mergeCache), this.debug_add && console.log("added " + t4 + " to intermediate");
        }
      }
    }
    let o2 = null;
    if (null === r2 && e2 !== i.EOF && (1 === s2.items.length || this.getUniqueAlt(s2) !== $.INVALID_ALT_NUMBER) && (o2 = s2), null === o2) {
      o2 = new Vt(n2);
      const t3 = new g(), r3 = e2 === i.EOF;
      for (let e3 = 0; e3 < s2.items.length; e3++) this.closure(s2.items[e3], o2, t3, false, n2, r3);
    }
    if (e2 === i.EOF && (o2 = this.removeAllConfigsNotInRuleStopState(o2, o2 === s2)), !(null === r2 || n2 && te.hasConfigInRuleStopState(o2))) for (let t3 = 0; t3 < r2.length; t3++) o2.add(r2[t3], this.mergeCache);
    return this.trace_atn_sim && console.log("computeReachSet " + t2 + " -> " + o2), 0 === o2.items.length ? null : o2;
  }
  removeAllConfigsNotInRuleStopState(t2, e2) {
    if (te.allConfigsInRuleStopStates(t2)) return t2;
    const n2 = new Vt(t2.fullCtx);
    for (let s2 = 0; s2 < t2.items.length; s2++) {
      const r2 = t2.items[s2];
      if (r2.state instanceof A) n2.add(r2, this.mergeCache);
      else if (e2 && r2.state.epsilonOnlyTransitions && this.atn.nextTokens(r2.state).contains(i.EPSILON)) {
        const t3 = this.atn.ruleToStopState[r2.state.ruleIndex];
        n2.add(new m({ state: t3 }, r2), this.mergeCache);
      }
    }
    return n2;
  }
  computeStartState(t2, e2, n2) {
    const s2 = K(this.atn, e2), i2 = new Vt(n2);
    this.trace_atn_sim && console.log("computeStartState from ATN state " + t2 + " initialContext=" + s2.toString(this.parser));
    for (let e3 = 0; e3 < t2.transitions.length; e3++) {
      const r2 = t2.transitions[e3].target, o2 = new m({ state: r2, alt: e3 + 1, context: s2 }, null), a2 = new g();
      this.closure(o2, i2, a2, true, n2, false);
    }
    return i2;
  }
  applyPrecedenceFilter(t2) {
    let e2;
    const n2 = [], s2 = new Vt(t2.fullCtx);
    for (let i2 = 0; i2 < t2.items.length; i2++) {
      if (e2 = t2.items[i2], 1 !== e2.alt) continue;
      const r2 = e2.semanticContext.evalPrecedence(this.parser, this._outerContext);
      null !== r2 && (n2[e2.state.stateNumber] = e2.context, r2 !== e2.semanticContext ? s2.add(new m({ semanticContext: r2 }, e2), this.mergeCache) : s2.add(e2, this.mergeCache));
    }
    for (let i2 = 0; i2 < t2.items.length; i2++) if (e2 = t2.items[i2], 1 !== e2.alt) {
      if (!e2.precedenceFilterSuppressed) {
        const t3 = n2[e2.state.stateNumber] || null;
        if (null !== t3 && t3.equals(e2.context)) continue;
      }
      s2.add(e2, this.mergeCache);
    }
    return s2;
  }
  getReachableTarget(t2, e2) {
    return t2.matches(e2, 0, this.atn.maxTokenType) ? t2.target : null;
  }
  getPredsForAmbigAlts(t2, e2, n2) {
    let s2 = [];
    for (let n3 = 0; n3 < e2.items.length; n3++) {
      const i3 = e2.items[n3];
      t2.get(i3.alt) && (s2[i3.alt] = p.orContext(s2[i3.alt] || null, i3.semanticContext));
    }
    let i2 = 0;
    for (let t3 = 1; t3 < n2 + 1; t3++) {
      const e3 = s2[t3] || null;
      null === e3 ? s2[t3] = p.NONE : e3 !== p.NONE && (i2 += 1);
    }
    return 0 === i2 && (s2 = null), this.debug && console.log("getPredsForAmbigAlts result " + d(s2)), s2;
  }
  getPredicatePredictions(t2, e2) {
    const n2 = [];
    let s2 = false;
    for (let i2 = 1; i2 < e2.length; i2++) {
      const r2 = e2[i2];
      null !== t2 && t2.get(i2) && n2.push(new Jt(r2, i2)), r2 !== p.NONE && (s2 = true);
    }
    return s2 ? n2 : null;
  }
  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(t2, e2) {
    const n2 = this.splitAccordingToSemanticValidity(t2, e2), s2 = n2[0], i2 = n2[1];
    let r2 = this.getAltThatFinishedDecisionEntryRule(s2);
    return r2 !== $.INVALID_ALT_NUMBER || i2.items.length > 0 && (r2 = this.getAltThatFinishedDecisionEntryRule(i2), r2 !== $.INVALID_ALT_NUMBER) ? r2 : $.INVALID_ALT_NUMBER;
  }
  getAltThatFinishedDecisionEntryRule(t2) {
    const e2 = [];
    for (let n2 = 0; n2 < t2.items.length; n2++) {
      const s2 = t2.items[n2];
      (s2.reachesIntoOuterContext > 0 || s2.state instanceof A && s2.context.hasEmptyPath()) && e2.indexOf(s2.alt) < 0 && e2.push(s2.alt);
    }
    return 0 === e2.length ? $.INVALID_ALT_NUMBER : Math.min.apply(null, e2);
  }
  splitAccordingToSemanticValidity(t2, e2) {
    const n2 = new Vt(t2.fullCtx), s2 = new Vt(t2.fullCtx);
    for (let i2 = 0; i2 < t2.items.length; i2++) {
      const r2 = t2.items[i2];
      r2.semanticContext !== p.NONE ? r2.semanticContext.evaluate(this.parser, e2) ? n2.add(r2) : s2.add(r2) : n2.add(r2);
    }
    return [n2, s2];
  }
  evalSemanticContext(t2, e2, n2) {
    const s2 = new W();
    for (let i2 = 0; i2 < t2.length; i2++) {
      const r2 = t2[i2];
      if (r2.pred === p.NONE) {
        if (s2.set(r2.alt), !n2) break;
        continue;
      }
      const o2 = r2.pred.evaluate(this.parser, e2);
      if ((this.debug || this.dfa_debug) && console.log("eval pred " + r2 + "=" + o2), o2 && ((this.debug || this.dfa_debug) && console.log("PREDICT " + r2.alt), s2.set(r2.alt), !n2)) break;
    }
    return s2;
  }
  closure(t2, e2, n2, s2, i2, r2) {
    this.closureCheckingStopState(t2, e2, n2, s2, i2, 0, r2);
  }
  closureCheckingStopState(t2, e2, n2, s2, i2, r2, o2) {
    if ((this.trace_atn_sim || this.debug_closure) && console.log("closure(" + t2.toString(this.parser, true) + ")"), t2.state instanceof A) {
      if (!t2.context.isEmpty()) {
        for (let a2 = 0; a2 < t2.context.length; a2++) {
          if (t2.context.getReturnState(a2) === B.EMPTY_RETURN_STATE) {
            if (i2) {
              e2.add(new m({ state: t2.state, context: B.EMPTY }, t2), this.mergeCache);
              continue;
            }
            this.debug && console.log("FALLING off rule " + this.getRuleName(t2.state.ruleIndex)), this.closure_(t2, e2, n2, s2, i2, r2, o2);
            continue;
          }
          const l2 = this.atn.states[t2.context.getReturnState(a2)], h2 = t2.context.getParent(a2), c2 = { state: l2, alt: t2.alt, context: h2, semanticContext: t2.semanticContext }, u2 = new m(c2, null);
          u2.reachesIntoOuterContext = t2.reachesIntoOuterContext, this.closureCheckingStopState(u2, e2, n2, s2, i2, r2 - 1, o2);
        }
        return;
      }
      if (i2) return void e2.add(t2, this.mergeCache);
      this.debug && console.log("FALLING off rule " + this.getRuleName(t2.state.ruleIndex));
    }
    this.closure_(t2, e2, n2, s2, i2, r2, o2);
  }
  closure_(t2, e2, n2, s2, i2, r2, o2) {
    const a2 = t2.state;
    a2.epsilonOnlyTransitions || e2.add(t2, this.mergeCache);
    for (let l2 = 0; l2 < a2.transitions.length; l2++) {
      if (0 === l2 && this.canDropLoopEntryEdgeInLeftRecursiveRule(t2)) continue;
      const h2 = a2.transitions[l2], c2 = s2 && !(h2 instanceof ut), u2 = this.getEpsilonTarget(t2, h2, c2, 0 === r2, i2, o2);
      if (null !== u2) {
        let s3 = r2;
        if (t2.state instanceof A) {
          if (null !== this._dfa && this._dfa.precedenceDfa && h2.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex && (u2.precedenceFilterSuppressed = true), u2.reachesIntoOuterContext += 1, n2.getOrAdd(u2) !== u2) continue;
          e2.dipsIntoOuterContext = true, s3 -= 1, this.debug && console.log("dips into outer ctx: " + u2);
        } else {
          if (!h2.isEpsilon && n2.getOrAdd(u2) !== u2) continue;
          h2 instanceof k && s3 >= 0 && (s3 += 1);
        }
        this.closureCheckingStopState(u2, e2, n2, c2, i2, s3, o2);
      }
    }
  }
  canDropLoopEntryEdgeInLeftRecursiveRule(t2) {
    const e2 = t2.state;
    if (e2.stateType !== C.STAR_LOOP_ENTRY) return false;
    if (e2.stateType !== C.STAR_LOOP_ENTRY || !e2.isPrecedenceDecision || t2.context.isEmpty() || t2.context.hasEmptyPath()) return false;
    const n2 = t2.context.length;
    for (let s3 = 0; s3 < n2; s3++) if (this.atn.states[t2.context.getReturnState(s3)].ruleIndex !== e2.ruleIndex) return false;
    const s2 = e2.transitions[0].target.endState.stateNumber, i2 = this.atn.states[s2];
    for (let s3 = 0; s3 < n2; s3++) {
      const n3 = t2.context.getReturnState(s3), r2 = this.atn.states[n3];
      if (1 !== r2.transitions.length || !r2.transitions[0].isEpsilon) return false;
      const o2 = r2.transitions[0].target;
      if (!(r2.stateType === C.BLOCK_END && o2 === e2 || r2 === i2 || o2 === i2 || o2.stateType === C.BLOCK_END && 1 === o2.transitions.length && o2.transitions[0].isEpsilon && o2.transitions[0].target === e2)) return false;
    }
    return true;
  }
  getRuleName(t2) {
    return null !== this.parser && t2 >= 0 ? this.parser.ruleNames[t2] : "<rule " + t2 + ">";
  }
  getEpsilonTarget(t2, e2, n2, s2, r2, o2) {
    switch (e2.serializationType) {
      case N.RULE:
        return this.ruleTransition(t2, e2);
      case N.PRECEDENCE:
        return this.precedenceTransition(t2, e2, n2, s2, r2);
      case N.PREDICATE:
        return this.predTransition(t2, e2, n2, s2, r2);
      case N.ACTION:
        return this.actionTransition(t2, e2);
      case N.EPSILON:
        return new m({ state: e2.target }, t2);
      case N.ATOM:
      case N.RANGE:
      case N.SET:
        return o2 && e2.matches(i.EOF, 0, 1) ? new m({ state: e2.target }, t2) : null;
      default:
        return null;
    }
  }
  actionTransition(t2, e2) {
    if (this.debug) {
      const t3 = -1 === e2.actionIndex ? 65535 : e2.actionIndex;
      console.log("ACTION edge " + e2.ruleIndex + ":" + t3);
    }
    return new m({ state: e2.target }, t2);
  }
  precedenceTransition(t2, e2, n2, s2, i2) {
    this.debug && (console.log("PRED (collectPredicates=" + n2 + ") " + e2.precedence + ">=_p, ctx dependent=true"), null !== this.parser && console.log("context surrounding pred is " + d(this.parser.getRuleInvocationStack())));
    let r2 = null;
    if (n2 && s2) if (i2) {
      const n3 = this._input.index;
      this._input.seek(this._startIndex);
      const s3 = e2.getPredicate().evaluate(this.parser, this._outerContext);
      this._input.seek(n3), s3 && (r2 = new m({ state: e2.target }, t2));
    } else {
      const n3 = p.andContext(t2.semanticContext, e2.getPredicate());
      r2 = new m({ state: e2.target, semanticContext: n3 }, t2);
    }
    else r2 = new m({ state: e2.target }, t2);
    return this.debug && console.log("config from pred transition=" + r2), r2;
  }
  predTransition(t2, e2, n2, s2, i2) {
    this.debug && (console.log("PRED (collectPredicates=" + n2 + ") " + e2.ruleIndex + ":" + e2.predIndex + ", ctx dependent=" + e2.isCtxDependent), null !== this.parser && console.log("context surrounding pred is " + d(this.parser.getRuleInvocationStack())));
    let r2 = null;
    if (n2 && (e2.isCtxDependent && s2 || !e2.isCtxDependent)) if (i2) {
      const n3 = this._input.index;
      this._input.seek(this._startIndex);
      const s3 = e2.getPredicate().evaluate(this.parser, this._outerContext);
      this._input.seek(n3), s3 && (r2 = new m({ state: e2.target }, t2));
    } else {
      const n3 = p.andContext(t2.semanticContext, e2.getPredicate());
      r2 = new m({ state: e2.target, semanticContext: n3 }, t2);
    }
    else r2 = new m({ state: e2.target }, t2);
    return this.debug && console.log("config from pred transition=" + r2), r2;
  }
  ruleTransition(t2, e2) {
    this.debug && console.log("CALL rule " + this.getRuleName(e2.target.ruleIndex) + ", ctx=" + t2.context);
    const n2 = e2.followState, s2 = V.create(t2.context, n2.stateNumber);
    return new m({ state: e2.target, context: s2 }, t2);
  }
  getConflictingAlts(t2) {
    const e2 = te.getConflictingAltSubsets(t2);
    return te.getAlts(e2);
  }
  getConflictingAltsOrUniqueAlt(t2) {
    let e2 = null;
    return t2.uniqueAlt !== $.INVALID_ALT_NUMBER ? (e2 = new W(), e2.set(t2.uniqueAlt)) : e2 = t2.conflictingAlts, e2;
  }
  getTokenName(t2) {
    if (t2 === i.EOF) return "EOF";
    if (null !== this.parser && null !== this.parser.literalNames) {
      if (!(t2 >= this.parser.literalNames.length && t2 >= this.parser.symbolicNames.length)) return (this.parser.literalNames[t2] || this.parser.symbolicNames[t2]) + "<" + t2 + ">";
      console.log(t2 + " ttype out of range: " + this.parser.literalNames), console.log("" + this.parser.getInputStream().getTokens());
    }
    return "" + t2;
  }
  getLookaheadName(t2) {
    return this.getTokenName(t2.LA(1));
  }
  dumpDeadEndConfigs(t2) {
    console.log("dead end configs: ");
    const e2 = t2.getDeadEndConfigs();
    for (let t3 = 0; t3 < e2.length; t3++) {
      const n2 = e2[t3];
      let s2 = "no edges";
      if (n2.state.transitions.length > 0) {
        const t4 = n2.state.transitions[0];
        t4 instanceof ht ? s2 = "Atom " + this.getTokenName(t4.label) : t4 instanceof I && (s2 = (t4 instanceof y ? "~" : "") + "Set " + t4.set);
      }
      console.error(n2.toString(this.parser, true) + ":" + s2);
    }
  }
  noViableAlt(t2, e2, n2, s2) {
    return new ee(this.parser, t2, t2.get(s2), t2.LT(1), n2, e2);
  }
  getUniqueAlt(t2) {
    let e2 = $.INVALID_ALT_NUMBER;
    for (let n2 = 0; n2 < t2.items.length; n2++) {
      const s2 = t2.items[n2];
      if (e2 === $.INVALID_ALT_NUMBER) e2 = s2.alt;
      else if (s2.alt !== e2) return $.INVALID_ALT_NUMBER;
    }
    return e2;
  }
  addDFAEdge(t2, e2, n2, s2) {
    if (this.debug && console.log("EDGE " + e2 + " -> " + s2 + " upon " + this.getTokenName(n2)), null === s2) return null;
    if (s2 = this.addDFAState(t2, s2), null === e2 || n2 < -1 || n2 > this.atn.maxTokenType) return s2;
    if (null === e2.edges && (e2.edges = []), e2.edges[n2 + 1] = s2, this.debug) {
      const e3 = null === this.parser ? null : this.parser.literalNames, n3 = null === this.parser ? null : this.parser.symbolicNames;
      console.log("DFA=\n" + t2.toString(e3, n3));
    }
    return s2;
  }
  addDFAState(t2, e2) {
    if (e2 === Ht.ERROR) return e2;
    const n2 = t2.states.get(e2);
    return null !== n2 ? (this.trace_atn_sim && console.log("addDFAState " + e2 + " exists"), n2) : (e2.stateNumber = t2.states.length, e2.configs.readOnly || (e2.configs.optimizeConfigs(this), e2.configs.setReadonly(true)), this.trace_atn_sim && console.log("addDFAState new " + e2), t2.states.add(e2), this.debug && console.log("adding new DFA state: " + e2), e2);
  }
  reportAttemptingFullContext(t2, e2, n2, s2, i2) {
    if (this.debug || this.retry_debug) {
      const e3 = new E(s2, i2 + 1);
      console.log("reportAttemptingFullContext decision=" + t2.decision + ":" + n2 + ", input=" + this.parser.getTokenStream().getText(e3));
    }
    null !== this.parser && this.parser.getErrorListener().reportAttemptingFullContext(this.parser, t2, s2, i2, e2, n2);
  }
  reportContextSensitivity(t2, e2, n2, s2, i2) {
    if (this.debug || this.retry_debug) {
      const e3 = new E(s2, i2 + 1);
      console.log("reportContextSensitivity decision=" + t2.decision + ":" + n2 + ", input=" + this.parser.getTokenStream().getText(e3));
    }
    null !== this.parser && this.parser.getErrorListener().reportContextSensitivity(this.parser, t2, s2, i2, e2, n2);
  }
  reportAmbiguity(t2, e2, n2, s2, i2, r2, o2) {
    if (this.debug || this.retry_debug) {
      const t3 = new E(n2, s2 + 1);
      console.log("reportAmbiguity " + r2 + ":" + o2 + ", input=" + this.parser.getTokenStream().getText(t3));
    }
    null !== this.parser && this.parser.getErrorListener().reportAmbiguity(this.parser, t2, n2, s2, i2, r2, o2);
  }
}
class ie {
  constructor() {
    this.cache = new H();
  }
  add(t2) {
    if (t2 === B.EMPTY) return B.EMPTY;
    const e2 = this.cache.get(t2) || null;
    return null !== e2 ? e2 : (this.cache.set(t2, t2), t2);
  }
  get(t2) {
    return this.cache.get(t2) || null;
  }
  get length() {
    return this.cache.length;
  }
}
const re = { ATN: $, ATNDeserializer: Lt, LexerATNSimulator: Xt, ParserATNSimulator: se, PredictionMode: te, PredictionContextCache: ie };
class oe {
  constructor(t2, e2, n2) {
    this.dfa = t2, this.literalNames = e2 || [], this.symbolicNames = n2 || [];
  }
  toString() {
    if (null === this.dfa.s0) return null;
    let t2 = "";
    const e2 = this.dfa.sortedStates();
    for (let n2 = 0; n2 < e2.length; n2++) {
      const s2 = e2[n2];
      if (null !== s2.edges) {
        const e3 = s2.edges.length;
        for (let n3 = 0; n3 < e3; n3++) {
          const e4 = s2.edges[n3] || null;
          null !== e4 && 2147483647 !== e4.stateNumber && (t2 = t2.concat(this.getStateString(s2)), t2 = t2.concat("-"), t2 = t2.concat(this.getEdgeLabel(n3)), t2 = t2.concat("->"), t2 = t2.concat(this.getStateString(e4)), t2 = t2.concat("\n"));
        }
      }
    }
    return 0 === t2.length ? null : t2;
  }
  getEdgeLabel(t2) {
    return 0 === t2 ? "EOF" : null !== this.literalNames || null !== this.symbolicNames ? this.literalNames[t2 - 1] || this.symbolicNames[t2 - 1] : String.fromCharCode(t2 - 1);
  }
  getStateString(t2) {
    const e2 = (t2.isAcceptState ? ":" : "") + "s" + t2.stateNumber + (t2.requiresFullContext ? "^" : "");
    return t2.isAcceptState ? null !== t2.predicates ? e2 + "=>" + d(t2.predicates) : e2 + "=>" + t2.prediction.toString() : e2;
  }
}
class ae extends oe {
  constructor(t2) {
    super(t2, null);
  }
  getEdgeLabel(t2) {
    return "'" + String.fromCharCode(t2) + "'";
  }
}
class le {
  constructor(t2, e2) {
    if (void 0 === e2 && (e2 = 0), this.atnStartState = t2, this.decision = e2, this._states = new g(), this.s0 = null, this.precedenceDfa = false, t2 instanceof rt && t2.isPrecedenceDecision) {
      this.precedenceDfa = true;
      const t3 = new qt(null, new Vt());
      t3.edges = [], t3.isAcceptState = false, t3.requiresFullContext = false, this.s0 = t3;
    }
  }
  getPrecedenceStartState(t2) {
    if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
    return t2 < 0 || t2 >= this.s0.edges.length ? null : this.s0.edges[t2] || null;
  }
  setPrecedenceStartState(t2, e2) {
    if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
    t2 < 0 || (this.s0.edges[t2] = e2);
  }
  setPrecedenceDfa(t2) {
    if (this.precedenceDfa !== t2) {
      if (this._states = new g(), t2) {
        const t3 = new qt(null, new Vt());
        t3.edges = [], t3.isAcceptState = false, t3.requiresFullContext = false, this.s0 = t3;
      } else this.s0 = null;
      this.precedenceDfa = t2;
    }
  }
  sortedStates() {
    return this._states.values().sort((function(t2, e2) {
      return t2.stateNumber - e2.stateNumber;
    }));
  }
  toString(t2, e2) {
    return t2 = t2 || null, e2 = e2 || null, null === this.s0 ? "" : new oe(this, t2, e2).toString();
  }
  toLexerString() {
    return null === this.s0 ? "" : new ae(this).toString();
  }
  get states() {
    return this._states;
  }
}
const he = { DFA: le, DFASerializer: oe, LexerDFASerializer: ae, PredPrediction: Jt }, ce = { PredictionContext: B }, ue = { Interval: E, IntervalSet: _ };
class de {
  visitTerminal(t2) {
  }
  visitErrorNode(t2) {
  }
  enterEveryRule(t2) {
  }
  exitEveryRule(t2) {
  }
}
class ge {
  visit(t2) {
    return Array.isArray(t2) ? t2.map((function(t3) {
      return t3.accept(this);
    }), this) : t2.accept(this);
  }
  visitChildren(t2) {
    return t2.children ? this.visit(t2.children) : null;
  }
  visitTerminal(t2) {
  }
  visitErrorNode(t2) {
  }
}
class pe {
  walk(t2, e2) {
    if (e2 instanceof D || void 0 !== e2.isErrorNode && e2.isErrorNode()) t2.visitErrorNode(e2);
    else if (e2 instanceof b) t2.visitTerminal(e2);
    else {
      this.enterRule(t2, e2);
      for (let n2 = 0; n2 < e2.getChildCount(); n2++) {
        const s2 = e2.getChild(n2);
        this.walk(t2, s2);
      }
      this.exitRule(t2, e2);
    }
  }
  enterRule(t2, e2) {
    const n2 = e2.ruleContext;
    t2.enterEveryRule(n2), n2.enterRule(t2);
  }
  exitRule(t2, e2) {
    const n2 = e2.ruleContext;
    n2.exitRule(t2), t2.exitEveryRule(n2);
  }
}
pe.DEFAULT = new pe();
const fe = { Trees: M, RuleNode: P, ErrorNode: D, TerminalNode: b, ParseTreeListener: de, ParseTreeVisitor: ge, ParseTreeWalker: pe };
class xe extends Ft {
  constructor(t2) {
    super({ message: "", recognizer: t2, input: t2.getInputStream(), ctx: t2._ctx }), this.offendingToken = t2.getCurrentToken();
  }
}
class Te extends Ft {
  constructor(t2, e2, n2) {
    super({ message: Se(e2, n2 || null), recognizer: t2, input: t2.getInputStream(), ctx: t2._ctx });
    const s2 = t2._interp.atn.states[t2.state].transitions[0];
    s2 instanceof pt ? (this.ruleIndex = s2.ruleIndex, this.predicateIndex = s2.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = e2, this.offendingToken = t2.getCurrentToken();
  }
}
function Se(t2, e2) {
  return null !== e2 ? e2 : "failed predicate: {" + t2 + "}?";
}
class me extends Ot {
  constructor(t2) {
    super(), t2 = t2 || true, this.exactOnly = t2;
  }
  reportAmbiguity(t2, e2, n2, s2, i2, r2, o2) {
    if (this.exactOnly && !i2) return;
    const a2 = "reportAmbiguity d=" + this.getDecisionDescription(t2, e2) + ": ambigAlts=" + this.getConflictingAlts(r2, o2) + ", input='" + t2.getTokenStream().getText(new E(n2, s2)) + "'";
    t2.notifyErrorListeners(a2);
  }
  reportAttemptingFullContext(t2, e2, n2, s2, i2, r2) {
    const o2 = "reportAttemptingFullContext d=" + this.getDecisionDescription(t2, e2) + ", input='" + t2.getTokenStream().getText(new E(n2, s2)) + "'";
    t2.notifyErrorListeners(o2);
  }
  reportContextSensitivity(t2, e2, n2, s2, i2, r2) {
    const o2 = "reportContextSensitivity d=" + this.getDecisionDescription(t2, e2) + ", input='" + t2.getTokenStream().getText(new E(n2, s2)) + "'";
    t2.notifyErrorListeners(o2);
  }
  getDecisionDescription(t2, e2) {
    const n2 = e2.decision, s2 = e2.atnStartState.ruleIndex, i2 = t2.ruleNames;
    if (s2 < 0 || s2 >= i2.length) return "" + n2;
    const r2 = i2[s2] || null;
    return null === r2 || 0 === r2.length ? "" + n2 : `${n2} (${r2})`;
  }
  getConflictingAlts(t2, e2) {
    if (null !== t2) return t2;
    const n2 = new W();
    for (let t3 = 0; t3 < e2.items.length; t3++) n2.set(e2.items[t3].alt);
    return `{${n2.values().join(", ")}}`;
  }
}
class Ee extends Error {
  constructor() {
    super(), Error.captureStackTrace(this, Ee);
  }
}
class _e {
  reset(t2) {
  }
  recoverInline(t2) {
  }
  recover(t2, e2) {
  }
  sync(t2) {
  }
  inErrorRecoveryMode(t2) {
  }
  reportError(t2) {
  }
}
class Ce extends _e {
  constructor() {
    super(), this.errorRecoveryMode = false, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
  }
  reset(t2) {
    this.endErrorCondition(t2);
  }
  beginErrorCondition(t2) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(t2) {
    return this.errorRecoveryMode;
  }
  endErrorCondition(t2) {
    this.errorRecoveryMode = false, this.lastErrorStates = null, this.lastErrorIndex = -1;
  }
  reportMatch(t2) {
    this.endErrorCondition(t2);
  }
  reportError(t2, e2) {
    this.inErrorRecoveryMode(t2) || (this.beginErrorCondition(t2), e2 instanceof ee ? this.reportNoViableAlternative(t2, e2) : e2 instanceof xe ? this.reportInputMismatch(t2, e2) : e2 instanceof Te ? this.reportFailedPredicate(t2, e2) : (console.log("unknown recognition error type: " + e2.constructor.name), console.log(e2.stack), t2.notifyErrorListeners(e2.getOffendingToken(), e2.getMessage(), e2)));
  }
  recover(t2, e2) {
    this.lastErrorIndex === t2.getInputStream().index && null !== this.lastErrorStates && this.lastErrorStates.indexOf(t2.state) >= 0 && t2.consume(), this.lastErrorIndex = t2._input.index, null === this.lastErrorStates && (this.lastErrorStates = []), this.lastErrorStates.push(t2.state);
    const n2 = this.getErrorRecoverySet(t2);
    this.consumeUntil(t2, n2);
  }
  sync(t2) {
    if (this.inErrorRecoveryMode(t2)) return;
    const e2 = t2._interp.atn.states[t2.state], n2 = t2.getTokenStream().LA(1), s2 = t2.atn.nextTokens(e2);
    if (s2.contains(n2)) return this.nextTokensContext = null, void (this.nextTokenState = C.INVALID_STATE_NUMBER);
    if (s2.contains(i.EPSILON)) null === this.nextTokensContext && (this.nextTokensContext = t2._ctx, this.nextTokensState = t2._stateNumber);
    else switch (e2.stateType) {
      case C.BLOCK_START:
      case C.STAR_BLOCK_START:
      case C.PLUS_BLOCK_START:
      case C.STAR_LOOP_ENTRY:
        if (null !== this.singleTokenDeletion(t2)) return;
        throw new xe(t2);
      case C.PLUS_LOOP_BACK:
      case C.STAR_LOOP_BACK: {
        this.reportUnwantedToken(t2);
        const e3 = new _();
        e3.addSet(t2.getExpectedTokens());
        const n3 = e3.addSet(this.getErrorRecoverySet(t2));
        this.consumeUntil(t2, n3);
      }
    }
  }
  reportNoViableAlternative(t2, e2) {
    const n2 = t2.getTokenStream();
    let s2;
    s2 = null !== n2 ? e2.startToken.type === i.EOF ? "<EOF>" : n2.getText(new E(e2.startToken.tokenIndex, e2.offendingToken.tokenIndex)) : "<unknown input>";
    const r2 = "no viable alternative at input " + this.escapeWSAndQuote(s2);
    t2.notifyErrorListeners(r2, e2.offendingToken, e2);
  }
  reportInputMismatch(t2, e2) {
    const n2 = "mismatched input " + this.getTokenErrorDisplay(e2.offendingToken) + " expecting " + e2.getExpectedTokens().toString(t2.literalNames, t2.symbolicNames);
    t2.notifyErrorListeners(n2, e2.offendingToken, e2);
  }
  reportFailedPredicate(t2, e2) {
    const n2 = "rule " + t2.ruleNames[t2._ctx.ruleIndex] + " " + e2.message;
    t2.notifyErrorListeners(n2, e2.offendingToken, e2);
  }
  reportUnwantedToken(t2) {
    if (this.inErrorRecoveryMode(t2)) return;
    this.beginErrorCondition(t2);
    const e2 = t2.getCurrentToken(), n2 = "extraneous input " + this.getTokenErrorDisplay(e2) + " expecting " + this.getExpectedTokens(t2).toString(t2.literalNames, t2.symbolicNames);
    t2.notifyErrorListeners(n2, e2, null);
  }
  reportMissingToken(t2) {
    if (this.inErrorRecoveryMode(t2)) return;
    this.beginErrorCondition(t2);
    const e2 = t2.getCurrentToken(), n2 = "missing " + this.getExpectedTokens(t2).toString(t2.literalNames, t2.symbolicNames) + " at " + this.getTokenErrorDisplay(e2);
    t2.notifyErrorListeners(n2, e2, null);
  }
  recoverInline(t2) {
    const e2 = this.singleTokenDeletion(t2);
    if (null !== e2) return t2.consume(), e2;
    if (this.singleTokenInsertion(t2)) return this.getMissingSymbol(t2);
    throw new xe(t2);
  }
  singleTokenInsertion(t2) {
    const e2 = t2.getTokenStream().LA(1), n2 = t2._interp.atn, s2 = n2.states[t2.state].transitions[0].target;
    return !!n2.nextTokens(s2, t2._ctx).contains(e2) && (this.reportMissingToken(t2), true);
  }
  singleTokenDeletion(t2) {
    const e2 = t2.getTokenStream().LA(2);
    if (this.getExpectedTokens(t2).contains(e2)) {
      this.reportUnwantedToken(t2), t2.consume();
      const e3 = t2.getCurrentToken();
      return this.reportMatch(t2), e3;
    }
    return null;
  }
  getMissingSymbol(t2) {
    const e2 = t2.getCurrentToken(), n2 = this.getExpectedTokens(t2).first();
    let s2;
    s2 = n2 === i.EOF ? "<missing EOF>" : "<missing " + t2.literalNames[n2] + ">";
    let r2 = e2;
    const o2 = t2.getTokenStream().LT(-1);
    return r2.type === i.EOF && null !== o2 && (r2 = o2), t2.getTokenFactory().create(r2.source, n2, s2, i.DEFAULT_CHANNEL, -1, -1, r2.line, r2.column);
  }
  getExpectedTokens(t2) {
    return t2.getExpectedTokens();
  }
  getTokenErrorDisplay(t2) {
    if (null === t2) return "<no token>";
    let e2 = t2.text;
    return null === e2 && (e2 = t2.type === i.EOF ? "<EOF>" : "<" + t2.type + ">"), this.escapeWSAndQuote(e2);
  }
  escapeWSAndQuote(t2) {
    return "'" + (t2 = (t2 = (t2 = t2.replace(/\n/g, "\\n")).replace(/\r/g, "\\r")).replace(/\t/g, "\\t")) + "'";
  }
  getErrorRecoverySet(t2) {
    const e2 = t2._interp.atn;
    let n2 = t2._ctx;
    const s2 = new _();
    for (; null !== n2 && n2.invokingState >= 0; ) {
      const t3 = e2.states[n2.invokingState].transitions[0], i2 = e2.nextTokens(t3.followState);
      s2.addSet(i2), n2 = n2.parentCtx;
    }
    return s2.removeOne(i.EPSILON), s2;
  }
  consumeUntil(t2, e2) {
    let n2 = t2.getTokenStream().LA(1);
    for (; n2 !== i.EOF && !e2.contains(n2); ) t2.consume(), n2 = t2.getTokenStream().LA(1);
  }
}
class Ae extends Ce {
  constructor() {
    super();
  }
  recover(t2, e2) {
    let n2 = t2._ctx;
    for (; null !== n2; ) n2.exception = e2, n2 = n2.parentCtx;
    throw new Ee(e2);
  }
  recoverInline(t2) {
    this.recover(t2, new xe(t2));
  }
  sync(t2) {
  }
}
const Ne = { RecognitionException: Ft, NoViableAltException: ee, LexerNoViableAltException: Mt, InputMismatchException: xe, FailedPredicateException: Te, DiagnosticErrorListener: me, BailErrorStrategy: Ae, DefaultErrorStrategy: Ce, ErrorListener: Ot };
class ke {
  constructor(t2, e2) {
    if (this.name = "<empty>", this.strdata = t2, this.decodeToUnicodeCodePoints = e2 || false, this._index = 0, this.data = [], this.decodeToUnicodeCodePoints) for (let t3 = 0; t3 < this.strdata.length; ) {
      const e3 = this.strdata.codePointAt(t3);
      this.data.push(e3), t3 += e3 <= 65535 ? 1 : 2;
    }
    else {
      this.data = new Array(this.strdata.length);
      for (let t3 = 0; t3 < this.strdata.length; t3++) this.data[t3] = this.strdata.charCodeAt(t3);
    }
    this._size = this.data.length;
  }
  reset() {
    this._index = 0;
  }
  consume() {
    if (this._index >= this._size) throw "cannot consume EOF";
    this._index += 1;
  }
  LA(t2) {
    if (0 === t2) return 0;
    t2 < 0 && (t2 += 1);
    const e2 = this._index + t2 - 1;
    return e2 < 0 || e2 >= this._size ? i.EOF : this.data[e2];
  }
  LT(t2) {
    return this.LA(t2);
  }
  mark() {
    return -1;
  }
  release(t2) {
  }
  seek(t2) {
    t2 <= this._index ? this._index = t2 : this._index = Math.min(t2, this._size);
  }
  getText(t2, e2) {
    if (e2 >= this._size && (e2 = this._size - 1), t2 >= this._size) return "";
    if (this.decodeToUnicodeCodePoints) {
      let n2 = "";
      for (let s2 = t2; s2 <= e2; s2++) n2 += String.fromCodePoint(this.data[s2]);
      return n2;
    }
    return this.strdata.slice(t2, e2 + 1);
  }
  toString() {
    return this.strdata;
  }
  get index() {
    return this._index;
  }
  get size() {
    return this._size;
  }
}
class Ie extends ke {
  constructor(t2, e2) {
    super(t2, e2);
  }
}
var ye = n(763);
const Le = "undefined" != typeof process && null != process.versions && null != process.versions.node;
class Oe extends Ie {
  static fromPath(t2, e2, n2) {
    if (!Le) throw new Error("FileStream is only available when running in Node!");
    ye.readFile(t2, e2, (function(t3, e3) {
      let s2 = null;
      null !== e3 && (s2 = new ke(e3, true)), n2(t3, s2);
    }));
  }
  constructor(t2, e2, n2) {
    if (!Le) throw new Error("FileStream is only available when running in Node!");
    super(ye.readFileSync(t2, e2 || "utf-8"), n2), this.fileName = t2;
  }
}
const Re = { fromString: function(t2) {
  return new ke(t2, true);
}, fromBlob: function(t2, e2, n2, s2) {
  const i2 = new window.FileReader();
  i2.onload = function(t3) {
    const e3 = new ke(t3.target.result, true);
    n2(e3);
  }, i2.onerror = s2, i2.readAsText(t2, e2);
}, fromBuffer: function(t2, e2) {
  return new ke(t2.toString(e2), true);
}, fromPath: function(t2, e2, n2) {
  Oe.fromPath(t2, e2, n2);
}, fromPathSync: function(t2, e2) {
  return new Oe(t2, e2);
} }, we = { arrayToString: d, stringToCharArray: function(t2) {
  let e2 = new Uint16Array(t2.length);
  for (let n2 = 0; n2 < t2.length; n2++) e2[n2] = t2.charCodeAt(n2);
  return e2;
} };
class ve {
}
class Pe extends ve {
  constructor(t2) {
    super(), this.tokenSource = t2, this.tokens = [], this.index = -1, this.fetchedEOF = false;
  }
  mark() {
    return 0;
  }
  release(t2) {
  }
  reset() {
    this.seek(0);
  }
  seek(t2) {
    this.lazyInit(), this.index = this.adjustSeekIndex(t2);
  }
  get size() {
    return this.tokens.length;
  }
  get(t2) {
    return this.lazyInit(), this.tokens[t2];
  }
  consume() {
    let t2 = false;
    if (t2 = this.index >= 0 && (this.fetchedEOF ? this.index < this.tokens.length - 1 : this.index < this.tokens.length), !t2 && this.LA(1) === i.EOF) throw "cannot consume EOF";
    this.sync(this.index + 1) && (this.index = this.adjustSeekIndex(this.index + 1));
  }
  sync(t2) {
    const e2 = t2 - this.tokens.length + 1;
    return !(e2 > 0) || this.fetch(e2) >= e2;
  }
  fetch(t2) {
    if (this.fetchedEOF) return 0;
    for (let e2 = 0; e2 < t2; e2++) {
      const t3 = this.tokenSource.nextToken();
      if (t3.tokenIndex = this.tokens.length, this.tokens.push(t3), t3.type === i.EOF) return this.fetchedEOF = true, e2 + 1;
    }
    return t2;
  }
  getTokens(t2, e2, n2) {
    if (void 0 === n2 && (n2 = null), t2 < 0 || e2 < 0) return null;
    this.lazyInit();
    const s2 = [];
    e2 >= this.tokens.length && (e2 = this.tokens.length - 1);
    for (let r2 = t2; r2 < e2; r2++) {
      const t3 = this.tokens[r2];
      if (t3.type === i.EOF) break;
      (null === n2 || n2.contains(t3.type)) && s2.push(t3);
    }
    return s2;
  }
  LA(t2) {
    return this.LT(t2).type;
  }
  LB(t2) {
    return this.index - t2 < 0 ? null : this.tokens[this.index - t2];
  }
  LT(t2) {
    if (this.lazyInit(), 0 === t2) return null;
    if (t2 < 0) return this.LB(-t2);
    const e2 = this.index + t2 - 1;
    return this.sync(e2), e2 >= this.tokens.length ? this.tokens[this.tokens.length - 1] : this.tokens[e2];
  }
  adjustSeekIndex(t2) {
    return t2;
  }
  lazyInit() {
    -1 === this.index && this.setup();
  }
  setup() {
    this.sync(0), this.index = this.adjustSeekIndex(0);
  }
  setTokenSource(t2) {
    this.tokenSource = t2, this.tokens = [], this.index = -1, this.fetchedEOF = false;
  }
  nextTokenOnChannel(t2, e2) {
    if (this.sync(t2), t2 >= this.tokens.length) return -1;
    let n2 = this.tokens[t2];
    for (; n2.channel !== e2; ) {
      if (n2.type === i.EOF) return -1;
      t2 += 1, this.sync(t2), n2 = this.tokens[t2];
    }
    return t2;
  }
  previousTokenOnChannel(t2, e2) {
    for (; t2 >= 0 && this.tokens[t2].channel !== e2; ) t2 -= 1;
    return t2;
  }
  getHiddenTokensToRight(t2, e2) {
    if (void 0 === e2 && (e2 = -1), this.lazyInit(), t2 < 0 || t2 >= this.tokens.length) throw t2 + " not in 0.." + this.tokens.length - 1;
    const n2 = this.nextTokenOnChannel(t2 + 1, Ut.DEFAULT_TOKEN_CHANNEL), s2 = t2 + 1, i2 = -1 === n2 ? this.tokens.length - 1 : n2;
    return this.filterForChannel(s2, i2, e2);
  }
  getHiddenTokensToLeft(t2, e2) {
    if (void 0 === e2 && (e2 = -1), this.lazyInit(), t2 < 0 || t2 >= this.tokens.length) throw t2 + " not in 0.." + this.tokens.length - 1;
    const n2 = this.previousTokenOnChannel(t2 - 1, Ut.DEFAULT_TOKEN_CHANNEL);
    if (n2 === t2 - 1) return null;
    const s2 = n2 + 1, i2 = t2 - 1;
    return this.filterForChannel(s2, i2, e2);
  }
  filterForChannel(t2, e2, n2) {
    const s2 = [];
    for (let i2 = t2; i2 < e2 + 1; i2++) {
      const t3 = this.tokens[i2];
      -1 === n2 ? t3.channel !== Ut.DEFAULT_TOKEN_CHANNEL && s2.push(t3) : t3.channel === n2 && s2.push(t3);
    }
    return 0 === s2.length ? null : s2;
  }
  getSourceName() {
    return this.tokenSource.getSourceName();
  }
  getText(t2) {
    this.lazyInit(), this.fill(), t2 || (t2 = new E(0, this.tokens.length - 1));
    let e2 = t2.start;
    e2 instanceof i && (e2 = e2.tokenIndex);
    let n2 = t2.stop;
    if (n2 instanceof i && (n2 = n2.tokenIndex), null === e2 || null === n2 || e2 < 0 || n2 < 0) return "";
    n2 >= this.tokens.length && (n2 = this.tokens.length - 1);
    let s2 = "";
    for (let t3 = e2; t3 < n2 + 1; t3++) {
      const e3 = this.tokens[t3];
      if (e3.type === i.EOF) break;
      s2 += e3.text;
    }
    return s2;
  }
  fill() {
    for (this.lazyInit(); 1e3 === this.fetch(1e3); ) ;
  }
}
Object.defineProperty(Pe, "size", { get: function() {
  return this.tokens.length;
} });
class be extends Pe {
  constructor(t2, e2) {
    super(t2), this.channel = void 0 === e2 ? i.DEFAULT_CHANNEL : e2;
  }
  adjustSeekIndex(t2) {
    return this.nextTokenOnChannel(t2, this.channel);
  }
  LB(t2) {
    if (0 === t2 || this.index - t2 < 0) return null;
    let e2 = this.index, n2 = 1;
    for (; n2 <= t2; ) e2 = this.previousTokenOnChannel(e2 - 1, this.channel), n2 += 1;
    return e2 < 0 ? null : this.tokens[e2];
  }
  LT(t2) {
    if (this.lazyInit(), 0 === t2) return null;
    if (t2 < 0) return this.LB(-t2);
    let e2 = this.index, n2 = 1;
    for (; n2 < t2; ) this.sync(e2 + 1) && (e2 = this.nextTokenOnChannel(e2 + 1, this.channel)), n2 += 1;
    return this.tokens[e2];
  }
  getNumberOfOnChannelTokens() {
    let t2 = 0;
    this.fill();
    for (let e2 = 0; e2 < this.tokens.length; e2++) {
      const n2 = this.tokens[e2];
      if (n2.channel === this.channel && (t2 += 1), n2.type === i.EOF) break;
    }
    return t2;
  }
}
class De extends de {
  constructor(t2) {
    super(), this.parser = t2;
  }
  enterEveryRule(t2) {
    console.log("enter   " + this.parser.ruleNames[t2.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
  visitTerminal(t2) {
    console.log("consume " + t2.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }
  exitEveryRule(t2) {
    console.log("exit    " + this.parser.ruleNames[t2.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
}
class Fe extends vt {
  constructor(t2) {
    super(), this._input = null, this._errHandler = new Ce(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = true, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.setInputStream(t2);
  }
  reset() {
    null !== this._input && this._input.seek(0), this._errHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(false), this._precedenceStack = [], this._precedenceStack.push(0), null !== this._interp && this._interp.reset();
  }
  match(t2) {
    let e2 = this.getCurrentToken();
    return e2.type === t2 ? (this._errHandler.reportMatch(this), this.consume()) : (e2 = this._errHandler.recoverInline(this), this.buildParseTrees && -1 === e2.tokenIndex && this._ctx.addErrorNode(e2)), e2;
  }
  matchWildcard() {
    let t2 = this.getCurrentToken();
    return t2.type > 0 ? (this._errHandler.reportMatch(this), this.consume()) : (t2 = this._errHandler.recoverInline(this), this.buildParseTrees && -1 === t2.tokenIndex && this._ctx.addErrorNode(t2)), t2;
  }
  getParseListeners() {
    return this._parseListeners || [];
  }
  addParseListener(t2) {
    if (null === t2) throw "listener";
    null === this._parseListeners && (this._parseListeners = []), this._parseListeners.push(t2);
  }
  removeParseListener(t2) {
    if (null !== this._parseListeners) {
      const e2 = this._parseListeners.indexOf(t2);
      e2 >= 0 && this._parseListeners.splice(e2, 1), 0 === this._parseListeners.length && (this._parseListeners = null);
    }
  }
  removeParseListeners() {
    this._parseListeners = null;
  }
  triggerEnterRuleEvent() {
    if (null !== this._parseListeners) {
      const t2 = this._ctx;
      this._parseListeners.forEach((function(e2) {
        e2.enterEveryRule(t2), t2.enterRule(e2);
      }));
    }
  }
  triggerExitRuleEvent() {
    if (null !== this._parseListeners) {
      const t2 = this._ctx;
      this._parseListeners.slice(0).reverse().forEach((function(e2) {
        t2.exitRule(e2), e2.exitEveryRule(t2);
      }));
    }
  }
  getTokenFactory() {
    return this._input.tokenSource._factory;
  }
  setTokenFactory(t2) {
    this._input.tokenSource._factory = t2;
  }
  getATNWithBypassAlts() {
    const t2 = this.getSerializedATN();
    if (null === t2) throw "The current parser does not support an ATN with bypass alternatives.";
    let e2 = this.bypassAltsAtnCache[t2];
    if (null === e2) {
      const n2 = new Tt();
      n2.generateRuleBypassTransitions = true, e2 = new Lt(n2).deserialize(t2), this.bypassAltsAtnCache[t2] = e2;
    }
    return e2;
  }
  getInputStream() {
    return this.getTokenStream();
  }
  setInputStream(t2) {
    this.setTokenStream(t2);
  }
  getTokenStream() {
    return this._input;
  }
  setTokenStream(t2) {
    this._input = null, this.reset(), this._input = t2;
  }
  get syntaxErrorsCount() {
    return this._syntaxErrors;
  }
  getCurrentToken() {
    return this._input.LT(1);
  }
  notifyErrorListeners(t2, e2, n2) {
    n2 = n2 || null, null === (e2 = e2 || null) && (e2 = this.getCurrentToken()), this._syntaxErrors += 1;
    const s2 = e2.line, i2 = e2.column;
    this.getErrorListener().syntaxError(this, e2, s2, i2, t2, n2);
  }
  consume() {
    const t2 = this.getCurrentToken();
    t2.type !== i.EOF && this.getInputStream().consume();
    const e2 = null !== this._parseListeners && this._parseListeners.length > 0;
    if (this.buildParseTrees || e2) {
      let n2;
      n2 = this._errHandler.inErrorRecoveryMode(this) ? this._ctx.addErrorNode(t2) : this._ctx.addTokenNode(t2), n2.invokingState = this.state, e2 && this._parseListeners.forEach((function(t3) {
        n2 instanceof D || void 0 !== n2.isErrorNode && n2.isErrorNode() ? t3.visitErrorNode(n2) : n2 instanceof b && t3.visitTerminal(n2);
      }));
    }
    return t2;
  }
  addContextToParseTree() {
    null !== this._ctx.parentCtx && this._ctx.parentCtx.addChild(this._ctx);
  }
  enterRule(t2, e2, n2) {
    this.state = e2, this._ctx = t2, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
  }
  exitRule() {
    this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parentCtx;
  }
  enterOuterAlt(t2, e2) {
    t2.setAltNumber(e2), this.buildParseTrees && this._ctx !== t2 && null !== this._ctx.parentCtx && (this._ctx.parentCtx.removeLastChild(), this._ctx.parentCtx.addChild(t2)), this._ctx = t2;
  }
  getPrecedence() {
    return 0 === this._precedenceStack.length ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
  }
  enterRecursionRule(t2, e2, n2, s2) {
    this.state = e2, this._precedenceStack.push(s2), this._ctx = t2, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
  }
  pushNewRecursionContext(t2, e2, n2) {
    const s2 = this._ctx;
    s2.parentCtx = t2, s2.invokingState = e2, s2.stop = this._input.LT(-1), this._ctx = t2, this._ctx.start = s2.start, this.buildParseTrees && this._ctx.addChild(s2), this.triggerEnterRuleEvent();
  }
  unrollRecursionContexts(t2) {
    this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
    const e2 = this._ctx, n2 = this.getParseListeners();
    if (null !== n2 && n2.length > 0) for (; this._ctx !== t2; ) this.triggerExitRuleEvent(), this._ctx = this._ctx.parentCtx;
    else this._ctx = t2;
    e2.parentCtx = t2, this.buildParseTrees && null !== t2 && t2.addChild(e2);
  }
  getInvokingContext(t2) {
    let e2 = this._ctx;
    for (; null !== e2; ) {
      if (e2.ruleIndex === t2) return e2;
      e2 = e2.parentCtx;
    }
    return null;
  }
  precpred(t2, e2) {
    return e2 >= this._precedenceStack[this._precedenceStack.length - 1];
  }
  inContext(t2) {
    return false;
  }
  isExpectedToken(t2) {
    const e2 = this._interp.atn;
    let n2 = this._ctx;
    const s2 = e2.states[this.state];
    let r2 = e2.nextTokens(s2);
    if (r2.contains(t2)) return true;
    if (!r2.contains(i.EPSILON)) return false;
    for (; null !== n2 && n2.invokingState >= 0 && r2.contains(i.EPSILON); ) {
      const s3 = e2.states[n2.invokingState].transitions[0];
      if (r2 = e2.nextTokens(s3.followState), r2.contains(t2)) return true;
      n2 = n2.parentCtx;
    }
    return !(!r2.contains(i.EPSILON) || t2 !== i.EOF);
  }
  getExpectedTokens() {
    return this._interp.atn.getExpectedTokens(this.state, this._ctx);
  }
  getExpectedTokensWithinCurrentRule() {
    const t2 = this._interp.atn, e2 = t2.states[this.state];
    return t2.nextTokens(e2);
  }
  getRuleIndex(t2) {
    const e2 = this.getRuleIndexMap()[t2];
    return null !== e2 ? e2 : -1;
  }
  getRuleInvocationStack(t2) {
    null === (t2 = t2 || null) && (t2 = this._ctx);
    const e2 = [];
    for (; null !== t2; ) {
      const n2 = t2.ruleIndex;
      n2 < 0 ? e2.push("n/a") : e2.push(this.ruleNames[n2]), t2 = t2.parentCtx;
    }
    return e2;
  }
  getDFAStrings() {
    return this._interp.decisionToDFA.toString();
  }
  dumpDFA() {
    let t2 = false;
    for (let e2 = 0; e2 < this._interp.decisionToDFA.length; e2++) {
      const n2 = this._interp.decisionToDFA[e2];
      n2.states.length > 0 && (t2 && console.log(), this.printer.println("Decision " + n2.decision + ":"), this.printer.print(n2.toString(this.literalNames, this.symbolicNames)), t2 = true);
    }
  }
  getSourceName() {
    return this._input.getSourceName();
  }
  setTrace(t2) {
    t2 ? (null !== this._tracer && this.removeParseListener(this._tracer), this._tracer = new De(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
  }
}
Fe.bypassAltsAtnCache = {};
class Me extends b {
  constructor(t2) {
    super(), this.parentCtx = null, this.symbol = t2;
  }
  getChild(t2) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  getParent() {
    return this.parentCtx;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (null === this.symbol) return E.INVALID_INTERVAL;
    const t2 = this.symbol.tokenIndex;
    return new E(t2, t2);
  }
  getChildCount() {
    return 0;
  }
  accept(t2) {
    return t2.visitTerminal(this);
  }
  getText() {
    return this.symbol.text;
  }
  toString() {
    return this.symbol.type === i.EOF ? "<EOF>" : this.symbol.text;
  }
}
class Ue extends Me {
  constructor(t2) {
    super(t2);
  }
  isErrorNode() {
    return true;
  }
  accept(t2) {
    return t2.visitErrorNode(this);
  }
}
class Be extends U {
  constructor(t2, e2) {
    super(t2, e2), this.children = null, this.start = null, this.stop = null, this.exception = null;
  }
  copyFrom(t2) {
    this.parentCtx = t2.parentCtx, this.invokingState = t2.invokingState, this.children = null, this.start = t2.start, this.stop = t2.stop, t2.children && (this.children = [], t2.children.map((function(t3) {
      t3 instanceof Ue && (this.children.push(t3), t3.parentCtx = this);
    }), this));
  }
  enterRule(t2) {
  }
  exitRule(t2) {
  }
  addChild(t2) {
    return null === this.children && (this.children = []), this.children.push(t2), t2;
  }
  removeLastChild() {
    null !== this.children && this.children.pop();
  }
  addTokenNode(t2) {
    const e2 = new Me(t2);
    return this.addChild(e2), e2.parentCtx = this, e2;
  }
  addErrorNode(t2) {
    const e2 = new Ue(t2);
    return this.addChild(e2), e2.parentCtx = this, e2;
  }
  getChild(t2, e2) {
    if (e2 = e2 || null, null === this.children || t2 < 0 || t2 >= this.children.length) return null;
    if (null === e2) return this.children[t2];
    for (let n2 = 0; n2 < this.children.length; n2++) {
      const s2 = this.children[n2];
      if (s2 instanceof e2) {
        if (0 === t2) return s2;
        t2 -= 1;
      }
    }
    return null;
  }
  getToken(t2, e2) {
    if (null === this.children || e2 < 0 || e2 >= this.children.length) return null;
    for (let n2 = 0; n2 < this.children.length; n2++) {
      const s2 = this.children[n2];
      if (s2 instanceof b && s2.symbol.type === t2) {
        if (0 === e2) return s2;
        e2 -= 1;
      }
    }
    return null;
  }
  getTokens(t2) {
    if (null === this.children) return [];
    {
      const e2 = [];
      for (let n2 = 0; n2 < this.children.length; n2++) {
        const s2 = this.children[n2];
        s2 instanceof b && s2.symbol.type === t2 && e2.push(s2);
      }
      return e2;
    }
  }
  getTypedRuleContext(t2, e2) {
    return this.getChild(e2, t2);
  }
  getTypedRuleContexts(t2) {
    if (null === this.children) return [];
    {
      const e2 = [];
      for (let n2 = 0; n2 < this.children.length; n2++) {
        const s2 = this.children[n2];
        s2 instanceof t2 && e2.push(s2);
      }
      return e2;
    }
  }
  getChildCount() {
    return null === this.children ? 0 : this.children.length;
  }
  getSourceInterval() {
    return null === this.start || null === this.stop ? E.INVALID_INTERVAL : new E(this.start.tokenIndex, this.stop.tokenIndex);
  }
}
U.EMPTY = new Be();
class ze {
  static DEFAULT_PROGRAM_NAME = "default";
  constructor(t2) {
    this.tokens = t2, this.programs = /* @__PURE__ */ new Map();
  }
  getTokenStream() {
    return this.tokens;
  }
  insertAfter(t2, e2) {
    let n2, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ze.DEFAULT_PROGRAM_NAME;
    n2 = "number" == typeof t2 ? t2 : t2.tokenIndex;
    let i2 = this.getProgram(s2), r2 = new He(this.tokens, n2, i2.length, e2);
    i2.push(r2);
  }
  insertBefore(t2, e2) {
    let n2, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ze.DEFAULT_PROGRAM_NAME;
    n2 = "number" == typeof t2 ? t2 : t2.tokenIndex;
    const i2 = this.getProgram(s2), r2 = new qe(this.tokens, n2, i2.length, e2);
    i2.push(r2);
  }
  replaceSingle(t2, e2) {
    let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ze.DEFAULT_PROGRAM_NAME;
    this.replace(t2, t2, e2, n2);
  }
  replace(t2, e2, n2) {
    let s2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ze.DEFAULT_PROGRAM_NAME;
    if ("number" != typeof t2 && (t2 = t2.tokenIndex), "number" != typeof e2 && (e2 = e2.tokenIndex), t2 > e2 || t2 < 0 || e2 < 0 || e2 >= this.tokens.size) throw new RangeError(`replace: range invalid: ${t2}..${e2}(size=${this.tokens.size})`);
    let i2 = this.getProgram(s2), r2 = new Ke(this.tokens, t2, e2, i2.length, n2);
    i2.push(r2);
  }
  delete(t2, e2) {
    let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ze.DEFAULT_PROGRAM_NAME;
    void 0 === e2 && (e2 = t2), this.replace(t2, e2, null, n2);
  }
  getProgram(t2) {
    let e2 = this.programs.get(t2);
    return null == e2 && (e2 = this.initializeProgram(t2)), e2;
  }
  initializeProgram(t2) {
    const e2 = [];
    return this.programs.set(t2, e2), e2;
  }
  getText(t2) {
    let e2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ze.DEFAULT_PROGRAM_NAME;
    e2 = t2 instanceof E ? t2 : new E(0, this.tokens.size - 1), "string" == typeof t2 && (n2 = t2);
    const s2 = this.programs.get(n2);
    let r2 = e2.start, o2 = e2.stop;
    if (o2 > this.tokens.size - 1 && (o2 = this.tokens.size - 1), r2 < 0 && (r2 = 0), null == s2 || 0 === s2.length) return this.tokens.getText(new E(r2, o2));
    let a2 = [], l2 = this.reduceToSingleOperationPerIndex(s2), h2 = r2;
    for (; h2 <= o2 && h2 < this.tokens.size; ) {
      let t3 = l2.get(h2);
      l2.delete(h2);
      let e3 = this.tokens.get(h2);
      null == t3 ? (e3.type !== i.EOF && a2.push(String(e3.text)), h2++) : h2 = t3.execute(a2);
    }
    if (o2 === this.tokens.size - 1) for (const t3 of l2.values()) t3.index >= this.tokens.size - 1 && a2.push(t3.text.toString());
    return a2.join("");
  }
  reduceToSingleOperationPerIndex(t2) {
    for (let e3 = 0; e3 < t2.length; e3++) {
      let n2 = t2[e3];
      if (null == n2) continue;
      if (!(n2 instanceof Ke)) continue;
      let s2 = n2, i2 = this.getKindOfOps(t2, qe, e3);
      for (let e4 of i2) e4.index === s2.index ? (t2[e4.instructionIndex] = void 0, s2.text = e4.text.toString() + (null != s2.text ? s2.text.toString() : "")) : e4.index > s2.index && e4.index <= s2.lastIndex && (t2[e4.instructionIndex] = void 0);
      let r2 = this.getKindOfOps(t2, Ke, e3);
      for (let e4 of r2) {
        if (e4.index >= s2.index && e4.lastIndex <= s2.lastIndex) {
          t2[e4.instructionIndex] = void 0;
          continue;
        }
        let n3 = e4.lastIndex < s2.index || e4.index > s2.lastIndex;
        if (null != e4.text || null != s2.text || n3) {
          if (!n3) throw new Error(`replace op boundaries of ${s2} overlap with previous ${e4}`);
        } else t2[e4.instructionIndex] = void 0, s2.index = Math.min(e4.index, s2.index), s2.lastIndex = Math.max(e4.lastIndex, s2.lastIndex);
      }
    }
    for (let e3 = 0; e3 < t2.length; e3++) {
      let n2 = t2[e3];
      if (null == n2) continue;
      if (!(n2 instanceof qe)) continue;
      let s2 = n2, i2 = this.getKindOfOps(t2, qe, e3);
      for (let e4 of i2) e4.index === s2.index && (e4 instanceof He ? (s2.text = this.catOpText(e4.text, s2.text), t2[e4.instructionIndex] = void 0) : e4 instanceof qe && (s2.text = this.catOpText(s2.text, e4.text), t2[e4.instructionIndex] = void 0));
      let r2 = this.getKindOfOps(t2, Ke, e3);
      for (let n3 of r2) if (s2.index !== n3.index) {
        if (s2.index >= n3.index && s2.index <= n3.lastIndex) throw new Error(`insert op ${s2} within boundaries of previous ${n3}`);
      } else n3.text = this.catOpText(s2.text, n3.text), t2[e3] = void 0;
    }
    let e2 = /* @__PURE__ */ new Map();
    for (let n2 of t2) if (null != n2) {
      if (null != e2.get(n2.index)) throw new Error("should only be one op per index");
      e2.set(n2.index, n2);
    }
    return e2;
  }
  catOpText(t2, e2) {
    let n2 = "", s2 = "";
    return null != t2 && (n2 = t2.toString()), null != e2 && (s2 = e2.toString()), n2 + s2;
  }
  getKindOfOps(t2, e2, n2) {
    return t2.slice(0, n2).filter(((t3) => t3 && t3 instanceof e2));
  }
}
class Ve {
  constructor(t2, e2, n2, s2) {
    this.tokens = t2, this.instructionIndex = n2, this.index = e2, this.text = void 0 === s2 ? "" : s2;
  }
  toString() {
    let t2 = this.constructor.name;
    const e2 = t2.indexOf("$");
    return t2 = t2.substring(e2 + 1, t2.length), "<" + t2 + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
  }
}
class qe extends Ve {
  constructor(t2, e2, n2, s2) {
    super(t2, e2, n2, s2);
  }
  execute(t2) {
    return this.text && t2.push(this.text.toString()), this.tokens.get(this.index).type !== i.EOF && t2.push(String(this.tokens.get(this.index).text)), this.index + 1;
  }
}
class He extends qe {
  constructor(t2, e2, n2, s2) {
    super(t2, e2 + 1, n2, s2);
  }
}
class Ke extends Ve {
  constructor(t2, e2, n2, s2, i2) {
    super(t2, e2, s2, i2), this.lastIndex = n2;
  }
  execute(t2) {
    return this.text && t2.push(this.text.toString()), this.lastIndex + 1;
  }
  toString() {
    return null == this.text ? "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">" : "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
  }
}
const Ye = { atn: re, dfa: he, context: ce, misc: ue, tree: fe, error: Ne, Token: i, CommonToken: Pt, CharStreams: Re, CharStream: ke, InputStream: Ie, CommonTokenStream: be, Lexer: Ut, Parser: Fe, ParserRuleContext: Be, Interval: E, IntervalSet: _, LL1Analyzer: j, Utils: we, TokenStreamRewriter: ze };
var Ge = s.MG, We = s.fr;
s.sR;
s.Zo;
var Xe = s.iH;
s.rt;
var Ze = s.jB, Qe = s.M8;
s.$t;
s.aq;
var nn = s.pG, sn = s.eP;
s.KU;
s.zW;
s.IX;
s.mY;
s.a7;
var cn = s.JG, un = s.ay, dn = s.X2;
s.WU;
s.Uw;
s.gw;
var xn = s.iX, Tn = s.re, Sn = s.Pg, mn = s.tD;
s.R$;
var _n = s.Dj;
s.m7;
s.NZ;
s.xo;
var kn = s.ou;
s.qC;
s.mD;
s.Ay;
const _DecafParser = class _DecafParser extends xn {
  get grammarFileName() {
    return "DecafParser.g4";
  }
  get literalNames() {
    return _DecafParser.literalNames;
  }
  get symbolicNames() {
    return _DecafParser.symbolicNames;
  }
  get ruleNames() {
    return _DecafParser.ruleNames;
  }
  get serializedATN() {
    return _DecafParser._serializedATN;
  }
  createFailedPredicateException(predicate, message) {
    return new sn(this, predicate, message);
  }
  constructor(input) {
    super(input);
    this._interp = new Tn(this, _DecafParser._ATN, _DecafParser.DecisionsToDFA, new mn());
  }
  // @RuleVersion(0)
  program() {
    let localctx = new ProgramContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, _DecafParser.RULE_program);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 63;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 1) {
          {
            {
              this.state = 60;
              this.import_decl();
            }
          }
          this.state = 65;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 69;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 1, this._ctx);
        while (_alt !== 2 && _alt !== Ge.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            {
              {
                this.state = 66;
                this.field_decl();
              }
            }
          }
          this.state = 71;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 1, this._ctx);
        }
        this.state = 75;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & 14340) !== 0) {
          {
            {
              this.state = 72;
              this.method_decl();
            }
          }
          this.state = 77;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 78;
        this.match(_DecafParser.EOF);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  import_decl() {
    let localctx = new Import_declContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, _DecafParser.RULE_import_decl);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 80;
        this.match(_DecafParser.IMPORT);
        this.state = 81;
        this.match(_DecafParser.ID);
        this.state = 82;
        this.match(_DecafParser.SEMI);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  field_decl() {
    let localctx = new Field_declContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, _DecafParser.RULE_field_decl);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 84;
        this.type_();
        this.state = 87;
        this._errHandler.sync(this);
        switch (this._interp.adaptivePredict(this._input, 3, this._ctx)) {
          case 1:
            {
              this.state = 85;
              this.match(_DecafParser.ID);
            }
            break;
          case 2:
            {
              this.state = 86;
              this.array_field_decl();
            }
            break;
        }
        this.state = 96;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 37) {
          {
            {
              this.state = 89;
              this.match(_DecafParser.COMMA);
              this.state = 92;
              this._errHandler.sync(this);
              switch (this._interp.adaptivePredict(this._input, 4, this._ctx)) {
                case 1:
                  {
                    this.state = 90;
                    this.match(_DecafParser.ID);
                  }
                  break;
                case 2:
                  {
                    this.state = 91;
                    this.array_field_decl();
                  }
                  break;
              }
            }
          }
          this.state = 98;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 99;
        this.match(_DecafParser.SEMI);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  array_field_decl() {
    let localctx = new Array_field_declContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, _DecafParser.RULE_array_field_decl);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 101;
        this.match(_DecafParser.ID);
        this.state = 102;
        this.match(_DecafParser.LEFT_BRACKET);
        this.state = 103;
        this.int_literal();
        this.state = 104;
        this.match(_DecafParser.RIGHT_BRACKET);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  method_decl() {
    let localctx = new Method_declContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, _DecafParser.RULE_method_decl);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 108;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 11:
          case 12:
          case 13:
            {
              this.state = 106;
              this.type_();
            }
            break;
          case 2:
            {
              this.state = 107;
              this.match(_DecafParser.VOID);
            }
            break;
          default:
            throw new dn(this);
        }
        this.state = 110;
        this.match(_DecafParser.ID);
        this.state = 111;
        this.match(_DecafParser.LEFT_PAREN);
        this.state = 123;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & 14336) !== 0) {
          {
            this.state = 112;
            this.type_();
            this.state = 113;
            this.match(_DecafParser.ID);
            this.state = 120;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 37) {
              {
                {
                  this.state = 114;
                  this.match(_DecafParser.COMMA);
                  this.state = 115;
                  this.type_();
                  this.state = 116;
                  this.match(_DecafParser.ID);
                }
              }
              this.state = 122;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        }
        this.state = 125;
        this.match(_DecafParser.RIGHT_PAREN);
        this.state = 126;
        this.block();
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  block() {
    let localctx = new BlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, _DecafParser.RULE_block);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 128;
        this.match(_DecafParser.LEFT_BRACE);
        this.state = 132;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & 14336) !== 0) {
          {
            {
              this.state = 129;
              this.field_decl();
            }
          }
          this.state = 134;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 138;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & 984) !== 0 || _la === 45) {
          {
            {
              this.state = 135;
              this.statement();
            }
          }
          this.state = 140;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 141;
        this.match(_DecafParser.RIGHT_BRACE);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  type_() {
    let localctx = new TypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, _DecafParser.RULE_type);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 143;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & 14336) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  statement() {
    let localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, _DecafParser.RULE_statement);
    try {
      this.state = 160;
      this._errHandler.sync(this);
      switch (this._interp.adaptivePredict(this._input, 11, this._ctx)) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 145;
            this.location();
            this.state = 146;
            this.assign_expr();
            this.state = 147;
            this.match(_DecafParser.SEMI);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 149;
            this.method_call();
            this.state = 150;
            this.match(_DecafParser.SEMI);
          }
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          {
            this.state = 152;
            this.if_stmt();
          }
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          {
            this.state = 153;
            this.for_stmt();
          }
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          {
            this.state = 154;
            this.while_stmt();
          }
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          {
            this.state = 155;
            this.return_stmt();
          }
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          {
            this.state = 156;
            this.match(_DecafParser.BREAK);
            this.state = 157;
            this.match(_DecafParser.SEMI);
          }
          break;
        case 8:
          this.enterOuterAlt(localctx, 8);
          {
            this.state = 158;
            this.match(_DecafParser.CONTINUE);
            this.state = 159;
            this.match(_DecafParser.SEMI);
          }
          break;
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  if_stmt() {
    let localctx = new If_stmtContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, _DecafParser.RULE_if_stmt);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 162;
        this.match(_DecafParser.IF);
        this.state = 163;
        this.match(_DecafParser.LEFT_PAREN);
        this.state = 164;
        this.expr(0);
        this.state = 165;
        this.match(_DecafParser.RIGHT_PAREN);
        this.state = 166;
        this.block();
        this.state = 169;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === 5) {
          {
            this.state = 167;
            this.match(_DecafParser.ELSE);
            this.state = 168;
            this.block();
          }
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  for_stmt() {
    let localctx = new For_stmtContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, _DecafParser.RULE_for_stmt);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 171;
        this.match(_DecafParser.FOR);
        this.state = 172;
        this.match(_DecafParser.LEFT_PAREN);
        this.state = 173;
        this.match(_DecafParser.ID);
        this.state = 174;
        this.match(_DecafParser.ASSIGN);
        this.state = 175;
        this.expr(0);
        this.state = 176;
        this.match(_DecafParser.SEMI);
        this.state = 177;
        this.expr(0);
        this.state = 178;
        this.match(_DecafParser.SEMI);
        this.state = 179;
        this.for_update();
        this.state = 180;
        this.match(_DecafParser.RIGHT_PAREN);
        this.state = 181;
        this.block();
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  while_stmt() {
    let localctx = new While_stmtContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, _DecafParser.RULE_while_stmt);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 183;
        this.match(_DecafParser.WHILE);
        this.state = 184;
        this.match(_DecafParser.LEFT_PAREN);
        this.state = 185;
        this.expr(0);
        this.state = 186;
        this.match(_DecafParser.RIGHT_PAREN);
        this.state = 187;
        this.block();
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  return_stmt() {
    let localctx = new Return_stmtContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, _DecafParser.RULE_return_stmt);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 189;
        this.match(_DecafParser.RETURN);
        this.state = 191;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & 1610685440) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & 223) !== 0) {
          {
            this.state = 190;
            this.expr(0);
          }
        }
        this.state = 193;
        this.match(_DecafParser.SEMI);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  for_update() {
    let localctx = new For_updateContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, _DecafParser.RULE_for_update);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 195;
        this.location();
        this.state = 196;
        this.assign_expr();
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  assign_expr() {
    let localctx = new Assign_exprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, _DecafParser.RULE_assign_expr);
    try {
      this.state = 202;
      this._errHandler.sync(this);
      switch (this._interp.adaptivePredict(this._input, 14, this._ctx)) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 198;
            this.assign_op();
            this.state = 199;
            this.expr(0);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 201;
            this.increment();
          }
          break;
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  assign_op() {
    let localctx = new Assign_opContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, _DecafParser.RULE_assign_op);
    try {
      this.state = 215;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case 14:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 204;
            this.match(_DecafParser.ASSIGN);
          }
          break;
        case 15:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 205;
            this.match(_DecafParser.PLUS);
            this.state = 206;
            this.match(_DecafParser.ASSIGN);
          }
          break;
        case 16:
          this.enterOuterAlt(localctx, 3);
          {
            this.state = 207;
            this.match(_DecafParser.MINUS);
            this.state = 208;
            this.match(_DecafParser.ASSIGN);
          }
          break;
        case 17:
          this.enterOuterAlt(localctx, 4);
          {
            this.state = 209;
            this.match(_DecafParser.MULTIPLY);
            this.state = 210;
            this.match(_DecafParser.ASSIGN);
          }
          break;
        case 18:
          this.enterOuterAlt(localctx, 5);
          {
            this.state = 211;
            this.match(_DecafParser.DIVIDE);
            this.state = 212;
            this.match(_DecafParser.ASSIGN);
          }
          break;
        case 19:
          this.enterOuterAlt(localctx, 6);
          {
            this.state = 213;
            this.match(_DecafParser.MODULO);
            this.state = 214;
            this.match(_DecafParser.ASSIGN);
          }
          break;
        default:
          throw new dn(this);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  increment() {
    let localctx = new IncrementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, _DecafParser.RULE_increment);
    try {
      this.state = 219;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case 20:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 217;
            this.match(_DecafParser.INCREMENT);
          }
          break;
        case 16:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 218;
            this.decrement();
          }
          break;
        default:
          throw new dn(this);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  decrement() {
    let localctx = new DecrementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, _DecafParser.RULE_decrement);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 221;
        this.match(_DecafParser.MINUS);
        this.state = 222;
        this.match(_DecafParser.MINUS);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  method_call() {
    let localctx = new Method_callContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, _DecafParser.RULE_method_call);
    let _la;
    try {
      this.state = 252;
      this._errHandler.sync(this);
      switch (this._interp.adaptivePredict(this._input, 21, this._ctx)) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 224;
            this.method_name();
            this.state = 225;
            this.match(_DecafParser.LEFT_PAREN);
            this.state = 234;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & 1610685440) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & 223) !== 0) {
              {
                this.state = 226;
                this.expr(0);
                this.state = 231;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 37) {
                  {
                    {
                      this.state = 227;
                      this.match(_DecafParser.COMMA);
                      this.state = 228;
                      this.expr(0);
                    }
                  }
                  this.state = 233;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
              }
            }
            this.state = 236;
            this.match(_DecafParser.RIGHT_PAREN);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 238;
            this.method_name();
            this.state = 239;
            this.match(_DecafParser.LEFT_PAREN);
            this.state = 248;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & 1610685440) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & 255) !== 0) {
              {
                this.state = 240;
                this.extern_arg();
                this.state = 245;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 37) {
                  {
                    {
                      this.state = 241;
                      this.match(_DecafParser.COMMA);
                      this.state = 242;
                      this.extern_arg();
                    }
                  }
                  this.state = 247;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
              }
            }
            this.state = 250;
            this.match(_DecafParser.RIGHT_PAREN);
          }
          break;
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  method_name() {
    let localctx = new Method_nameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, _DecafParser.RULE_method_name);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 254;
        this.match(_DecafParser.ID);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  location() {
    let localctx = new LocationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, _DecafParser.RULE_location);
    try {
      this.state = 262;
      this._errHandler.sync(this);
      switch (this._interp.adaptivePredict(this._input, 22, this._ctx)) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 256;
            this.match(_DecafParser.ID);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          {
            {
              this.state = 257;
              this.match(_DecafParser.ID);
              this.state = 258;
              this.match(_DecafParser.LEFT_BRACKET);
              this.state = 259;
              this.expr(0);
              this.state = 260;
              this.match(_DecafParser.RIGHT_BRACKET);
            }
          }
          break;
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  expr(_p) {
    if (_p === void 0) {
      _p = 0;
    }
    let _parentctx = this._ctx;
    let _parentState = this.state;
    let localctx = new ExprContext(this, this._ctx, _parentState);
    let _prevctx = localctx;
    let _startState = 40;
    this.enterRecursionRule(localctx, 40, _DecafParser.RULE_expr, _p);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 285;
        this._errHandler.sync(this);
        switch (this._interp.adaptivePredict(this._input, 23, this._ctx)) {
          case 1:
            {
              this.state = 265;
              this.match(_DecafParser.LEFT_PAREN);
              this.state = 266;
              this.expr(0);
              this.state = 267;
              this.match(_DecafParser.RIGHT_PAREN);
            }
            break;
          case 2:
            {
              this.state = 269;
              this.match(_DecafParser.MINUS);
              this.state = 270;
              this.expr(13);
            }
            break;
          case 3:
            {
              this.state = 271;
              this.match(_DecafParser.NOT);
              this.state = 272;
              this.expr(12);
            }
            break;
          case 4:
            {
              this.state = 273;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 274;
              this.match(_DecafParser.LEFT_PAREN);
              this.state = 275;
              this.expr(0);
              this.state = 276;
              this.match(_DecafParser.RIGHT_PAREN);
            }
            break;
          case 5:
            {
              this.state = 278;
              this.match(_DecafParser.LEN);
              this.state = 279;
              this.match(_DecafParser.LEFT_PAREN);
              this.state = 280;
              this.match(_DecafParser.ID);
              this.state = 281;
              this.match(_DecafParser.RIGHT_PAREN);
            }
            break;
          case 6:
            {
              this.state = 282;
              this.location();
            }
            break;
          case 7:
            {
              this.state = 283;
              this.method_call();
            }
            break;
          case 8:
            {
              this.state = 284;
              this.literal();
            }
            break;
        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 307;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 25, this._ctx);
        while (_alt !== 2 && _alt !== Ge.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            if (this._parseListeners != null) {
              this.triggerExitRuleEvent();
            }
            _prevctx = localctx;
            {
              this.state = 305;
              this._errHandler.sync(this);
              switch (this._interp.adaptivePredict(this._input, 24, this._ctx)) {
                case 1:
                  {
                    localctx = new ExprContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, _DecafParser.RULE_expr);
                    this.state = 287;
                    if (!this.precpred(this._ctx, 9)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 9)");
                    }
                    this.state = 288;
                    _la = this._input.LA(1);
                    if (!((_la & ~31) === 0 && (1 << _la & 917504) !== 0)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 289;
                    this.expr(10);
                  }
                  break;
                case 2:
                  {
                    localctx = new ExprContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, _DecafParser.RULE_expr);
                    this.state = 290;
                    if (!this.precpred(this._ctx, 8)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 8)");
                    }
                    this.state = 291;
                    _la = this._input.LA(1);
                    if (!(_la === 15 || _la === 16)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 292;
                    this.expr(9);
                  }
                  break;
                case 3:
                  {
                    localctx = new ExprContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, _DecafParser.RULE_expr);
                    this.state = 293;
                    if (!this.precpred(this._ctx, 7)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 7)");
                    }
                    this.state = 294;
                    _la = this._input.LA(1);
                    if (!((_la & ~31) === 0 && (1 << _la & 125829120) !== 0)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 295;
                    this.expr(8);
                  }
                  break;
                case 4:
                  {
                    localctx = new ExprContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, _DecafParser.RULE_expr);
                    this.state = 296;
                    if (!this.precpred(this._ctx, 6)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 6)");
                    }
                    this.state = 297;
                    _la = this._input.LA(1);
                    if (!(_la === 21 || _la === 22)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 298;
                    this.expr(7);
                  }
                  break;
                case 5:
                  {
                    localctx = new ExprContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, _DecafParser.RULE_expr);
                    this.state = 299;
                    if (!this.precpred(this._ctx, 5)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 5)");
                    }
                    this.state = 300;
                    this.match(_DecafParser.AND);
                    this.state = 301;
                    this.expr(6);
                  }
                  break;
                case 6:
                  {
                    localctx = new ExprContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, _DecafParser.RULE_expr);
                    this.state = 302;
                    if (!this.precpred(this._ctx, 4)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 4)");
                    }
                    this.state = 303;
                    this.match(_DecafParser.OR);
                    this.state = 304;
                    this.expr(5);
                  }
                  break;
              }
            }
          }
          this.state = 309;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 25, this._ctx);
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.unrollRecursionContexts(_parentctx);
    }
    return localctx;
  }
  // @RuleVersion(0)
  extern_arg() {
    let localctx = new Extern_argContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, _DecafParser.RULE_extern_arg);
    try {
      this.state = 312;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case 10:
        case 11:
        case 12:
        case 16:
        case 29:
        case 30:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 44:
        case 45:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 310;
            this.expr(0);
          }
          break;
        case 43:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 311;
            this.match(_DecafParser.STRINGLITERAL);
          }
          break;
        default:
          throw new dn(this);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  bin_op() {
    let localctx = new Bin_opContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, _DecafParser.RULE_bin_op);
    try {
      this.state = 318;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 314;
            this.arith_op();
          }
          break;
        case 23:
        case 24:
        case 25:
        case 26:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 315;
            this.rel_op();
          }
          break;
        case 21:
        case 22:
          this.enterOuterAlt(localctx, 3);
          {
            this.state = 316;
            this.eq_op();
          }
          break;
        case 27:
        case 28:
          this.enterOuterAlt(localctx, 4);
          {
            this.state = 317;
            this.cond_op();
          }
          break;
        default:
          throw new dn(this);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  arith_op() {
    let localctx = new Arith_opContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, _DecafParser.RULE_arith_op);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 320;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & 1015808) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  rel_op() {
    let localctx = new Rel_opContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, _DecafParser.RULE_rel_op);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 322;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & 125829120) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  eq_op() {
    let localctx = new Eq_opContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, _DecafParser.RULE_eq_op);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 324;
        _la = this._input.LA(1);
        if (!(_la === 21 || _la === 22)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  cond_op() {
    let localctx = new Cond_opContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, _DecafParser.RULE_cond_op);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 326;
        _la = this._input.LA(1);
        if (!(_la === 27 || _la === 28)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  literal() {
    let localctx = new LiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, _DecafParser.RULE_literal);
    let _la;
    try {
      this.state = 335;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case 16:
        case 40:
        case 41:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 329;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === 16) {
              {
                this.state = 328;
                this.match(_DecafParser.MINUS);
              }
            }
            this.state = 331;
            this.int_literal();
          }
          break;
        case 38:
        case 39:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 332;
            this.long_literal();
          }
          break;
        case 42:
          this.enterOuterAlt(localctx, 3);
          {
            this.state = 333;
            this.match(_DecafParser.CHARLITERAL);
          }
          break;
        case 44:
          this.enterOuterAlt(localctx, 4);
          {
            this.state = 334;
            this.match(_DecafParser.BOOLLITERAL);
          }
          break;
        default:
          throw new dn(this);
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  int_literal() {
    let localctx = new Int_literalContext(this, this._ctx, this.state);
    this.enterRule(localctx, 56, _DecafParser.RULE_int_literal);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 337;
        _la = this._input.LA(1);
        if (!(_la === 40 || _la === 41)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  long_literal() {
    let localctx = new Long_literalContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, _DecafParser.RULE_long_literal);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 339;
        _la = this._input.LA(1);
        if (!(_la === 38 || _la === 39)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re2) {
      if (re2 instanceof _n) {
        localctx.exception = re2;
        this._errHandler.reportError(this, re2);
        this._errHandler.recover(this, re2);
      } else {
        throw re2;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  sempred(localctx, ruleIndex, predIndex) {
    switch (ruleIndex) {
      case 20:
        return this.expr_sempred(localctx, predIndex);
    }
    return true;
  }
  expr_sempred(localctx, predIndex) {
    switch (predIndex) {
      case 0:
        return this.precpred(this._ctx, 9);
      case 1:
        return this.precpred(this._ctx, 8);
      case 2:
        return this.precpred(this._ctx, 7);
      case 3:
        return this.precpred(this._ctx, 6);
      case 4:
        return this.precpred(this._ctx, 5);
      case 5:
        return this.precpred(this._ctx, 4);
    }
    return true;
  }
  static get _ATN() {
    if (!_DecafParser.__ATN) {
      _DecafParser.__ATN = new We().deserialize(_DecafParser._serializedATN);
    }
    return _DecafParser.__ATN;
  }
};
_DecafParser.IMPORT = 1;
_DecafParser.VOID = 2;
_DecafParser.RETURN = 3;
_DecafParser.IF = 4;
_DecafParser.ELSE = 5;
_DecafParser.FOR = 6;
_DecafParser.WHILE = 7;
_DecafParser.BREAK = 8;
_DecafParser.CONTINUE = 9;
_DecafParser.LEN = 10;
_DecafParser.INT = 11;
_DecafParser.LONG = 12;
_DecafParser.BOOL = 13;
_DecafParser.ASSIGN = 14;
_DecafParser.PLUS = 15;
_DecafParser.MINUS = 16;
_DecafParser.MULTIPLY = 17;
_DecafParser.DIVIDE = 18;
_DecafParser.MODULO = 19;
_DecafParser.INCREMENT = 20;
_DecafParser.EQUAL = 21;
_DecafParser.NOT_EQUAL = 22;
_DecafParser.LESS_THAN = 23;
_DecafParser.GREATER_THAN = 24;
_DecafParser.LESS_EQUAL = 25;
_DecafParser.GREATER_EQUAL = 26;
_DecafParser.AND = 27;
_DecafParser.OR = 28;
_DecafParser.NOT = 29;
_DecafParser.LEFT_PAREN = 30;
_DecafParser.RIGHT_PAREN = 31;
_DecafParser.LEFT_BRACE = 32;
_DecafParser.RIGHT_BRACE = 33;
_DecafParser.LEFT_BRACKET = 34;
_DecafParser.RIGHT_BRACKET = 35;
_DecafParser.SEMI = 36;
_DecafParser.COMMA = 37;
_DecafParser.LONGHEXLITERAL = 38;
_DecafParser.LONGDECLITERAL = 39;
_DecafParser.DECIMALLITERAL = 40;
_DecafParser.HEXLITERAL = 41;
_DecafParser.CHARLITERAL = 42;
_DecafParser.STRINGLITERAL = 43;
_DecafParser.BOOLLITERAL = 44;
_DecafParser.ID = 45;
_DecafParser.WS = 46;
_DecafParser.LINE_COMMENT = 47;
_DecafParser.BLOCK_COMMENT = 48;
_DecafParser.EOF = kn.EOF;
_DecafParser.RULE_program = 0;
_DecafParser.RULE_import_decl = 1;
_DecafParser.RULE_field_decl = 2;
_DecafParser.RULE_array_field_decl = 3;
_DecafParser.RULE_method_decl = 4;
_DecafParser.RULE_block = 5;
_DecafParser.RULE_type = 6;
_DecafParser.RULE_statement = 7;
_DecafParser.RULE_if_stmt = 8;
_DecafParser.RULE_for_stmt = 9;
_DecafParser.RULE_while_stmt = 10;
_DecafParser.RULE_return_stmt = 11;
_DecafParser.RULE_for_update = 12;
_DecafParser.RULE_assign_expr = 13;
_DecafParser.RULE_assign_op = 14;
_DecafParser.RULE_increment = 15;
_DecafParser.RULE_decrement = 16;
_DecafParser.RULE_method_call = 17;
_DecafParser.RULE_method_name = 18;
_DecafParser.RULE_location = 19;
_DecafParser.RULE_expr = 20;
_DecafParser.RULE_extern_arg = 21;
_DecafParser.RULE_bin_op = 22;
_DecafParser.RULE_arith_op = 23;
_DecafParser.RULE_rel_op = 24;
_DecafParser.RULE_eq_op = 25;
_DecafParser.RULE_cond_op = 26;
_DecafParser.RULE_literal = 27;
_DecafParser.RULE_int_literal = 28;
_DecafParser.RULE_long_literal = 29;
_DecafParser.literalNames = [
  null,
  "'import'",
  "'void'",
  "'return'",
  "'if'",
  "'else'",
  "'for'",
  "'while'",
  "'break'",
  "'continue'",
  "'len'",
  "'int'",
  "'long'",
  "'bool'",
  "'='",
  "'+'",
  "'-'",
  "'*'",
  "'/'",
  "'%'",
  "'++'",
  "'=='",
  "'!='",
  "'<'",
  "'>'",
  "'<='",
  "'>='",
  "'&&'",
  "'||'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  "';'",
  "','"
];
_DecafParser.symbolicNames = [
  null,
  "IMPORT",
  "VOID",
  "RETURN",
  "IF",
  "ELSE",
  "FOR",
  "WHILE",
  "BREAK",
  "CONTINUE",
  "LEN",
  "INT",
  "LONG",
  "BOOL",
  "ASSIGN",
  "PLUS",
  "MINUS",
  "MULTIPLY",
  "DIVIDE",
  "MODULO",
  "INCREMENT",
  "EQUAL",
  "NOT_EQUAL",
  "LESS_THAN",
  "GREATER_THAN",
  "LESS_EQUAL",
  "GREATER_EQUAL",
  "AND",
  "OR",
  "NOT",
  "LEFT_PAREN",
  "RIGHT_PAREN",
  "LEFT_BRACE",
  "RIGHT_BRACE",
  "LEFT_BRACKET",
  "RIGHT_BRACKET",
  "SEMI",
  "COMMA",
  "LONGHEXLITERAL",
  "LONGDECLITERAL",
  "DECIMALLITERAL",
  "HEXLITERAL",
  "CHARLITERAL",
  "STRINGLITERAL",
  "BOOLLITERAL",
  "ID",
  "WS",
  "LINE_COMMENT",
  "BLOCK_COMMENT"
];
_DecafParser.ruleNames = [
  "program",
  "import_decl",
  "field_decl",
  "array_field_decl",
  "method_decl",
  "block",
  "type",
  "statement",
  "if_stmt",
  "for_stmt",
  "while_stmt",
  "return_stmt",
  "for_update",
  "assign_expr",
  "assign_op",
  "increment",
  "decrement",
  "method_call",
  "method_name",
  "location",
  "expr",
  "extern_arg",
  "bin_op",
  "arith_op",
  "rel_op",
  "eq_op",
  "cond_op",
  "literal",
  "int_literal",
  "long_literal"
];
_DecafParser._serializedATN = [
  4,
  1,
  48,
  342,
  2,
  0,
  7,
  0,
  2,
  1,
  7,
  1,
  2,
  2,
  7,
  2,
  2,
  3,
  7,
  3,
  2,
  4,
  7,
  4,
  2,
  5,
  7,
  5,
  2,
  6,
  7,
  6,
  2,
  7,
  7,
  7,
  2,
  8,
  7,
  8,
  2,
  9,
  7,
  9,
  2,
  10,
  7,
  10,
  2,
  11,
  7,
  11,
  2,
  12,
  7,
  12,
  2,
  13,
  7,
  13,
  2,
  14,
  7,
  14,
  2,
  15,
  7,
  15,
  2,
  16,
  7,
  16,
  2,
  17,
  7,
  17,
  2,
  18,
  7,
  18,
  2,
  19,
  7,
  19,
  2,
  20,
  7,
  20,
  2,
  21,
  7,
  21,
  2,
  22,
  7,
  22,
  2,
  23,
  7,
  23,
  2,
  24,
  7,
  24,
  2,
  25,
  7,
  25,
  2,
  26,
  7,
  26,
  2,
  27,
  7,
  27,
  2,
  28,
  7,
  28,
  2,
  29,
  7,
  29,
  1,
  0,
  5,
  0,
  62,
  8,
  0,
  10,
  0,
  12,
  0,
  65,
  9,
  0,
  1,
  0,
  5,
  0,
  68,
  8,
  0,
  10,
  0,
  12,
  0,
  71,
  9,
  0,
  1,
  0,
  5,
  0,
  74,
  8,
  0,
  10,
  0,
  12,
  0,
  77,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  1,
  2,
  3,
  2,
  88,
  8,
  2,
  1,
  2,
  1,
  2,
  1,
  2,
  3,
  2,
  93,
  8,
  2,
  5,
  2,
  95,
  8,
  2,
  10,
  2,
  12,
  2,
  98,
  9,
  2,
  1,
  2,
  1,
  2,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  4,
  1,
  4,
  3,
  4,
  109,
  8,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  5,
  4,
  119,
  8,
  4,
  10,
  4,
  12,
  4,
  122,
  9,
  4,
  3,
  4,
  124,
  8,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  5,
  1,
  5,
  5,
  5,
  131,
  8,
  5,
  10,
  5,
  12,
  5,
  134,
  9,
  5,
  1,
  5,
  5,
  5,
  137,
  8,
  5,
  10,
  5,
  12,
  5,
  140,
  9,
  5,
  1,
  5,
  1,
  5,
  1,
  6,
  1,
  6,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  3,
  7,
  161,
  8,
  7,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  3,
  8,
  170,
  8,
  8,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  11,
  1,
  11,
  3,
  11,
  192,
  8,
  11,
  1,
  11,
  1,
  11,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  13,
  3,
  13,
  203,
  8,
  13,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  1,
  14,
  3,
  14,
  216,
  8,
  14,
  1,
  15,
  1,
  15,
  3,
  15,
  220,
  8,
  15,
  1,
  16,
  1,
  16,
  1,
  16,
  1,
  17,
  1,
  17,
  1,
  17,
  1,
  17,
  1,
  17,
  5,
  17,
  230,
  8,
  17,
  10,
  17,
  12,
  17,
  233,
  9,
  17,
  3,
  17,
  235,
  8,
  17,
  1,
  17,
  1,
  17,
  1,
  17,
  1,
  17,
  1,
  17,
  1,
  17,
  1,
  17,
  5,
  17,
  244,
  8,
  17,
  10,
  17,
  12,
  17,
  247,
  9,
  17,
  3,
  17,
  249,
  8,
  17,
  1,
  17,
  1,
  17,
  3,
  17,
  253,
  8,
  17,
  1,
  18,
  1,
  18,
  1,
  19,
  1,
  19,
  1,
  19,
  1,
  19,
  1,
  19,
  1,
  19,
  3,
  19,
  263,
  8,
  19,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  3,
  20,
  286,
  8,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  20,
  5,
  20,
  306,
  8,
  20,
  10,
  20,
  12,
  20,
  309,
  9,
  20,
  1,
  21,
  1,
  21,
  3,
  21,
  313,
  8,
  21,
  1,
  22,
  1,
  22,
  1,
  22,
  1,
  22,
  3,
  22,
  319,
  8,
  22,
  1,
  23,
  1,
  23,
  1,
  24,
  1,
  24,
  1,
  25,
  1,
  25,
  1,
  26,
  1,
  26,
  1,
  27,
  3,
  27,
  330,
  8,
  27,
  1,
  27,
  1,
  27,
  1,
  27,
  1,
  27,
  3,
  27,
  336,
  8,
  27,
  1,
  28,
  1,
  28,
  1,
  29,
  1,
  29,
  1,
  29,
  0,
  1,
  40,
  30,
  0,
  2,
  4,
  6,
  8,
  10,
  12,
  14,
  16,
  18,
  20,
  22,
  24,
  26,
  28,
  30,
  32,
  34,
  36,
  38,
  40,
  42,
  44,
  46,
  48,
  50,
  52,
  54,
  56,
  58,
  0,
  10,
  1,
  0,
  11,
  13,
  1,
  0,
  11,
  12,
  1,
  0,
  17,
  19,
  1,
  0,
  15,
  16,
  1,
  0,
  23,
  26,
  1,
  0,
  21,
  22,
  1,
  0,
  15,
  19,
  1,
  0,
  27,
  28,
  1,
  0,
  40,
  41,
  1,
  0,
  38,
  39,
  365,
  0,
  63,
  1,
  0,
  0,
  0,
  2,
  80,
  1,
  0,
  0,
  0,
  4,
  84,
  1,
  0,
  0,
  0,
  6,
  101,
  1,
  0,
  0,
  0,
  8,
  108,
  1,
  0,
  0,
  0,
  10,
  128,
  1,
  0,
  0,
  0,
  12,
  143,
  1,
  0,
  0,
  0,
  14,
  160,
  1,
  0,
  0,
  0,
  16,
  162,
  1,
  0,
  0,
  0,
  18,
  171,
  1,
  0,
  0,
  0,
  20,
  183,
  1,
  0,
  0,
  0,
  22,
  189,
  1,
  0,
  0,
  0,
  24,
  195,
  1,
  0,
  0,
  0,
  26,
  202,
  1,
  0,
  0,
  0,
  28,
  215,
  1,
  0,
  0,
  0,
  30,
  219,
  1,
  0,
  0,
  0,
  32,
  221,
  1,
  0,
  0,
  0,
  34,
  252,
  1,
  0,
  0,
  0,
  36,
  254,
  1,
  0,
  0,
  0,
  38,
  262,
  1,
  0,
  0,
  0,
  40,
  285,
  1,
  0,
  0,
  0,
  42,
  312,
  1,
  0,
  0,
  0,
  44,
  318,
  1,
  0,
  0,
  0,
  46,
  320,
  1,
  0,
  0,
  0,
  48,
  322,
  1,
  0,
  0,
  0,
  50,
  324,
  1,
  0,
  0,
  0,
  52,
  326,
  1,
  0,
  0,
  0,
  54,
  335,
  1,
  0,
  0,
  0,
  56,
  337,
  1,
  0,
  0,
  0,
  58,
  339,
  1,
  0,
  0,
  0,
  60,
  62,
  3,
  2,
  1,
  0,
  61,
  60,
  1,
  0,
  0,
  0,
  62,
  65,
  1,
  0,
  0,
  0,
  63,
  61,
  1,
  0,
  0,
  0,
  63,
  64,
  1,
  0,
  0,
  0,
  64,
  69,
  1,
  0,
  0,
  0,
  65,
  63,
  1,
  0,
  0,
  0,
  66,
  68,
  3,
  4,
  2,
  0,
  67,
  66,
  1,
  0,
  0,
  0,
  68,
  71,
  1,
  0,
  0,
  0,
  69,
  67,
  1,
  0,
  0,
  0,
  69,
  70,
  1,
  0,
  0,
  0,
  70,
  75,
  1,
  0,
  0,
  0,
  71,
  69,
  1,
  0,
  0,
  0,
  72,
  74,
  3,
  8,
  4,
  0,
  73,
  72,
  1,
  0,
  0,
  0,
  74,
  77,
  1,
  0,
  0,
  0,
  75,
  73,
  1,
  0,
  0,
  0,
  75,
  76,
  1,
  0,
  0,
  0,
  76,
  78,
  1,
  0,
  0,
  0,
  77,
  75,
  1,
  0,
  0,
  0,
  78,
  79,
  5,
  0,
  0,
  1,
  79,
  1,
  1,
  0,
  0,
  0,
  80,
  81,
  5,
  1,
  0,
  0,
  81,
  82,
  5,
  45,
  0,
  0,
  82,
  83,
  5,
  36,
  0,
  0,
  83,
  3,
  1,
  0,
  0,
  0,
  84,
  87,
  3,
  12,
  6,
  0,
  85,
  88,
  5,
  45,
  0,
  0,
  86,
  88,
  3,
  6,
  3,
  0,
  87,
  85,
  1,
  0,
  0,
  0,
  87,
  86,
  1,
  0,
  0,
  0,
  88,
  96,
  1,
  0,
  0,
  0,
  89,
  92,
  5,
  37,
  0,
  0,
  90,
  93,
  5,
  45,
  0,
  0,
  91,
  93,
  3,
  6,
  3,
  0,
  92,
  90,
  1,
  0,
  0,
  0,
  92,
  91,
  1,
  0,
  0,
  0,
  93,
  95,
  1,
  0,
  0,
  0,
  94,
  89,
  1,
  0,
  0,
  0,
  95,
  98,
  1,
  0,
  0,
  0,
  96,
  94,
  1,
  0,
  0,
  0,
  96,
  97,
  1,
  0,
  0,
  0,
  97,
  99,
  1,
  0,
  0,
  0,
  98,
  96,
  1,
  0,
  0,
  0,
  99,
  100,
  5,
  36,
  0,
  0,
  100,
  5,
  1,
  0,
  0,
  0,
  101,
  102,
  5,
  45,
  0,
  0,
  102,
  103,
  5,
  34,
  0,
  0,
  103,
  104,
  3,
  56,
  28,
  0,
  104,
  105,
  5,
  35,
  0,
  0,
  105,
  7,
  1,
  0,
  0,
  0,
  106,
  109,
  3,
  12,
  6,
  0,
  107,
  109,
  5,
  2,
  0,
  0,
  108,
  106,
  1,
  0,
  0,
  0,
  108,
  107,
  1,
  0,
  0,
  0,
  109,
  110,
  1,
  0,
  0,
  0,
  110,
  111,
  5,
  45,
  0,
  0,
  111,
  123,
  5,
  30,
  0,
  0,
  112,
  113,
  3,
  12,
  6,
  0,
  113,
  120,
  5,
  45,
  0,
  0,
  114,
  115,
  5,
  37,
  0,
  0,
  115,
  116,
  3,
  12,
  6,
  0,
  116,
  117,
  5,
  45,
  0,
  0,
  117,
  119,
  1,
  0,
  0,
  0,
  118,
  114,
  1,
  0,
  0,
  0,
  119,
  122,
  1,
  0,
  0,
  0,
  120,
  118,
  1,
  0,
  0,
  0,
  120,
  121,
  1,
  0,
  0,
  0,
  121,
  124,
  1,
  0,
  0,
  0,
  122,
  120,
  1,
  0,
  0,
  0,
  123,
  112,
  1,
  0,
  0,
  0,
  123,
  124,
  1,
  0,
  0,
  0,
  124,
  125,
  1,
  0,
  0,
  0,
  125,
  126,
  5,
  31,
  0,
  0,
  126,
  127,
  3,
  10,
  5,
  0,
  127,
  9,
  1,
  0,
  0,
  0,
  128,
  132,
  5,
  32,
  0,
  0,
  129,
  131,
  3,
  4,
  2,
  0,
  130,
  129,
  1,
  0,
  0,
  0,
  131,
  134,
  1,
  0,
  0,
  0,
  132,
  130,
  1,
  0,
  0,
  0,
  132,
  133,
  1,
  0,
  0,
  0,
  133,
  138,
  1,
  0,
  0,
  0,
  134,
  132,
  1,
  0,
  0,
  0,
  135,
  137,
  3,
  14,
  7,
  0,
  136,
  135,
  1,
  0,
  0,
  0,
  137,
  140,
  1,
  0,
  0,
  0,
  138,
  136,
  1,
  0,
  0,
  0,
  138,
  139,
  1,
  0,
  0,
  0,
  139,
  141,
  1,
  0,
  0,
  0,
  140,
  138,
  1,
  0,
  0,
  0,
  141,
  142,
  5,
  33,
  0,
  0,
  142,
  11,
  1,
  0,
  0,
  0,
  143,
  144,
  7,
  0,
  0,
  0,
  144,
  13,
  1,
  0,
  0,
  0,
  145,
  146,
  3,
  38,
  19,
  0,
  146,
  147,
  3,
  26,
  13,
  0,
  147,
  148,
  5,
  36,
  0,
  0,
  148,
  161,
  1,
  0,
  0,
  0,
  149,
  150,
  3,
  34,
  17,
  0,
  150,
  151,
  5,
  36,
  0,
  0,
  151,
  161,
  1,
  0,
  0,
  0,
  152,
  161,
  3,
  16,
  8,
  0,
  153,
  161,
  3,
  18,
  9,
  0,
  154,
  161,
  3,
  20,
  10,
  0,
  155,
  161,
  3,
  22,
  11,
  0,
  156,
  157,
  5,
  8,
  0,
  0,
  157,
  161,
  5,
  36,
  0,
  0,
  158,
  159,
  5,
  9,
  0,
  0,
  159,
  161,
  5,
  36,
  0,
  0,
  160,
  145,
  1,
  0,
  0,
  0,
  160,
  149,
  1,
  0,
  0,
  0,
  160,
  152,
  1,
  0,
  0,
  0,
  160,
  153,
  1,
  0,
  0,
  0,
  160,
  154,
  1,
  0,
  0,
  0,
  160,
  155,
  1,
  0,
  0,
  0,
  160,
  156,
  1,
  0,
  0,
  0,
  160,
  158,
  1,
  0,
  0,
  0,
  161,
  15,
  1,
  0,
  0,
  0,
  162,
  163,
  5,
  4,
  0,
  0,
  163,
  164,
  5,
  30,
  0,
  0,
  164,
  165,
  3,
  40,
  20,
  0,
  165,
  166,
  5,
  31,
  0,
  0,
  166,
  169,
  3,
  10,
  5,
  0,
  167,
  168,
  5,
  5,
  0,
  0,
  168,
  170,
  3,
  10,
  5,
  0,
  169,
  167,
  1,
  0,
  0,
  0,
  169,
  170,
  1,
  0,
  0,
  0,
  170,
  17,
  1,
  0,
  0,
  0,
  171,
  172,
  5,
  6,
  0,
  0,
  172,
  173,
  5,
  30,
  0,
  0,
  173,
  174,
  5,
  45,
  0,
  0,
  174,
  175,
  5,
  14,
  0,
  0,
  175,
  176,
  3,
  40,
  20,
  0,
  176,
  177,
  5,
  36,
  0,
  0,
  177,
  178,
  3,
  40,
  20,
  0,
  178,
  179,
  5,
  36,
  0,
  0,
  179,
  180,
  3,
  24,
  12,
  0,
  180,
  181,
  5,
  31,
  0,
  0,
  181,
  182,
  3,
  10,
  5,
  0,
  182,
  19,
  1,
  0,
  0,
  0,
  183,
  184,
  5,
  7,
  0,
  0,
  184,
  185,
  5,
  30,
  0,
  0,
  185,
  186,
  3,
  40,
  20,
  0,
  186,
  187,
  5,
  31,
  0,
  0,
  187,
  188,
  3,
  10,
  5,
  0,
  188,
  21,
  1,
  0,
  0,
  0,
  189,
  191,
  5,
  3,
  0,
  0,
  190,
  192,
  3,
  40,
  20,
  0,
  191,
  190,
  1,
  0,
  0,
  0,
  191,
  192,
  1,
  0,
  0,
  0,
  192,
  193,
  1,
  0,
  0,
  0,
  193,
  194,
  5,
  36,
  0,
  0,
  194,
  23,
  1,
  0,
  0,
  0,
  195,
  196,
  3,
  38,
  19,
  0,
  196,
  197,
  3,
  26,
  13,
  0,
  197,
  25,
  1,
  0,
  0,
  0,
  198,
  199,
  3,
  28,
  14,
  0,
  199,
  200,
  3,
  40,
  20,
  0,
  200,
  203,
  1,
  0,
  0,
  0,
  201,
  203,
  3,
  30,
  15,
  0,
  202,
  198,
  1,
  0,
  0,
  0,
  202,
  201,
  1,
  0,
  0,
  0,
  203,
  27,
  1,
  0,
  0,
  0,
  204,
  216,
  5,
  14,
  0,
  0,
  205,
  206,
  5,
  15,
  0,
  0,
  206,
  216,
  5,
  14,
  0,
  0,
  207,
  208,
  5,
  16,
  0,
  0,
  208,
  216,
  5,
  14,
  0,
  0,
  209,
  210,
  5,
  17,
  0,
  0,
  210,
  216,
  5,
  14,
  0,
  0,
  211,
  212,
  5,
  18,
  0,
  0,
  212,
  216,
  5,
  14,
  0,
  0,
  213,
  214,
  5,
  19,
  0,
  0,
  214,
  216,
  5,
  14,
  0,
  0,
  215,
  204,
  1,
  0,
  0,
  0,
  215,
  205,
  1,
  0,
  0,
  0,
  215,
  207,
  1,
  0,
  0,
  0,
  215,
  209,
  1,
  0,
  0,
  0,
  215,
  211,
  1,
  0,
  0,
  0,
  215,
  213,
  1,
  0,
  0,
  0,
  216,
  29,
  1,
  0,
  0,
  0,
  217,
  220,
  5,
  20,
  0,
  0,
  218,
  220,
  3,
  32,
  16,
  0,
  219,
  217,
  1,
  0,
  0,
  0,
  219,
  218,
  1,
  0,
  0,
  0,
  220,
  31,
  1,
  0,
  0,
  0,
  221,
  222,
  5,
  16,
  0,
  0,
  222,
  223,
  5,
  16,
  0,
  0,
  223,
  33,
  1,
  0,
  0,
  0,
  224,
  225,
  3,
  36,
  18,
  0,
  225,
  234,
  5,
  30,
  0,
  0,
  226,
  231,
  3,
  40,
  20,
  0,
  227,
  228,
  5,
  37,
  0,
  0,
  228,
  230,
  3,
  40,
  20,
  0,
  229,
  227,
  1,
  0,
  0,
  0,
  230,
  233,
  1,
  0,
  0,
  0,
  231,
  229,
  1,
  0,
  0,
  0,
  231,
  232,
  1,
  0,
  0,
  0,
  232,
  235,
  1,
  0,
  0,
  0,
  233,
  231,
  1,
  0,
  0,
  0,
  234,
  226,
  1,
  0,
  0,
  0,
  234,
  235,
  1,
  0,
  0,
  0,
  235,
  236,
  1,
  0,
  0,
  0,
  236,
  237,
  5,
  31,
  0,
  0,
  237,
  253,
  1,
  0,
  0,
  0,
  238,
  239,
  3,
  36,
  18,
  0,
  239,
  248,
  5,
  30,
  0,
  0,
  240,
  245,
  3,
  42,
  21,
  0,
  241,
  242,
  5,
  37,
  0,
  0,
  242,
  244,
  3,
  42,
  21,
  0,
  243,
  241,
  1,
  0,
  0,
  0,
  244,
  247,
  1,
  0,
  0,
  0,
  245,
  243,
  1,
  0,
  0,
  0,
  245,
  246,
  1,
  0,
  0,
  0,
  246,
  249,
  1,
  0,
  0,
  0,
  247,
  245,
  1,
  0,
  0,
  0,
  248,
  240,
  1,
  0,
  0,
  0,
  248,
  249,
  1,
  0,
  0,
  0,
  249,
  250,
  1,
  0,
  0,
  0,
  250,
  251,
  5,
  31,
  0,
  0,
  251,
  253,
  1,
  0,
  0,
  0,
  252,
  224,
  1,
  0,
  0,
  0,
  252,
  238,
  1,
  0,
  0,
  0,
  253,
  35,
  1,
  0,
  0,
  0,
  254,
  255,
  5,
  45,
  0,
  0,
  255,
  37,
  1,
  0,
  0,
  0,
  256,
  263,
  5,
  45,
  0,
  0,
  257,
  258,
  5,
  45,
  0,
  0,
  258,
  259,
  5,
  34,
  0,
  0,
  259,
  260,
  3,
  40,
  20,
  0,
  260,
  261,
  5,
  35,
  0,
  0,
  261,
  263,
  1,
  0,
  0,
  0,
  262,
  256,
  1,
  0,
  0,
  0,
  262,
  257,
  1,
  0,
  0,
  0,
  263,
  39,
  1,
  0,
  0,
  0,
  264,
  265,
  6,
  20,
  -1,
  0,
  265,
  266,
  5,
  30,
  0,
  0,
  266,
  267,
  3,
  40,
  20,
  0,
  267,
  268,
  5,
  31,
  0,
  0,
  268,
  286,
  1,
  0,
  0,
  0,
  269,
  270,
  5,
  16,
  0,
  0,
  270,
  286,
  3,
  40,
  20,
  13,
  271,
  272,
  5,
  29,
  0,
  0,
  272,
  286,
  3,
  40,
  20,
  12,
  273,
  274,
  7,
  1,
  0,
  0,
  274,
  275,
  5,
  30,
  0,
  0,
  275,
  276,
  3,
  40,
  20,
  0,
  276,
  277,
  5,
  31,
  0,
  0,
  277,
  286,
  1,
  0,
  0,
  0,
  278,
  279,
  5,
  10,
  0,
  0,
  279,
  280,
  5,
  30,
  0,
  0,
  280,
  281,
  5,
  45,
  0,
  0,
  281,
  286,
  5,
  31,
  0,
  0,
  282,
  286,
  3,
  38,
  19,
  0,
  283,
  286,
  3,
  34,
  17,
  0,
  284,
  286,
  3,
  54,
  27,
  0,
  285,
  264,
  1,
  0,
  0,
  0,
  285,
  269,
  1,
  0,
  0,
  0,
  285,
  271,
  1,
  0,
  0,
  0,
  285,
  273,
  1,
  0,
  0,
  0,
  285,
  278,
  1,
  0,
  0,
  0,
  285,
  282,
  1,
  0,
  0,
  0,
  285,
  283,
  1,
  0,
  0,
  0,
  285,
  284,
  1,
  0,
  0,
  0,
  286,
  307,
  1,
  0,
  0,
  0,
  287,
  288,
  10,
  9,
  0,
  0,
  288,
  289,
  7,
  2,
  0,
  0,
  289,
  306,
  3,
  40,
  20,
  10,
  290,
  291,
  10,
  8,
  0,
  0,
  291,
  292,
  7,
  3,
  0,
  0,
  292,
  306,
  3,
  40,
  20,
  9,
  293,
  294,
  10,
  7,
  0,
  0,
  294,
  295,
  7,
  4,
  0,
  0,
  295,
  306,
  3,
  40,
  20,
  8,
  296,
  297,
  10,
  6,
  0,
  0,
  297,
  298,
  7,
  5,
  0,
  0,
  298,
  306,
  3,
  40,
  20,
  7,
  299,
  300,
  10,
  5,
  0,
  0,
  300,
  301,
  5,
  27,
  0,
  0,
  301,
  306,
  3,
  40,
  20,
  6,
  302,
  303,
  10,
  4,
  0,
  0,
  303,
  304,
  5,
  28,
  0,
  0,
  304,
  306,
  3,
  40,
  20,
  5,
  305,
  287,
  1,
  0,
  0,
  0,
  305,
  290,
  1,
  0,
  0,
  0,
  305,
  293,
  1,
  0,
  0,
  0,
  305,
  296,
  1,
  0,
  0,
  0,
  305,
  299,
  1,
  0,
  0,
  0,
  305,
  302,
  1,
  0,
  0,
  0,
  306,
  309,
  1,
  0,
  0,
  0,
  307,
  305,
  1,
  0,
  0,
  0,
  307,
  308,
  1,
  0,
  0,
  0,
  308,
  41,
  1,
  0,
  0,
  0,
  309,
  307,
  1,
  0,
  0,
  0,
  310,
  313,
  3,
  40,
  20,
  0,
  311,
  313,
  5,
  43,
  0,
  0,
  312,
  310,
  1,
  0,
  0,
  0,
  312,
  311,
  1,
  0,
  0,
  0,
  313,
  43,
  1,
  0,
  0,
  0,
  314,
  319,
  3,
  46,
  23,
  0,
  315,
  319,
  3,
  48,
  24,
  0,
  316,
  319,
  3,
  50,
  25,
  0,
  317,
  319,
  3,
  52,
  26,
  0,
  318,
  314,
  1,
  0,
  0,
  0,
  318,
  315,
  1,
  0,
  0,
  0,
  318,
  316,
  1,
  0,
  0,
  0,
  318,
  317,
  1,
  0,
  0,
  0,
  319,
  45,
  1,
  0,
  0,
  0,
  320,
  321,
  7,
  6,
  0,
  0,
  321,
  47,
  1,
  0,
  0,
  0,
  322,
  323,
  7,
  4,
  0,
  0,
  323,
  49,
  1,
  0,
  0,
  0,
  324,
  325,
  7,
  5,
  0,
  0,
  325,
  51,
  1,
  0,
  0,
  0,
  326,
  327,
  7,
  7,
  0,
  0,
  327,
  53,
  1,
  0,
  0,
  0,
  328,
  330,
  5,
  16,
  0,
  0,
  329,
  328,
  1,
  0,
  0,
  0,
  329,
  330,
  1,
  0,
  0,
  0,
  330,
  331,
  1,
  0,
  0,
  0,
  331,
  336,
  3,
  56,
  28,
  0,
  332,
  336,
  3,
  58,
  29,
  0,
  333,
  336,
  5,
  42,
  0,
  0,
  334,
  336,
  5,
  44,
  0,
  0,
  335,
  329,
  1,
  0,
  0,
  0,
  335,
  332,
  1,
  0,
  0,
  0,
  335,
  333,
  1,
  0,
  0,
  0,
  335,
  334,
  1,
  0,
  0,
  0,
  336,
  55,
  1,
  0,
  0,
  0,
  337,
  338,
  7,
  8,
  0,
  0,
  338,
  57,
  1,
  0,
  0,
  0,
  339,
  340,
  7,
  9,
  0,
  0,
  340,
  59,
  1,
  0,
  0,
  0,
  30,
  63,
  69,
  75,
  87,
  92,
  96,
  108,
  120,
  123,
  132,
  138,
  160,
  169,
  191,
  202,
  215,
  219,
  231,
  234,
  245,
  248,
  252,
  262,
  285,
  305,
  307,
  312,
  318,
  329,
  335
];
_DecafParser.DecisionsToDFA = _DecafParser._ATN.decisionToState.map((ds, index) => new Qe(ds, index));
let DecafParser = _DecafParser;
class ProgramContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  EOF() {
    return this.getToken(DecafParser.EOF, 0);
  }
  import_decl_list() {
    return this.getTypedRuleContexts(Import_declContext);
  }
  import_decl(i2) {
    return this.getTypedRuleContext(Import_declContext, i2);
  }
  field_decl_list() {
    return this.getTypedRuleContexts(Field_declContext);
  }
  field_decl(i2) {
    return this.getTypedRuleContext(Field_declContext, i2);
  }
  method_decl_list() {
    return this.getTypedRuleContexts(Method_declContext);
  }
  method_decl(i2) {
    return this.getTypedRuleContext(Method_declContext, i2);
  }
  get ruleIndex() {
    return DecafParser.RULE_program;
  }
  enterRule(listener) {
    if (listener.enterProgram) {
      listener.enterProgram(this);
    }
  }
  exitRule(listener) {
    if (listener.exitProgram) {
      listener.exitProgram(this);
    }
  }
}
class Import_declContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  IMPORT() {
    return this.getToken(DecafParser.IMPORT, 0);
  }
  ID() {
    return this.getToken(DecafParser.ID, 0);
  }
  SEMI() {
    return this.getToken(DecafParser.SEMI, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_import_decl;
  }
  enterRule(listener) {
    if (listener.enterImport_decl) {
      listener.enterImport_decl(this);
    }
  }
  exitRule(listener) {
    if (listener.exitImport_decl) {
      listener.exitImport_decl(this);
    }
  }
}
class Field_declContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  type_() {
    return this.getTypedRuleContext(TypeContext, 0);
  }
  SEMI() {
    return this.getToken(DecafParser.SEMI, 0);
  }
  ID_list() {
    return this.getTokens(DecafParser.ID);
  }
  ID(i2) {
    return this.getToken(DecafParser.ID, i2);
  }
  array_field_decl_list() {
    return this.getTypedRuleContexts(Array_field_declContext);
  }
  array_field_decl(i2) {
    return this.getTypedRuleContext(Array_field_declContext, i2);
  }
  COMMA_list() {
    return this.getTokens(DecafParser.COMMA);
  }
  COMMA(i2) {
    return this.getToken(DecafParser.COMMA, i2);
  }
  get ruleIndex() {
    return DecafParser.RULE_field_decl;
  }
  enterRule(listener) {
    if (listener.enterField_decl) {
      listener.enterField_decl(this);
    }
  }
  exitRule(listener) {
    if (listener.exitField_decl) {
      listener.exitField_decl(this);
    }
  }
}
class Array_field_declContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  ID() {
    return this.getToken(DecafParser.ID, 0);
  }
  LEFT_BRACKET() {
    return this.getToken(DecafParser.LEFT_BRACKET, 0);
  }
  int_literal() {
    return this.getTypedRuleContext(Int_literalContext, 0);
  }
  RIGHT_BRACKET() {
    return this.getToken(DecafParser.RIGHT_BRACKET, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_array_field_decl;
  }
  enterRule(listener) {
    if (listener.enterArray_field_decl) {
      listener.enterArray_field_decl(this);
    }
  }
  exitRule(listener) {
    if (listener.exitArray_field_decl) {
      listener.exitArray_field_decl(this);
    }
  }
}
class Method_declContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  ID_list() {
    return this.getTokens(DecafParser.ID);
  }
  ID(i2) {
    return this.getToken(DecafParser.ID, i2);
  }
  LEFT_PAREN() {
    return this.getToken(DecafParser.LEFT_PAREN, 0);
  }
  RIGHT_PAREN() {
    return this.getToken(DecafParser.RIGHT_PAREN, 0);
  }
  block() {
    return this.getTypedRuleContext(BlockContext, 0);
  }
  type__list() {
    return this.getTypedRuleContexts(TypeContext);
  }
  type_(i2) {
    return this.getTypedRuleContext(TypeContext, i2);
  }
  VOID() {
    return this.getToken(DecafParser.VOID, 0);
  }
  COMMA_list() {
    return this.getTokens(DecafParser.COMMA);
  }
  COMMA(i2) {
    return this.getToken(DecafParser.COMMA, i2);
  }
  get ruleIndex() {
    return DecafParser.RULE_method_decl;
  }
  enterRule(listener) {
    if (listener.enterMethod_decl) {
      listener.enterMethod_decl(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMethod_decl) {
      listener.exitMethod_decl(this);
    }
  }
}
class BlockContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  LEFT_BRACE() {
    return this.getToken(DecafParser.LEFT_BRACE, 0);
  }
  RIGHT_BRACE() {
    return this.getToken(DecafParser.RIGHT_BRACE, 0);
  }
  field_decl_list() {
    return this.getTypedRuleContexts(Field_declContext);
  }
  field_decl(i2) {
    return this.getTypedRuleContext(Field_declContext, i2);
  }
  statement_list() {
    return this.getTypedRuleContexts(StatementContext);
  }
  statement(i2) {
    return this.getTypedRuleContext(StatementContext, i2);
  }
  get ruleIndex() {
    return DecafParser.RULE_block;
  }
  enterRule(listener) {
    if (listener.enterBlock) {
      listener.enterBlock(this);
    }
  }
  exitRule(listener) {
    if (listener.exitBlock) {
      listener.exitBlock(this);
    }
  }
}
class TypeContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  INT() {
    return this.getToken(DecafParser.INT, 0);
  }
  LONG() {
    return this.getToken(DecafParser.LONG, 0);
  }
  BOOL() {
    return this.getToken(DecafParser.BOOL, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_type;
  }
  enterRule(listener) {
    if (listener.enterType) {
      listener.enterType(this);
    }
  }
  exitRule(listener) {
    if (listener.exitType) {
      listener.exitType(this);
    }
  }
}
class StatementContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  location() {
    return this.getTypedRuleContext(LocationContext, 0);
  }
  assign_expr() {
    return this.getTypedRuleContext(Assign_exprContext, 0);
  }
  SEMI() {
    return this.getToken(DecafParser.SEMI, 0);
  }
  method_call() {
    return this.getTypedRuleContext(Method_callContext, 0);
  }
  if_stmt() {
    return this.getTypedRuleContext(If_stmtContext, 0);
  }
  for_stmt() {
    return this.getTypedRuleContext(For_stmtContext, 0);
  }
  while_stmt() {
    return this.getTypedRuleContext(While_stmtContext, 0);
  }
  return_stmt() {
    return this.getTypedRuleContext(Return_stmtContext, 0);
  }
  BREAK() {
    return this.getToken(DecafParser.BREAK, 0);
  }
  CONTINUE() {
    return this.getToken(DecafParser.CONTINUE, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_statement;
  }
  enterRule(listener) {
    if (listener.enterStatement) {
      listener.enterStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStatement) {
      listener.exitStatement(this);
    }
  }
}
class If_stmtContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  IF() {
    return this.getToken(DecafParser.IF, 0);
  }
  LEFT_PAREN() {
    return this.getToken(DecafParser.LEFT_PAREN, 0);
  }
  expr() {
    return this.getTypedRuleContext(ExprContext, 0);
  }
  RIGHT_PAREN() {
    return this.getToken(DecafParser.RIGHT_PAREN, 0);
  }
  block_list() {
    return this.getTypedRuleContexts(BlockContext);
  }
  block(i2) {
    return this.getTypedRuleContext(BlockContext, i2);
  }
  ELSE() {
    return this.getToken(DecafParser.ELSE, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_if_stmt;
  }
  enterRule(listener) {
    if (listener.enterIf_stmt) {
      listener.enterIf_stmt(this);
    }
  }
  exitRule(listener) {
    if (listener.exitIf_stmt) {
      listener.exitIf_stmt(this);
    }
  }
}
class For_stmtContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  FOR() {
    return this.getToken(DecafParser.FOR, 0);
  }
  LEFT_PAREN() {
    return this.getToken(DecafParser.LEFT_PAREN, 0);
  }
  ID() {
    return this.getToken(DecafParser.ID, 0);
  }
  ASSIGN() {
    return this.getToken(DecafParser.ASSIGN, 0);
  }
  expr_list() {
    return this.getTypedRuleContexts(ExprContext);
  }
  expr(i2) {
    return this.getTypedRuleContext(ExprContext, i2);
  }
  SEMI_list() {
    return this.getTokens(DecafParser.SEMI);
  }
  SEMI(i2) {
    return this.getToken(DecafParser.SEMI, i2);
  }
  for_update() {
    return this.getTypedRuleContext(For_updateContext, 0);
  }
  RIGHT_PAREN() {
    return this.getToken(DecafParser.RIGHT_PAREN, 0);
  }
  block() {
    return this.getTypedRuleContext(BlockContext, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_for_stmt;
  }
  enterRule(listener) {
    if (listener.enterFor_stmt) {
      listener.enterFor_stmt(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFor_stmt) {
      listener.exitFor_stmt(this);
    }
  }
}
class While_stmtContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  WHILE() {
    return this.getToken(DecafParser.WHILE, 0);
  }
  LEFT_PAREN() {
    return this.getToken(DecafParser.LEFT_PAREN, 0);
  }
  expr() {
    return this.getTypedRuleContext(ExprContext, 0);
  }
  RIGHT_PAREN() {
    return this.getToken(DecafParser.RIGHT_PAREN, 0);
  }
  block() {
    return this.getTypedRuleContext(BlockContext, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_while_stmt;
  }
  enterRule(listener) {
    if (listener.enterWhile_stmt) {
      listener.enterWhile_stmt(this);
    }
  }
  exitRule(listener) {
    if (listener.exitWhile_stmt) {
      listener.exitWhile_stmt(this);
    }
  }
}
class Return_stmtContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  RETURN() {
    return this.getToken(DecafParser.RETURN, 0);
  }
  SEMI() {
    return this.getToken(DecafParser.SEMI, 0);
  }
  expr() {
    return this.getTypedRuleContext(ExprContext, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_return_stmt;
  }
  enterRule(listener) {
    if (listener.enterReturn_stmt) {
      listener.enterReturn_stmt(this);
    }
  }
  exitRule(listener) {
    if (listener.exitReturn_stmt) {
      listener.exitReturn_stmt(this);
    }
  }
}
class For_updateContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  location() {
    return this.getTypedRuleContext(LocationContext, 0);
  }
  assign_expr() {
    return this.getTypedRuleContext(Assign_exprContext, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_for_update;
  }
  enterRule(listener) {
    if (listener.enterFor_update) {
      listener.enterFor_update(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFor_update) {
      listener.exitFor_update(this);
    }
  }
}
class Assign_exprContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  assign_op() {
    return this.getTypedRuleContext(Assign_opContext, 0);
  }
  expr() {
    return this.getTypedRuleContext(ExprContext, 0);
  }
  increment() {
    return this.getTypedRuleContext(IncrementContext, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_assign_expr;
  }
  enterRule(listener) {
    if (listener.enterAssign_expr) {
      listener.enterAssign_expr(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssign_expr) {
      listener.exitAssign_expr(this);
    }
  }
}
class Assign_opContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  ASSIGN() {
    return this.getToken(DecafParser.ASSIGN, 0);
  }
  PLUS() {
    return this.getToken(DecafParser.PLUS, 0);
  }
  MINUS() {
    return this.getToken(DecafParser.MINUS, 0);
  }
  MULTIPLY() {
    return this.getToken(DecafParser.MULTIPLY, 0);
  }
  DIVIDE() {
    return this.getToken(DecafParser.DIVIDE, 0);
  }
  MODULO() {
    return this.getToken(DecafParser.MODULO, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_assign_op;
  }
  enterRule(listener) {
    if (listener.enterAssign_op) {
      listener.enterAssign_op(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssign_op) {
      listener.exitAssign_op(this);
    }
  }
}
class IncrementContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  INCREMENT() {
    return this.getToken(DecafParser.INCREMENT, 0);
  }
  decrement() {
    return this.getTypedRuleContext(DecrementContext, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_increment;
  }
  enterRule(listener) {
    if (listener.enterIncrement) {
      listener.enterIncrement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitIncrement) {
      listener.exitIncrement(this);
    }
  }
}
class DecrementContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  MINUS_list() {
    return this.getTokens(DecafParser.MINUS);
  }
  MINUS(i2) {
    return this.getToken(DecafParser.MINUS, i2);
  }
  get ruleIndex() {
    return DecafParser.RULE_decrement;
  }
  enterRule(listener) {
    if (listener.enterDecrement) {
      listener.enterDecrement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitDecrement) {
      listener.exitDecrement(this);
    }
  }
}
class Method_callContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  method_name() {
    return this.getTypedRuleContext(Method_nameContext, 0);
  }
  LEFT_PAREN() {
    return this.getToken(DecafParser.LEFT_PAREN, 0);
  }
  RIGHT_PAREN() {
    return this.getToken(DecafParser.RIGHT_PAREN, 0);
  }
  expr_list() {
    return this.getTypedRuleContexts(ExprContext);
  }
  expr(i2) {
    return this.getTypedRuleContext(ExprContext, i2);
  }
  COMMA_list() {
    return this.getTokens(DecafParser.COMMA);
  }
  COMMA(i2) {
    return this.getToken(DecafParser.COMMA, i2);
  }
  extern_arg_list() {
    return this.getTypedRuleContexts(Extern_argContext);
  }
  extern_arg(i2) {
    return this.getTypedRuleContext(Extern_argContext, i2);
  }
  get ruleIndex() {
    return DecafParser.RULE_method_call;
  }
  enterRule(listener) {
    if (listener.enterMethod_call) {
      listener.enterMethod_call(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMethod_call) {
      listener.exitMethod_call(this);
    }
  }
}
class Method_nameContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  ID() {
    return this.getToken(DecafParser.ID, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_method_name;
  }
  enterRule(listener) {
    if (listener.enterMethod_name) {
      listener.enterMethod_name(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMethod_name) {
      listener.exitMethod_name(this);
    }
  }
}
class LocationContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  ID() {
    return this.getToken(DecafParser.ID, 0);
  }
  LEFT_BRACKET() {
    return this.getToken(DecafParser.LEFT_BRACKET, 0);
  }
  expr() {
    return this.getTypedRuleContext(ExprContext, 0);
  }
  RIGHT_BRACKET() {
    return this.getToken(DecafParser.RIGHT_BRACKET, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_location;
  }
  enterRule(listener) {
    if (listener.enterLocation) {
      listener.enterLocation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitLocation) {
      listener.exitLocation(this);
    }
  }
}
class ExprContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  LEFT_PAREN() {
    return this.getToken(DecafParser.LEFT_PAREN, 0);
  }
  expr_list() {
    return this.getTypedRuleContexts(ExprContext);
  }
  expr(i2) {
    return this.getTypedRuleContext(ExprContext, i2);
  }
  RIGHT_PAREN() {
    return this.getToken(DecafParser.RIGHT_PAREN, 0);
  }
  MINUS() {
    return this.getToken(DecafParser.MINUS, 0);
  }
  NOT() {
    return this.getToken(DecafParser.NOT, 0);
  }
  INT() {
    return this.getToken(DecafParser.INT, 0);
  }
  LONG() {
    return this.getToken(DecafParser.LONG, 0);
  }
  LEN() {
    return this.getToken(DecafParser.LEN, 0);
  }
  ID() {
    return this.getToken(DecafParser.ID, 0);
  }
  location() {
    return this.getTypedRuleContext(LocationContext, 0);
  }
  method_call() {
    return this.getTypedRuleContext(Method_callContext, 0);
  }
  literal() {
    return this.getTypedRuleContext(LiteralContext, 0);
  }
  MULTIPLY() {
    return this.getToken(DecafParser.MULTIPLY, 0);
  }
  DIVIDE() {
    return this.getToken(DecafParser.DIVIDE, 0);
  }
  MODULO() {
    return this.getToken(DecafParser.MODULO, 0);
  }
  PLUS() {
    return this.getToken(DecafParser.PLUS, 0);
  }
  LESS_THAN() {
    return this.getToken(DecafParser.LESS_THAN, 0);
  }
  GREATER_THAN() {
    return this.getToken(DecafParser.GREATER_THAN, 0);
  }
  LESS_EQUAL() {
    return this.getToken(DecafParser.LESS_EQUAL, 0);
  }
  GREATER_EQUAL() {
    return this.getToken(DecafParser.GREATER_EQUAL, 0);
  }
  EQUAL() {
    return this.getToken(DecafParser.EQUAL, 0);
  }
  NOT_EQUAL() {
    return this.getToken(DecafParser.NOT_EQUAL, 0);
  }
  AND() {
    return this.getToken(DecafParser.AND, 0);
  }
  OR() {
    return this.getToken(DecafParser.OR, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_expr;
  }
  enterRule(listener) {
    if (listener.enterExpr) {
      listener.enterExpr(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExpr) {
      listener.exitExpr(this);
    }
  }
}
class Extern_argContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  expr() {
    return this.getTypedRuleContext(ExprContext, 0);
  }
  STRINGLITERAL() {
    return this.getToken(DecafParser.STRINGLITERAL, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_extern_arg;
  }
  enterRule(listener) {
    if (listener.enterExtern_arg) {
      listener.enterExtern_arg(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExtern_arg) {
      listener.exitExtern_arg(this);
    }
  }
}
class Bin_opContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  arith_op() {
    return this.getTypedRuleContext(Arith_opContext, 0);
  }
  rel_op() {
    return this.getTypedRuleContext(Rel_opContext, 0);
  }
  eq_op() {
    return this.getTypedRuleContext(Eq_opContext, 0);
  }
  cond_op() {
    return this.getTypedRuleContext(Cond_opContext, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_bin_op;
  }
  enterRule(listener) {
    if (listener.enterBin_op) {
      listener.enterBin_op(this);
    }
  }
  exitRule(listener) {
    if (listener.exitBin_op) {
      listener.exitBin_op(this);
    }
  }
}
class Arith_opContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  PLUS() {
    return this.getToken(DecafParser.PLUS, 0);
  }
  MINUS() {
    return this.getToken(DecafParser.MINUS, 0);
  }
  MULTIPLY() {
    return this.getToken(DecafParser.MULTIPLY, 0);
  }
  DIVIDE() {
    return this.getToken(DecafParser.DIVIDE, 0);
  }
  MODULO() {
    return this.getToken(DecafParser.MODULO, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_arith_op;
  }
  enterRule(listener) {
    if (listener.enterArith_op) {
      listener.enterArith_op(this);
    }
  }
  exitRule(listener) {
    if (listener.exitArith_op) {
      listener.exitArith_op(this);
    }
  }
}
class Rel_opContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  LESS_THAN() {
    return this.getToken(DecafParser.LESS_THAN, 0);
  }
  GREATER_THAN() {
    return this.getToken(DecafParser.GREATER_THAN, 0);
  }
  LESS_EQUAL() {
    return this.getToken(DecafParser.LESS_EQUAL, 0);
  }
  GREATER_EQUAL() {
    return this.getToken(DecafParser.GREATER_EQUAL, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_rel_op;
  }
  enterRule(listener) {
    if (listener.enterRel_op) {
      listener.enterRel_op(this);
    }
  }
  exitRule(listener) {
    if (listener.exitRel_op) {
      listener.exitRel_op(this);
    }
  }
}
class Eq_opContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  EQUAL() {
    return this.getToken(DecafParser.EQUAL, 0);
  }
  NOT_EQUAL() {
    return this.getToken(DecafParser.NOT_EQUAL, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_eq_op;
  }
  enterRule(listener) {
    if (listener.enterEq_op) {
      listener.enterEq_op(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEq_op) {
      listener.exitEq_op(this);
    }
  }
}
class Cond_opContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  AND() {
    return this.getToken(DecafParser.AND, 0);
  }
  OR() {
    return this.getToken(DecafParser.OR, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_cond_op;
  }
  enterRule(listener) {
    if (listener.enterCond_op) {
      listener.enterCond_op(this);
    }
  }
  exitRule(listener) {
    if (listener.exitCond_op) {
      listener.exitCond_op(this);
    }
  }
}
class LiteralContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  int_literal() {
    return this.getTypedRuleContext(Int_literalContext, 0);
  }
  MINUS() {
    return this.getToken(DecafParser.MINUS, 0);
  }
  long_literal() {
    return this.getTypedRuleContext(Long_literalContext, 0);
  }
  CHARLITERAL() {
    return this.getToken(DecafParser.CHARLITERAL, 0);
  }
  BOOLLITERAL() {
    return this.getToken(DecafParser.BOOLLITERAL, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_literal;
  }
  enterRule(listener) {
    if (listener.enterLiteral) {
      listener.enterLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitLiteral) {
      listener.exitLiteral(this);
    }
  }
}
class Int_literalContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  DECIMALLITERAL() {
    return this.getToken(DecafParser.DECIMALLITERAL, 0);
  }
  HEXLITERAL() {
    return this.getToken(DecafParser.HEXLITERAL, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_int_literal;
  }
  enterRule(listener) {
    if (listener.enterInt_literal) {
      listener.enterInt_literal(this);
    }
  }
  exitRule(listener) {
    if (listener.exitInt_literal) {
      listener.exitInt_literal(this);
    }
  }
}
class Long_literalContext extends Sn {
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  LONGDECLITERAL() {
    return this.getToken(DecafParser.LONGDECLITERAL, 0);
  }
  LONGHEXLITERAL() {
    return this.getToken(DecafParser.LONGHEXLITERAL, 0);
  }
  get ruleIndex() {
    return DecafParser.RULE_long_literal;
  }
  enterRule(listener) {
    if (listener.enterLong_literal) {
      listener.enterLong_literal(this);
    }
  }
  exitRule(listener) {
    if (listener.exitLong_literal) {
      listener.exitLong_literal(this);
    }
  }
}
const _DecafLexer = class _DecafLexer extends cn {
  constructor(input) {
    super(input);
    this._interp = new un(this, _DecafLexer._ATN, _DecafLexer.DecisionsToDFA, new mn());
  }
  get grammarFileName() {
    return "DecafLexer.g4";
  }
  get literalNames() {
    return _DecafLexer.literalNames;
  }
  get symbolicNames() {
    return _DecafLexer.symbolicNames;
  }
  get ruleNames() {
    return _DecafLexer.ruleNames;
  }
  get serializedATN() {
    return _DecafLexer._serializedATN;
  }
  get channelNames() {
    return _DecafLexer.channelNames;
  }
  get modeNames() {
    return _DecafLexer.modeNames;
  }
  static get _ATN() {
    if (!_DecafLexer.__ATN) {
      _DecafLexer.__ATN = new We().deserialize(_DecafLexer._serializedATN);
    }
    return _DecafLexer.__ATN;
  }
};
_DecafLexer.IMPORT = 1;
_DecafLexer.VOID = 2;
_DecafLexer.RETURN = 3;
_DecafLexer.IF = 4;
_DecafLexer.ELSE = 5;
_DecafLexer.FOR = 6;
_DecafLexer.WHILE = 7;
_DecafLexer.BREAK = 8;
_DecafLexer.CONTINUE = 9;
_DecafLexer.LEN = 10;
_DecafLexer.INT = 11;
_DecafLexer.LONG = 12;
_DecafLexer.BOOL = 13;
_DecafLexer.ASSIGN = 14;
_DecafLexer.PLUS = 15;
_DecafLexer.MINUS = 16;
_DecafLexer.MULTIPLY = 17;
_DecafLexer.DIVIDE = 18;
_DecafLexer.MODULO = 19;
_DecafLexer.INCREMENT = 20;
_DecafLexer.EQUAL = 21;
_DecafLexer.NOT_EQUAL = 22;
_DecafLexer.LESS_THAN = 23;
_DecafLexer.GREATER_THAN = 24;
_DecafLexer.LESS_EQUAL = 25;
_DecafLexer.GREATER_EQUAL = 26;
_DecafLexer.AND = 27;
_DecafLexer.OR = 28;
_DecafLexer.NOT = 29;
_DecafLexer.LEFT_PAREN = 30;
_DecafLexer.RIGHT_PAREN = 31;
_DecafLexer.LEFT_BRACE = 32;
_DecafLexer.RIGHT_BRACE = 33;
_DecafLexer.LEFT_BRACKET = 34;
_DecafLexer.RIGHT_BRACKET = 35;
_DecafLexer.SEMI = 36;
_DecafLexer.COMMA = 37;
_DecafLexer.LONGHEXLITERAL = 38;
_DecafLexer.LONGDECLITERAL = 39;
_DecafLexer.DECIMALLITERAL = 40;
_DecafLexer.HEXLITERAL = 41;
_DecafLexer.CHARLITERAL = 42;
_DecafLexer.STRINGLITERAL = 43;
_DecafLexer.BOOLLITERAL = 44;
_DecafLexer.ID = 45;
_DecafLexer.WS = 46;
_DecafLexer.LINE_COMMENT = 47;
_DecafLexer.BLOCK_COMMENT = 48;
_DecafLexer.EOF = kn.EOF;
_DecafLexer.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
_DecafLexer.literalNames = [
  null,
  "'import'",
  "'void'",
  "'return'",
  "'if'",
  "'else'",
  "'for'",
  "'while'",
  "'break'",
  "'continue'",
  "'len'",
  "'int'",
  "'long'",
  "'bool'",
  "'='",
  "'+'",
  "'-'",
  "'*'",
  "'/'",
  "'%'",
  "'++'",
  "'=='",
  "'!='",
  "'<'",
  "'>'",
  "'<='",
  "'>='",
  "'&&'",
  "'||'",
  "'!'",
  "'('",
  "')'",
  "'{'",
  "'}'",
  "'['",
  "']'",
  "';'",
  "','"
];
_DecafLexer.symbolicNames = [
  null,
  "IMPORT",
  "VOID",
  "RETURN",
  "IF",
  "ELSE",
  "FOR",
  "WHILE",
  "BREAK",
  "CONTINUE",
  "LEN",
  "INT",
  "LONG",
  "BOOL",
  "ASSIGN",
  "PLUS",
  "MINUS",
  "MULTIPLY",
  "DIVIDE",
  "MODULO",
  "INCREMENT",
  "EQUAL",
  "NOT_EQUAL",
  "LESS_THAN",
  "GREATER_THAN",
  "LESS_EQUAL",
  "GREATER_EQUAL",
  "AND",
  "OR",
  "NOT",
  "LEFT_PAREN",
  "RIGHT_PAREN",
  "LEFT_BRACE",
  "RIGHT_BRACE",
  "LEFT_BRACKET",
  "RIGHT_BRACKET",
  "SEMI",
  "COMMA",
  "LONGHEXLITERAL",
  "LONGDECLITERAL",
  "DECIMALLITERAL",
  "HEXLITERAL",
  "CHARLITERAL",
  "STRINGLITERAL",
  "BOOLLITERAL",
  "ID",
  "WS",
  "LINE_COMMENT",
  "BLOCK_COMMENT"
];
_DecafLexer.modeNames = ["DEFAULT_MODE"];
_DecafLexer.ruleNames = [
  "IMPORT",
  "VOID",
  "RETURN",
  "IF",
  "ELSE",
  "FOR",
  "WHILE",
  "BREAK",
  "CONTINUE",
  "LEN",
  "INT",
  "LONG",
  "BOOL",
  "ASSIGN",
  "PLUS",
  "MINUS",
  "MULTIPLY",
  "DIVIDE",
  "MODULO",
  "INCREMENT",
  "EQUAL",
  "NOT_EQUAL",
  "LESS_THAN",
  "GREATER_THAN",
  "LESS_EQUAL",
  "GREATER_EQUAL",
  "AND",
  "OR",
  "NOT",
  "LEFT_PAREN",
  "RIGHT_PAREN",
  "LEFT_BRACE",
  "RIGHT_BRACE",
  "LEFT_BRACKET",
  "RIGHT_BRACKET",
  "SEMI",
  "COMMA",
  "LONGHEXLITERAL",
  "LONGDECLITERAL",
  "DECIMALLITERAL",
  "HEXLITERAL",
  "CHARLITERAL",
  "ESCAPE_SEQUENCE",
  "STRINGLITERAL",
  "BOOLLITERAL",
  "ID",
  "WS",
  "LINE_COMMENT",
  "BLOCK_COMMENT"
];
_DecafLexer._serializedATN = [
  4,
  0,
  48,
  324,
  6,
  -1,
  2,
  0,
  7,
  0,
  2,
  1,
  7,
  1,
  2,
  2,
  7,
  2,
  2,
  3,
  7,
  3,
  2,
  4,
  7,
  4,
  2,
  5,
  7,
  5,
  2,
  6,
  7,
  6,
  2,
  7,
  7,
  7,
  2,
  8,
  7,
  8,
  2,
  9,
  7,
  9,
  2,
  10,
  7,
  10,
  2,
  11,
  7,
  11,
  2,
  12,
  7,
  12,
  2,
  13,
  7,
  13,
  2,
  14,
  7,
  14,
  2,
  15,
  7,
  15,
  2,
  16,
  7,
  16,
  2,
  17,
  7,
  17,
  2,
  18,
  7,
  18,
  2,
  19,
  7,
  19,
  2,
  20,
  7,
  20,
  2,
  21,
  7,
  21,
  2,
  22,
  7,
  22,
  2,
  23,
  7,
  23,
  2,
  24,
  7,
  24,
  2,
  25,
  7,
  25,
  2,
  26,
  7,
  26,
  2,
  27,
  7,
  27,
  2,
  28,
  7,
  28,
  2,
  29,
  7,
  29,
  2,
  30,
  7,
  30,
  2,
  31,
  7,
  31,
  2,
  32,
  7,
  32,
  2,
  33,
  7,
  33,
  2,
  34,
  7,
  34,
  2,
  35,
  7,
  35,
  2,
  36,
  7,
  36,
  2,
  37,
  7,
  37,
  2,
  38,
  7,
  38,
  2,
  39,
  7,
  39,
  2,
  40,
  7,
  40,
  2,
  41,
  7,
  41,
  2,
  42,
  7,
  42,
  2,
  43,
  7,
  43,
  2,
  44,
  7,
  44,
  2,
  45,
  7,
  45,
  2,
  46,
  7,
  46,
  2,
  47,
  7,
  47,
  2,
  48,
  7,
  48,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  1,
  2,
  1,
  2,
  1,
  2,
  1,
  2,
  1,
  2,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  4,
  1,
  5,
  1,
  5,
  1,
  5,
  1,
  5,
  1,
  6,
  1,
  6,
  1,
  6,
  1,
  6,
  1,
  6,
  1,
  6,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  8,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  11,
  1,
  11,
  1,
  11,
  1,
  11,
  1,
  11,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  13,
  1,
  13,
  1,
  14,
  1,
  14,
  1,
  15,
  1,
  15,
  1,
  16,
  1,
  16,
  1,
  17,
  1,
  17,
  1,
  18,
  1,
  18,
  1,
  19,
  1,
  19,
  1,
  19,
  1,
  20,
  1,
  20,
  1,
  20,
  1,
  21,
  1,
  21,
  1,
  21,
  1,
  22,
  1,
  22,
  1,
  23,
  1,
  23,
  1,
  24,
  1,
  24,
  1,
  24,
  1,
  25,
  1,
  25,
  1,
  25,
  1,
  26,
  1,
  26,
  1,
  26,
  1,
  27,
  1,
  27,
  1,
  27,
  1,
  28,
  1,
  28,
  1,
  29,
  1,
  29,
  1,
  30,
  1,
  30,
  1,
  31,
  1,
  31,
  1,
  32,
  1,
  32,
  1,
  33,
  1,
  33,
  1,
  34,
  1,
  34,
  1,
  35,
  1,
  35,
  1,
  36,
  1,
  36,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  4,
  37,
  229,
  8,
  37,
  11,
  37,
  12,
  37,
  230,
  1,
  37,
  1,
  37,
  1,
  38,
  4,
  38,
  236,
  8,
  38,
  11,
  38,
  12,
  38,
  237,
  1,
  38,
  1,
  38,
  1,
  39,
  4,
  39,
  243,
  8,
  39,
  11,
  39,
  12,
  39,
  244,
  1,
  40,
  1,
  40,
  1,
  40,
  1,
  40,
  4,
  40,
  251,
  8,
  40,
  11,
  40,
  12,
  40,
  252,
  1,
  41,
  1,
  41,
  1,
  41,
  3,
  41,
  258,
  8,
  41,
  1,
  41,
  1,
  41,
  1,
  42,
  1,
  42,
  1,
  42,
  1,
  43,
  1,
  43,
  1,
  43,
  5,
  43,
  268,
  8,
  43,
  10,
  43,
  12,
  43,
  271,
  9,
  43,
  1,
  43,
  1,
  43,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  3,
  44,
  284,
  8,
  44,
  1,
  45,
  1,
  45,
  5,
  45,
  288,
  8,
  45,
  10,
  45,
  12,
  45,
  291,
  9,
  45,
  1,
  46,
  4,
  46,
  294,
  8,
  46,
  11,
  46,
  12,
  46,
  295,
  1,
  46,
  1,
  46,
  1,
  47,
  1,
  47,
  1,
  47,
  1,
  47,
  5,
  47,
  304,
  8,
  47,
  10,
  47,
  12,
  47,
  307,
  9,
  47,
  1,
  47,
  1,
  47,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  48,
  5,
  48,
  315,
  8,
  48,
  10,
  48,
  12,
  48,
  318,
  9,
  48,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  316,
  0,
  49,
  1,
  1,
  3,
  2,
  5,
  3,
  7,
  4,
  9,
  5,
  11,
  6,
  13,
  7,
  15,
  8,
  17,
  9,
  19,
  10,
  21,
  11,
  23,
  12,
  25,
  13,
  27,
  14,
  29,
  15,
  31,
  16,
  33,
  17,
  35,
  18,
  37,
  19,
  39,
  20,
  41,
  21,
  43,
  22,
  45,
  23,
  47,
  24,
  49,
  25,
  51,
  26,
  53,
  27,
  55,
  28,
  57,
  29,
  59,
  30,
  61,
  31,
  63,
  32,
  65,
  33,
  67,
  34,
  69,
  35,
  71,
  36,
  73,
  37,
  75,
  38,
  77,
  39,
  79,
  40,
  81,
  41,
  83,
  42,
  85,
  0,
  87,
  43,
  89,
  44,
  91,
  45,
  93,
  46,
  95,
  47,
  97,
  48,
  1,
  0,
  9,
  3,
  0,
  48,
  57,
  65,
  70,
  97,
  102,
  1,
  0,
  48,
  57,
  2,
  0,
  39,
  39,
  92,
  92,
  7,
  0,
  34,
  34,
  39,
  39,
  92,
  92,
  102,
  102,
  110,
  110,
  114,
  114,
  116,
  116,
  2,
  0,
  34,
  34,
  92,
  92,
  3,
  0,
  65,
  90,
  95,
  95,
  97,
  122,
  4,
  0,
  48,
  57,
  65,
  90,
  95,
  95,
  97,
  122,
  3,
  0,
  9,
  10,
  13,
  13,
  32,
  32,
  2,
  0,
  10,
  10,
  13,
  13,
  334,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  3,
  1,
  0,
  0,
  0,
  0,
  5,
  1,
  0,
  0,
  0,
  0,
  7,
  1,
  0,
  0,
  0,
  0,
  9,
  1,
  0,
  0,
  0,
  0,
  11,
  1,
  0,
  0,
  0,
  0,
  13,
  1,
  0,
  0,
  0,
  0,
  15,
  1,
  0,
  0,
  0,
  0,
  17,
  1,
  0,
  0,
  0,
  0,
  19,
  1,
  0,
  0,
  0,
  0,
  21,
  1,
  0,
  0,
  0,
  0,
  23,
  1,
  0,
  0,
  0,
  0,
  25,
  1,
  0,
  0,
  0,
  0,
  27,
  1,
  0,
  0,
  0,
  0,
  29,
  1,
  0,
  0,
  0,
  0,
  31,
  1,
  0,
  0,
  0,
  0,
  33,
  1,
  0,
  0,
  0,
  0,
  35,
  1,
  0,
  0,
  0,
  0,
  37,
  1,
  0,
  0,
  0,
  0,
  39,
  1,
  0,
  0,
  0,
  0,
  41,
  1,
  0,
  0,
  0,
  0,
  43,
  1,
  0,
  0,
  0,
  0,
  45,
  1,
  0,
  0,
  0,
  0,
  47,
  1,
  0,
  0,
  0,
  0,
  49,
  1,
  0,
  0,
  0,
  0,
  51,
  1,
  0,
  0,
  0,
  0,
  53,
  1,
  0,
  0,
  0,
  0,
  55,
  1,
  0,
  0,
  0,
  0,
  57,
  1,
  0,
  0,
  0,
  0,
  59,
  1,
  0,
  0,
  0,
  0,
  61,
  1,
  0,
  0,
  0,
  0,
  63,
  1,
  0,
  0,
  0,
  0,
  65,
  1,
  0,
  0,
  0,
  0,
  67,
  1,
  0,
  0,
  0,
  0,
  69,
  1,
  0,
  0,
  0,
  0,
  71,
  1,
  0,
  0,
  0,
  0,
  73,
  1,
  0,
  0,
  0,
  0,
  75,
  1,
  0,
  0,
  0,
  0,
  77,
  1,
  0,
  0,
  0,
  0,
  79,
  1,
  0,
  0,
  0,
  0,
  81,
  1,
  0,
  0,
  0,
  0,
  83,
  1,
  0,
  0,
  0,
  0,
  87,
  1,
  0,
  0,
  0,
  0,
  89,
  1,
  0,
  0,
  0,
  0,
  91,
  1,
  0,
  0,
  0,
  0,
  93,
  1,
  0,
  0,
  0,
  0,
  95,
  1,
  0,
  0,
  0,
  0,
  97,
  1,
  0,
  0,
  0,
  1,
  99,
  1,
  0,
  0,
  0,
  3,
  106,
  1,
  0,
  0,
  0,
  5,
  111,
  1,
  0,
  0,
  0,
  7,
  118,
  1,
  0,
  0,
  0,
  9,
  121,
  1,
  0,
  0,
  0,
  11,
  126,
  1,
  0,
  0,
  0,
  13,
  130,
  1,
  0,
  0,
  0,
  15,
  136,
  1,
  0,
  0,
  0,
  17,
  142,
  1,
  0,
  0,
  0,
  19,
  151,
  1,
  0,
  0,
  0,
  21,
  155,
  1,
  0,
  0,
  0,
  23,
  159,
  1,
  0,
  0,
  0,
  25,
  164,
  1,
  0,
  0,
  0,
  27,
  169,
  1,
  0,
  0,
  0,
  29,
  171,
  1,
  0,
  0,
  0,
  31,
  173,
  1,
  0,
  0,
  0,
  33,
  175,
  1,
  0,
  0,
  0,
  35,
  177,
  1,
  0,
  0,
  0,
  37,
  179,
  1,
  0,
  0,
  0,
  39,
  181,
  1,
  0,
  0,
  0,
  41,
  184,
  1,
  0,
  0,
  0,
  43,
  187,
  1,
  0,
  0,
  0,
  45,
  190,
  1,
  0,
  0,
  0,
  47,
  192,
  1,
  0,
  0,
  0,
  49,
  194,
  1,
  0,
  0,
  0,
  51,
  197,
  1,
  0,
  0,
  0,
  53,
  200,
  1,
  0,
  0,
  0,
  55,
  203,
  1,
  0,
  0,
  0,
  57,
  206,
  1,
  0,
  0,
  0,
  59,
  208,
  1,
  0,
  0,
  0,
  61,
  210,
  1,
  0,
  0,
  0,
  63,
  212,
  1,
  0,
  0,
  0,
  65,
  214,
  1,
  0,
  0,
  0,
  67,
  216,
  1,
  0,
  0,
  0,
  69,
  218,
  1,
  0,
  0,
  0,
  71,
  220,
  1,
  0,
  0,
  0,
  73,
  222,
  1,
  0,
  0,
  0,
  75,
  224,
  1,
  0,
  0,
  0,
  77,
  235,
  1,
  0,
  0,
  0,
  79,
  242,
  1,
  0,
  0,
  0,
  81,
  246,
  1,
  0,
  0,
  0,
  83,
  254,
  1,
  0,
  0,
  0,
  85,
  261,
  1,
  0,
  0,
  0,
  87,
  264,
  1,
  0,
  0,
  0,
  89,
  283,
  1,
  0,
  0,
  0,
  91,
  285,
  1,
  0,
  0,
  0,
  93,
  293,
  1,
  0,
  0,
  0,
  95,
  299,
  1,
  0,
  0,
  0,
  97,
  310,
  1,
  0,
  0,
  0,
  99,
  100,
  5,
  105,
  0,
  0,
  100,
  101,
  5,
  109,
  0,
  0,
  101,
  102,
  5,
  112,
  0,
  0,
  102,
  103,
  5,
  111,
  0,
  0,
  103,
  104,
  5,
  114,
  0,
  0,
  104,
  105,
  5,
  116,
  0,
  0,
  105,
  2,
  1,
  0,
  0,
  0,
  106,
  107,
  5,
  118,
  0,
  0,
  107,
  108,
  5,
  111,
  0,
  0,
  108,
  109,
  5,
  105,
  0,
  0,
  109,
  110,
  5,
  100,
  0,
  0,
  110,
  4,
  1,
  0,
  0,
  0,
  111,
  112,
  5,
  114,
  0,
  0,
  112,
  113,
  5,
  101,
  0,
  0,
  113,
  114,
  5,
  116,
  0,
  0,
  114,
  115,
  5,
  117,
  0,
  0,
  115,
  116,
  5,
  114,
  0,
  0,
  116,
  117,
  5,
  110,
  0,
  0,
  117,
  6,
  1,
  0,
  0,
  0,
  118,
  119,
  5,
  105,
  0,
  0,
  119,
  120,
  5,
  102,
  0,
  0,
  120,
  8,
  1,
  0,
  0,
  0,
  121,
  122,
  5,
  101,
  0,
  0,
  122,
  123,
  5,
  108,
  0,
  0,
  123,
  124,
  5,
  115,
  0,
  0,
  124,
  125,
  5,
  101,
  0,
  0,
  125,
  10,
  1,
  0,
  0,
  0,
  126,
  127,
  5,
  102,
  0,
  0,
  127,
  128,
  5,
  111,
  0,
  0,
  128,
  129,
  5,
  114,
  0,
  0,
  129,
  12,
  1,
  0,
  0,
  0,
  130,
  131,
  5,
  119,
  0,
  0,
  131,
  132,
  5,
  104,
  0,
  0,
  132,
  133,
  5,
  105,
  0,
  0,
  133,
  134,
  5,
  108,
  0,
  0,
  134,
  135,
  5,
  101,
  0,
  0,
  135,
  14,
  1,
  0,
  0,
  0,
  136,
  137,
  5,
  98,
  0,
  0,
  137,
  138,
  5,
  114,
  0,
  0,
  138,
  139,
  5,
  101,
  0,
  0,
  139,
  140,
  5,
  97,
  0,
  0,
  140,
  141,
  5,
  107,
  0,
  0,
  141,
  16,
  1,
  0,
  0,
  0,
  142,
  143,
  5,
  99,
  0,
  0,
  143,
  144,
  5,
  111,
  0,
  0,
  144,
  145,
  5,
  110,
  0,
  0,
  145,
  146,
  5,
  116,
  0,
  0,
  146,
  147,
  5,
  105,
  0,
  0,
  147,
  148,
  5,
  110,
  0,
  0,
  148,
  149,
  5,
  117,
  0,
  0,
  149,
  150,
  5,
  101,
  0,
  0,
  150,
  18,
  1,
  0,
  0,
  0,
  151,
  152,
  5,
  108,
  0,
  0,
  152,
  153,
  5,
  101,
  0,
  0,
  153,
  154,
  5,
  110,
  0,
  0,
  154,
  20,
  1,
  0,
  0,
  0,
  155,
  156,
  5,
  105,
  0,
  0,
  156,
  157,
  5,
  110,
  0,
  0,
  157,
  158,
  5,
  116,
  0,
  0,
  158,
  22,
  1,
  0,
  0,
  0,
  159,
  160,
  5,
  108,
  0,
  0,
  160,
  161,
  5,
  111,
  0,
  0,
  161,
  162,
  5,
  110,
  0,
  0,
  162,
  163,
  5,
  103,
  0,
  0,
  163,
  24,
  1,
  0,
  0,
  0,
  164,
  165,
  5,
  98,
  0,
  0,
  165,
  166,
  5,
  111,
  0,
  0,
  166,
  167,
  5,
  111,
  0,
  0,
  167,
  168,
  5,
  108,
  0,
  0,
  168,
  26,
  1,
  0,
  0,
  0,
  169,
  170,
  5,
  61,
  0,
  0,
  170,
  28,
  1,
  0,
  0,
  0,
  171,
  172,
  5,
  43,
  0,
  0,
  172,
  30,
  1,
  0,
  0,
  0,
  173,
  174,
  5,
  45,
  0,
  0,
  174,
  32,
  1,
  0,
  0,
  0,
  175,
  176,
  5,
  42,
  0,
  0,
  176,
  34,
  1,
  0,
  0,
  0,
  177,
  178,
  5,
  47,
  0,
  0,
  178,
  36,
  1,
  0,
  0,
  0,
  179,
  180,
  5,
  37,
  0,
  0,
  180,
  38,
  1,
  0,
  0,
  0,
  181,
  182,
  5,
  43,
  0,
  0,
  182,
  183,
  5,
  43,
  0,
  0,
  183,
  40,
  1,
  0,
  0,
  0,
  184,
  185,
  5,
  61,
  0,
  0,
  185,
  186,
  5,
  61,
  0,
  0,
  186,
  42,
  1,
  0,
  0,
  0,
  187,
  188,
  5,
  33,
  0,
  0,
  188,
  189,
  5,
  61,
  0,
  0,
  189,
  44,
  1,
  0,
  0,
  0,
  190,
  191,
  5,
  60,
  0,
  0,
  191,
  46,
  1,
  0,
  0,
  0,
  192,
  193,
  5,
  62,
  0,
  0,
  193,
  48,
  1,
  0,
  0,
  0,
  194,
  195,
  5,
  60,
  0,
  0,
  195,
  196,
  5,
  61,
  0,
  0,
  196,
  50,
  1,
  0,
  0,
  0,
  197,
  198,
  5,
  62,
  0,
  0,
  198,
  199,
  5,
  61,
  0,
  0,
  199,
  52,
  1,
  0,
  0,
  0,
  200,
  201,
  5,
  38,
  0,
  0,
  201,
  202,
  5,
  38,
  0,
  0,
  202,
  54,
  1,
  0,
  0,
  0,
  203,
  204,
  5,
  124,
  0,
  0,
  204,
  205,
  5,
  124,
  0,
  0,
  205,
  56,
  1,
  0,
  0,
  0,
  206,
  207,
  5,
  33,
  0,
  0,
  207,
  58,
  1,
  0,
  0,
  0,
  208,
  209,
  5,
  40,
  0,
  0,
  209,
  60,
  1,
  0,
  0,
  0,
  210,
  211,
  5,
  41,
  0,
  0,
  211,
  62,
  1,
  0,
  0,
  0,
  212,
  213,
  5,
  123,
  0,
  0,
  213,
  64,
  1,
  0,
  0,
  0,
  214,
  215,
  5,
  125,
  0,
  0,
  215,
  66,
  1,
  0,
  0,
  0,
  216,
  217,
  5,
  91,
  0,
  0,
  217,
  68,
  1,
  0,
  0,
  0,
  218,
  219,
  5,
  93,
  0,
  0,
  219,
  70,
  1,
  0,
  0,
  0,
  220,
  221,
  5,
  59,
  0,
  0,
  221,
  72,
  1,
  0,
  0,
  0,
  222,
  223,
  5,
  44,
  0,
  0,
  223,
  74,
  1,
  0,
  0,
  0,
  224,
  225,
  5,
  48,
  0,
  0,
  225,
  226,
  5,
  120,
  0,
  0,
  226,
  228,
  1,
  0,
  0,
  0,
  227,
  229,
  7,
  0,
  0,
  0,
  228,
  227,
  1,
  0,
  0,
  0,
  229,
  230,
  1,
  0,
  0,
  0,
  230,
  228,
  1,
  0,
  0,
  0,
  230,
  231,
  1,
  0,
  0,
  0,
  231,
  232,
  1,
  0,
  0,
  0,
  232,
  233,
  5,
  76,
  0,
  0,
  233,
  76,
  1,
  0,
  0,
  0,
  234,
  236,
  7,
  1,
  0,
  0,
  235,
  234,
  1,
  0,
  0,
  0,
  236,
  237,
  1,
  0,
  0,
  0,
  237,
  235,
  1,
  0,
  0,
  0,
  237,
  238,
  1,
  0,
  0,
  0,
  238,
  239,
  1,
  0,
  0,
  0,
  239,
  240,
  5,
  76,
  0,
  0,
  240,
  78,
  1,
  0,
  0,
  0,
  241,
  243,
  7,
  1,
  0,
  0,
  242,
  241,
  1,
  0,
  0,
  0,
  243,
  244,
  1,
  0,
  0,
  0,
  244,
  242,
  1,
  0,
  0,
  0,
  244,
  245,
  1,
  0,
  0,
  0,
  245,
  80,
  1,
  0,
  0,
  0,
  246,
  247,
  5,
  48,
  0,
  0,
  247,
  248,
  5,
  120,
  0,
  0,
  248,
  250,
  1,
  0,
  0,
  0,
  249,
  251,
  7,
  0,
  0,
  0,
  250,
  249,
  1,
  0,
  0,
  0,
  251,
  252,
  1,
  0,
  0,
  0,
  252,
  250,
  1,
  0,
  0,
  0,
  252,
  253,
  1,
  0,
  0,
  0,
  253,
  82,
  1,
  0,
  0,
  0,
  254,
  257,
  5,
  39,
  0,
  0,
  255,
  258,
  8,
  2,
  0,
  0,
  256,
  258,
  3,
  85,
  42,
  0,
  257,
  255,
  1,
  0,
  0,
  0,
  257,
  256,
  1,
  0,
  0,
  0,
  258,
  259,
  1,
  0,
  0,
  0,
  259,
  260,
  5,
  39,
  0,
  0,
  260,
  84,
  1,
  0,
  0,
  0,
  261,
  262,
  5,
  92,
  0,
  0,
  262,
  263,
  7,
  3,
  0,
  0,
  263,
  86,
  1,
  0,
  0,
  0,
  264,
  269,
  5,
  34,
  0,
  0,
  265,
  268,
  8,
  4,
  0,
  0,
  266,
  268,
  3,
  85,
  42,
  0,
  267,
  265,
  1,
  0,
  0,
  0,
  267,
  266,
  1,
  0,
  0,
  0,
  268,
  271,
  1,
  0,
  0,
  0,
  269,
  267,
  1,
  0,
  0,
  0,
  269,
  270,
  1,
  0,
  0,
  0,
  270,
  272,
  1,
  0,
  0,
  0,
  271,
  269,
  1,
  0,
  0,
  0,
  272,
  273,
  5,
  34,
  0,
  0,
  273,
  88,
  1,
  0,
  0,
  0,
  274,
  275,
  5,
  116,
  0,
  0,
  275,
  276,
  5,
  114,
  0,
  0,
  276,
  277,
  5,
  117,
  0,
  0,
  277,
  284,
  5,
  101,
  0,
  0,
  278,
  279,
  5,
  102,
  0,
  0,
  279,
  280,
  5,
  97,
  0,
  0,
  280,
  281,
  5,
  108,
  0,
  0,
  281,
  282,
  5,
  115,
  0,
  0,
  282,
  284,
  5,
  101,
  0,
  0,
  283,
  274,
  1,
  0,
  0,
  0,
  283,
  278,
  1,
  0,
  0,
  0,
  284,
  90,
  1,
  0,
  0,
  0,
  285,
  289,
  7,
  5,
  0,
  0,
  286,
  288,
  7,
  6,
  0,
  0,
  287,
  286,
  1,
  0,
  0,
  0,
  288,
  291,
  1,
  0,
  0,
  0,
  289,
  287,
  1,
  0,
  0,
  0,
  289,
  290,
  1,
  0,
  0,
  0,
  290,
  92,
  1,
  0,
  0,
  0,
  291,
  289,
  1,
  0,
  0,
  0,
  292,
  294,
  7,
  7,
  0,
  0,
  293,
  292,
  1,
  0,
  0,
  0,
  294,
  295,
  1,
  0,
  0,
  0,
  295,
  293,
  1,
  0,
  0,
  0,
  295,
  296,
  1,
  0,
  0,
  0,
  296,
  297,
  1,
  0,
  0,
  0,
  297,
  298,
  6,
  46,
  0,
  0,
  298,
  94,
  1,
  0,
  0,
  0,
  299,
  300,
  5,
  47,
  0,
  0,
  300,
  301,
  5,
  47,
  0,
  0,
  301,
  305,
  1,
  0,
  0,
  0,
  302,
  304,
  8,
  8,
  0,
  0,
  303,
  302,
  1,
  0,
  0,
  0,
  304,
  307,
  1,
  0,
  0,
  0,
  305,
  303,
  1,
  0,
  0,
  0,
  305,
  306,
  1,
  0,
  0,
  0,
  306,
  308,
  1,
  0,
  0,
  0,
  307,
  305,
  1,
  0,
  0,
  0,
  308,
  309,
  6,
  47,
  0,
  0,
  309,
  96,
  1,
  0,
  0,
  0,
  310,
  311,
  5,
  47,
  0,
  0,
  311,
  312,
  5,
  42,
  0,
  0,
  312,
  316,
  1,
  0,
  0,
  0,
  313,
  315,
  9,
  0,
  0,
  0,
  314,
  313,
  1,
  0,
  0,
  0,
  315,
  318,
  1,
  0,
  0,
  0,
  316,
  317,
  1,
  0,
  0,
  0,
  316,
  314,
  1,
  0,
  0,
  0,
  317,
  319,
  1,
  0,
  0,
  0,
  318,
  316,
  1,
  0,
  0,
  0,
  319,
  320,
  5,
  42,
  0,
  0,
  320,
  321,
  5,
  47,
  0,
  0,
  321,
  322,
  1,
  0,
  0,
  0,
  322,
  323,
  6,
  48,
  0,
  0,
  323,
  98,
  1,
  0,
  0,
  0,
  13,
  0,
  230,
  237,
  244,
  252,
  257,
  267,
  269,
  283,
  289,
  295,
  305,
  316,
  1,
  6,
  0,
  0
];
_DecafLexer.DecisionsToDFA = _DecafLexer._ATN.decisionToState.map((ds, index) => new Qe(ds, index));
let DecafLexer = _DecafLexer;
function webAstParser(webProgram) {
  console.log(webProgram);
  let stream = Xe.fromString(webProgram);
  let lexer = new DecafLexer(stream);
  let token_stream = new Ze(lexer);
  let parser = new DecafParser(token_stream);
  parser.removeErrorListeners();
  return parser.program();
}
class CustomErrorListener extends nn {
  constructor() {
    super(...arguments);
    this.errors = [];
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e2) {
    this.errors.push(`Parsing error at line ${line}, column ${column}: ${msg}`);
  }
  getErrors() {
    return this.errors;
  }
}
function webParse(content) {
  console.log(content);
  const stream = Xe.fromString(content);
  const lexer = new DecafLexer(stream);
  const token_stream = new Ze(lexer);
  const parser = new DecafParser(token_stream);
  parser.removeErrorListeners();
  const errorListener = new CustomErrorListener();
  parser.addErrorListener(errorListener);
  parser.program();
  return errorListener.getErrors();
}
class Scope {
  constructor(parent) {
    this.parent = parent;
    this.symbols = /* @__PURE__ */ new Map();
  }
  add(id, type) {
    if (this.symbols.has(id)) {
      throw new Error(`Duplicate variable: ${id}`);
    }
    this.symbols.set(id, type);
  }
  lookup(id) {
    if (this.symbols.has(id)) {
      return this.symbols.get(id)?.type;
    } else if (this.parent !== null) {
      return this.parent.lookup(id);
    } else {
      return void 0;
    }
  }
}
class Params extends Scope {
  constructor(ordered_params, parent) {
    super(parent);
    this.ordered_params = [];
    ordered_params.forEach(
      (param) => this.add(param[0], new Field(param[0], param[1], param[2]))
    );
  }
  add(param, type) {
    this.symbols.set(param, type);
    this.ordered_params.push([param, type]);
  }
}
class Position {
  constructor(line, col) {
    this.line = line;
    this.col = col;
  }
  toString() {
    return `${this.line}:${this.col}`;
  }
}
class Span {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  toString() {
    return `${this.start}-${this.end}`;
  }
}
class IrNode {
}
class Program extends IrNode {
  constructor(span) {
    super();
    this.span = span;
    this.imports = /* @__PURE__ */ new Map();
    this.methods = /* @__PURE__ */ new Map();
    this.natives = /* @__PURE__ */ new Map();
    this.scope = new Scope(null);
    this.stringLiteralMap = /* @__PURE__ */ new Map();
  }
}
class Field extends IrNode {
  constructor(name, type, span, array_size) {
    super();
    this.name = name;
    this.type = type;
    this.span = span;
    this.array_size = array_size;
  }
  equals(other) {
    return this.name === other.name && this.type === other.type;
  }
}
class Method extends IrNode {
  constructor(method_name, params, returnType, span) {
    super();
    this.method_name = method_name;
    this.params = params;
    this.returnType = returnType;
    this.span = span;
    this.body = new Block(
      new Scope(null),
      [],
      new Span(new Position(0, 0), new Position(0, 0))
    );
  }
  get_return_type(scope) {
    return this.returnType;
  }
}
class Import extends IrNode {
  constructor(name, span) {
    super();
    this.name = name;
    this.span = span;
  }
}
class Block extends IrNode {
  constructor(scope, statements, span) {
    super();
    this.scope = scope;
    this.statements = statements;
    this.span = span;
  }
}
class Expr extends IrNode {
}
class NameExpr extends Expr {
  constructor(name, span) {
    super();
    this.name = name;
    this.span = span;
  }
}
class ArrNameExpr extends Expr {
  constructor(name, expression, span) {
    super();
    this.name = name;
    this.expression = expression;
    this.span = span;
  }
}
class CastExpr extends Expr {
  constructor(expr, span) {
    super();
    this.expr = expr;
    this.span = span;
  }
}
class LongCastExpr extends CastExpr {
  constructor(expr, span) {
    super(expr, span);
    this.span = span;
  }
}
class IntCastExpr extends CastExpr {
  constructor(expr, span) {
    super(expr, span);
    this.span = span;
  }
}
class LenExpr extends Expr {
  constructor(name, span) {
    super();
    this.name = name;
    this.span = span;
  }
}
class BinExpr extends Expr {
  constructor(expr1, binOp, expr2, span) {
    super();
    this.expr1 = expr1;
    this.binOp = binOp;
    this.expr2 = expr2;
    this.span = span;
  }
}
class NotExpr extends Expr {
  constructor(expr, span) {
    super();
    this.expr = expr;
    this.span = span;
  }
}
class NegativeExpr extends Expr {
  constructor(expr, span) {
    super();
    this.expr = expr;
    this.span = span;
  }
}
class Statement extends IrNode {
}
class AssignContent extends IrNode {
  constructor(operator, expr) {
    super();
    this.operator = operator;
    this.expr = expr;
    this.isLong = false;
  }
}
class Assignment extends Statement {
  constructor(rhs, assignee_span, assign_expr_span) {
    super();
    this.rhs = rhs;
    this.assignee_span = assignee_span;
    this.assign_expr_span = assign_expr_span;
    this.lhsIndexed = null;
    this.lhsUnindexed = null;
  }
}
class MethodCallExpr extends Statement {
  constructor(methodName, args, span) {
    super();
    this.methodName = methodName;
    this.args = args;
    this.span = span;
  }
  // get_return_type(scope: Scope): Datatype {
  // }
}
class IfElse extends Statement {
  constructor(condition, trueBody, falseBody, span) {
    super();
    this.condition = condition;
    this.trueBody = trueBody;
    this.falseBody = falseBody;
    this.span = span;
  }
}
class ForLoop extends Statement {
  constructor(init, condition, update, body, span) {
    super();
    this.init = init;
    this.condition = condition;
    this.update = update;
    this.body = body;
    this.span = span;
  }
}
class WhileLoop extends Statement {
  constructor(condition, body, span) {
    super();
    this.condition = condition;
    this.body = body;
    this.span = span;
  }
}
class Return extends Statement {
  constructor(expr, span) {
    super();
    this.expr = expr;
    this.span = span;
  }
}
class Break extends Statement {
  constructor(span) {
    super();
    this.span = span;
  }
}
class Continue extends Statement {
  constructor(span) {
    super();
    this.span = span;
  }
}
class Literal extends IrNode {
  constructor(d2) {
    super();
    this.literalType = d2;
  }
}
class IntLiteral extends Literal {
  constructor(val, span) {
    super(
      "int"
      /* Int */
    );
    this.val = val;
    this.span = span;
  }
  toString() {
    return `${this.val}`;
  }
}
class LongLiteral extends Literal {
  constructor(val, span) {
    super(
      "long"
      /* Long */
    );
    this.val = val;
    this.span = span;
  }
  toString() {
    return `${this.val}L`;
  }
}
class StringLiteral extends Literal {
  constructor(val, span) {
    super(
      "string"
      /* String */
    );
    this.val = val;
    this.span = span;
  }
  toString() {
    return `"${this.val}"`;
  }
}
class BoolLiteral extends Literal {
  constructor(b2, span) {
    super(
      "bool"
      /* Bool */
    );
    this.b = b2;
    this.span = span;
  }
}
class AssignmentOperator extends IrNode {
}
class Assign extends AssignmentOperator {
}
class PlusAssign extends AssignmentOperator {
}
class MinusAssign extends AssignmentOperator {
}
class MultiplyAssign extends AssignmentOperator {
}
class DivideAssign extends AssignmentOperator {
}
class ModuloAssign extends AssignmentOperator {
}
class IncrementOperator extends AssignmentOperator {
}
class Increment extends IncrementOperator {
}
class Decrement extends IncrementOperator {
}
class BinaryOperation extends Expr {
  constructor() {
    super();
  }
}
class ArithOp extends BinaryOperation {
  constructor() {
    super();
  }
}
class PlusOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return "+";
  }
}
class MinusOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return "-";
  }
}
class MultiplyOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return "*";
  }
}
class DivideOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return "/";
  }
}
class ModuloOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return "%";
  }
}
class LeftShiftOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return "<<";
  }
}
class RightShiftOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return ">>";
  }
}
class BitAndOp extends ArithOp {
  constructor() {
    super();
  }
  toString() {
    return "&";
  }
}
class RelationOp extends BinaryOperation {
  constructor() {
    super();
  }
}
class LessThanOp extends RelationOp {
  constructor() {
    super();
  }
  toString() {
    return "<";
  }
}
class GreaterThanOp extends RelationOp {
  constructor() {
    super();
  }
  toString() {
    return ">";
  }
}
class LessEqualOp extends RelationOp {
  constructor() {
    super();
  }
  toString() {
    return "<=";
  }
}
class GreaterEqualOp extends RelationOp {
  constructor() {
    super();
  }
  toString() {
    return ">=";
  }
}
class EqOp extends BinaryOperation {
  constructor() {
    super();
  }
}
class EqualOp extends EqOp {
  constructor() {
    super();
  }
  toString() {
    return "==";
  }
}
class NotEqualOp extends EqOp {
  constructor() {
    super();
  }
  toString() {
    return "!=";
  }
}
class CondOp extends BinaryOperation {
  constructor() {
    super();
  }
}
class AndOp extends CondOp {
  constructor() {
    super();
  }
  toString() {
    return "&&";
  }
}
class OrOp extends CondOp {
  constructor() {
    super();
  }
  toString() {
    return "||";
  }
}
class Datatype {
}
class InvalidType extends Datatype {
  constructor() {
    super();
  }
  equals(other) {
    return false;
  }
  toString() {
    return "invalid";
  }
}
class IntType extends Datatype {
  constructor() {
    super();
  }
  equals(other) {
    return other instanceof IntType;
  }
  toString() {
    return "int";
  }
}
class LongType extends Datatype {
  constructor() {
    super();
  }
  equals(other) {
    return other instanceof LongType;
  }
  toString() {
    return "long";
  }
}
class BoolType extends Datatype {
  constructor() {
    super();
  }
  equals(other) {
    return other instanceof BoolType;
  }
  toString() {
    return "bool";
  }
}
class ArrayType extends Datatype {
  constructor(array_size) {
    super();
    this.array_size = array_size;
  }
  equals(other) {
    return other instanceof ArrayType;
  }
  toString() {
    return `array[${this.array_size}]`;
  }
}
class IntArrayType extends ArrayType {
  constructor(array_size) {
    super(array_size);
    this.array_size = array_size;
  }
  equals(other) {
    return other instanceof IntArrayType;
  }
  unarray() {
    return new IntType();
  }
  toString() {
    return `int[${this.array_size}]`;
  }
}
class LongArrayType extends ArrayType {
  constructor(array_size) {
    super(array_size);
    this.array_size = array_size;
  }
  equals(other) {
    return other instanceof LongArrayType;
  }
  unarray() {
    return new LongType();
  }
  toString() {
    return `long[${this.array_size}]`;
  }
}
class BoolArrayType extends ArrayType {
  constructor(array_size) {
    super(array_size);
    this.array_size = array_size;
  }
  equals(other) {
    return other instanceof BoolArrayType;
  }
  unarray() {
    return new BoolType();
  }
  toString() {
    return `bool[${this.array_size}]`;
  }
}
class StringType extends Datatype {
  constructor() {
    super();
  }
  equals(other) {
    return other instanceof StringType;
  }
  toString() {
    return "string";
  }
}
class VoidType extends Datatype {
  constructor() {
    super();
  }
  equals(other) {
    return other instanceof VoidType;
  }
  toString() {
    return "void";
  }
}
class IrBuilder {
  constructor(antlr_tree) {
    this.error_messages = [];
    this.antlr_tree = antlr_tree;
    this.stringLiteralMap = /* @__PURE__ */ new Map();
  }
  buildErrorMessage(error_text, antlr_node, identifier) {
    if (antlr_node.start.line === antlr_node.stop?.line && antlr_node.start.column === antlr_node.stop?.column) {
      this.error_messages.push(
        `Semantic error at line ${antlr_node.start.line}, column ${antlr_node.start.column}: ${error_text} (identifier: ${identifier})`
      );
    } else if (antlr_node.start.line === antlr_node.stop?.line) {
      this.error_messages.push(
        `Semantic error at line ${antlr_node.start.line}, column ${antlr_node.start.column}-${antlr_node.stop?.column}: ${error_text} (identifier: ${identifier})`
      );
    } else if (antlr_node.start.column === antlr_node.stop?.column) {
      this.error_messages.push(
        `Semantic error at line ${antlr_node.start.line}-${antlr_node.stop?.line}, column ${antlr_node.start.column}: ${error_text} (identifier: ${identifier})`
      );
    } else {
      this.error_messages.push(
        `Semantic error at line ${antlr_node.start.line}-${antlr_node.stop?.line}, column ${antlr_node.start.column}-${antlr_node.stop?.column}: ${error_text} (identifier: ${identifier})`
      );
    }
  }
  getErrorMessages() {
    return this.error_messages;
  }
  buildProgram() {
    const program_span = this.spanConstructor(this.antlr_tree);
    const root_node = new Program(program_span);
    const antlr_tree = this.antlr_tree;
    const import_children = antlr_tree.import_decl_list();
    const field_children = antlr_tree.field_decl_list();
    const method_children = antlr_tree.method_decl_list();
    import_children.forEach((child) => {
      this.buildProgramImportDecl(child, root_node);
    });
    field_children.forEach((child) => {
      this.buildFieldDecl(child, root_node);
    });
    root_node.scope.symbols.forEach((field, name) => {
      root_node.natives.set(name, field.type);
    });
    method_children.forEach((child) => {
      this.buildProgramMethodDecl(child, root_node);
    });
    root_node.stringLiteralMap = this.stringLiteralMap;
    return root_node;
  }
  buildProgramImportDecl(antlr_node, root_node) {
    const method_name = antlr_node.ID().getText();
    const import_span2 = this.spanConstructor(antlr_node);
    const import_instance = new Import(method_name, import_span2);
    if (root_node.methods.has(method_name) || root_node.scope.symbols.has(method_name)) {
      this.buildErrorMessage(
        `Import name ${method_name} conflicts with existing identifier in global scope`,
        antlr_node,
        method_name
      );
      return;
    }
    const import_symbol_table = root_node.imports;
    if (import_symbol_table.has(antlr_node.ID().getText())) {
      this.buildErrorMessage(
        `Duplicate import declaration: ${antlr_node.ID().getText()}`,
        antlr_node,
        method_name
      );
      return;
    }
    import_symbol_table.set(method_name, import_instance);
  }
  buildFieldDecl(antlr_node, root_node) {
    const root_scope_symbols = root_node.scope.symbols;
    if (root_node instanceof Program) {
      antlr_node.ID_list().forEach((val_field_decl_id) => {
        const field_name = val_field_decl_id.getText();
        if (root_node.imports.has(field_name) || root_node.methods.has(field_name)) {
          this.buildErrorMessage(
            `Field name ${field_name} conflicts with existing identifier in global scope`,
            antlr_node,
            field_name
          );
          return;
        }
      });
      antlr_node.array_field_decl_list().forEach((array_field_decl_id) => {
        const field_name = array_field_decl_id.ID().getText();
        if (root_node.imports.has(field_name) || root_node.methods.has(field_name)) {
          this.buildErrorMessage(
            `Array field name ${field_name} conflicts with existing identifier in global scope`,
            antlr_node,
            field_name
          );
          return;
        }
      });
    }
    antlr_node.ID_list().forEach((val_field_decl_id) => {
      const used_type = this.cast_datatype(antlr_node.type_());
      if (root_scope_symbols.has(val_field_decl_id.getText())) {
        this.buildErrorMessage(
          `Duplicate field declaration: ${val_field_decl_id.getText()}`,
          antlr_node,
          val_field_decl_id.getText()
        );
        return;
      }
      const field_name = val_field_decl_id.getText();
      const var_field = new Field(
        field_name,
        used_type,
        this.terminalSpanConstructor(val_field_decl_id)
      );
      root_scope_symbols.set(val_field_decl_id.getText(), var_field);
    });
    antlr_node.array_field_decl_list().forEach((array_field_decl) => {
      const array_size = this.extract_num_literal_value(array_field_decl, true);
      const used_type = this.cast_array_datatype(
        antlr_node.type_(),
        array_size
      );
      if (root_scope_symbols.has(array_field_decl.ID().getText())) {
        this.buildErrorMessage(
          `Duplicate field declaration: ${array_field_decl.ID().getText()}`,
          antlr_node,
          array_field_decl.ID().getText()
        );
        return;
      }
      const array_field_name = array_field_decl.ID().getText();
      const array_field = new Field(
        array_field_name,
        used_type,
        this.spanConstructor(array_field_decl),
        array_size
      );
      root_scope_symbols.set(array_field_decl.ID().getText(), array_field);
    });
  }
  buildProgramMethodDecl(antlr_node, root_node) {
    const method_name = antlr_node.ID(0).getText();
    const method_symbol_table = root_node.methods;
    if (root_node.imports.has(method_name) || root_node.scope.symbols.has(method_name)) {
      this.buildErrorMessage(
        `Method name ${method_name} conflicts with existing identifier in global scope`,
        antlr_node,
        method_name
      );
      return;
    }
    if (method_symbol_table.has(method_name)) {
      this.buildErrorMessage(
        `Duplicate method declaration: ${method_name}`,
        antlr_node,
        method_name
      );
      return;
    }
    const uncasted_types = antlr_node.type__list();
    const casted_types = uncasted_types.map((type) => this.cast_datatype(type));
    let method_return_type;
    if (antlr_node.VOID()) {
      method_return_type = new VoidType();
    } else {
      method_return_type = casted_types.shift();
      uncasted_types.shift();
    }
    const method_param_names = antlr_node.ID_list().slice(1);
    const method_params_list = casted_types.map(
      (param_type, index) => {
        const param_name = method_param_names[index].getText();
        const param_type_node = uncasted_types[index];
        const param_span = this.param_span_constructor(
          param_type_node,
          method_param_names[index]
        );
        return [param_name, param_type, param_span];
      }
    );
    for (let i2 = 0; i2 < method_params_list.length; i2++) {
      for (let j2 = 0; j2 < i2; j2++) {
        if (method_params_list[i2][0] === method_params_list[j2][0]) {
          this.buildErrorMessage(
            `Duplicate param name in method declaration: ${method_name}`,
            antlr_node,
            method_params_list[i2][0]
          );
        }
      }
    }
    const ast_method = new Method(
      method_name,
      new Params(method_params_list, new Scope(root_node.scope)),
      method_return_type,
      this.spanConstructor(antlr_node)
    );
    this.buildMethodBlock(antlr_node.block(), ast_method);
    method_symbol_table.set(method_name, ast_method);
  }
  buildMethodBlock(antlr_node, root_node) {
    const block_span = this.spanConstructor(antlr_node);
    const method_block = new Block(new Scope(root_node.params), [], block_span);
    root_node.params.ordered_params.forEach(([param_name, _2]) => {
      if (method_block.scope.symbols.has(param_name)) {
        this.buildErrorMessage(
          `Variable ${param_name} conflicts with method parameter name`,
          antlr_node,
          param_name
        );
      }
    });
    root_node.body = method_block;
    this.fillInBlockInfo(antlr_node, method_block);
    method_block.scope.symbols.forEach((value, param_name) => {
      const method_params = root_node.params;
      if (method_params.symbols.has(param_name)) {
        this.buildErrorMessage(
          `Variable ${param_name} conflicts with method parameter name`,
          antlr_node,
          param_name
        );
      }
      if (root_node.method_name === param_name) {
        this.buildErrorMessage(
          `Variable ${param_name} conflicts with method name`,
          antlr_node,
          param_name
        );
      }
    });
  }
  fillInBlockInfo(antlr_node, method_block) {
    const field_declarations = antlr_node.field_decl_list();
    field_declarations.forEach((field_decl) => {
      this.buildFieldDecl(field_decl, method_block);
    });
    const statements = antlr_node.statement_list();
    statements.forEach((statement) => {
      this.buildBlockStatement(statement, method_block);
    });
  }
  buildBlockStatement(antlr_node, root_node) {
    if (antlr_node.location()) {
      this.buildStatementLocAssign(antlr_node, root_node);
      return;
    }
    if (antlr_node.method_call()) {
      root_node.statements.push(
        this.build_method_call(antlr_node.method_call())
      );
      return;
    }
    if (antlr_node.if_stmt()) {
      this.buildStatementIf(antlr_node.if_stmt(), root_node);
      return;
    }
    if (antlr_node.for_stmt()) {
      this.buildStatementFor(antlr_node.for_stmt(), root_node);
      return;
    }
    if (antlr_node.while_stmt()) {
      this.buildStatementWhile(antlr_node.while_stmt(), root_node);
      return;
    }
    if (antlr_node.return_stmt()) {
      this.buildStatementReturn(antlr_node.return_stmt(), root_node);
      return;
    }
    if (antlr_node.BREAK()) {
      this.buildStatementBreak(antlr_node, root_node);
      return;
    }
    if (antlr_node.CONTINUE()) {
      this.buildStatementContinue(antlr_node, root_node);
      return;
    }
    throw new Error();
  }
  buildStatementLocAssign(antlr_node, root_node) {
    const assign_node = this.createStatementLocAssign(
      antlr_node.location(),
      antlr_node.assign_expr()
    );
    root_node.statements.push(assign_node);
  }
  build_method_call(antlr_node) {
    const method_name = antlr_node.method_name().getText();
    const method_params = antlr_node.expr_list();
    const params = method_params.map((expr) => this.evaluate_expr(expr));
    if (params.length === 0) {
      antlr_node.extern_arg_list().forEach((arg) => {
        const evaluated_extern_arg = this.evaluate_extern_arg(arg, method_name);
        params.push(evaluated_extern_arg);
      });
    }
    return new MethodCallExpr(
      method_name,
      params,
      this.spanConstructor(antlr_node)
    );
  }
  buildStatementIf(antlr_node, root_node) {
    const antlr_if_block = antlr_node.block(0);
    const antlr_else_block = antlr_node.block(1);
    const if_block = new Block(
      new Scope(root_node.scope),
      [],
      this.spanConstructor(antlr_if_block)
    );
    this.fillInBlockInfo(antlr_if_block, if_block);
    let else_block = null;
    if (antlr_else_block) {
      else_block = new Block(
        new Scope(root_node.scope),
        [],
        this.spanConstructor(antlr_else_block)
      );
      this.fillInBlockInfo(antlr_else_block, else_block);
    }
    const if_else_statement = new IfElse(
      this.evaluate_expr(antlr_node.expr()),
      if_block,
      else_block,
      this.spanConstructor(antlr_node)
    );
    root_node.statements.push(if_else_statement);
  }
  buildStatementFor(antlr_node, root_node) {
    const iteration_variable = antlr_node.ID().getText();
    const initializing_expr = this.evaluate_expr(antlr_node.expr(0));
    const for_condition = this.evaluate_expr(antlr_node.expr(1));
    const update_node = antlr_node.for_update();
    const body = antlr_node.block();
    const for_assignment = new Assignment(
      new AssignContent(new Assign(), initializing_expr),
      this.terminalSpanConstructor(antlr_node.ID()),
      this.spanConstructor(antlr_node)
    );
    for_assignment.lhsUnindexed = iteration_variable;
    const ir_body_block = new Block(
      new Scope(root_node.scope),
      [],
      this.spanConstructor(body)
    );
    this.fillInBlockInfo(body, ir_body_block);
    const update_assignment = this.createStatementLocAssign(
      update_node.location(),
      update_node.assign_expr()
    );
    const for_loop = new ForLoop(
      for_assignment,
      for_condition,
      update_assignment,
      ir_body_block,
      this.spanConstructor(antlr_node)
    );
    root_node.statements.push(for_loop);
  }
  buildStatementWhile(antlr_node, root_node) {
    const while_condition = this.evaluate_expr(antlr_node.expr());
    const body = antlr_node.block();
    const ir_body_block = new Block(
      new Scope(root_node.scope),
      [],
      this.spanConstructor(body)
    );
    this.fillInBlockInfo(body, ir_body_block);
    const while_loop = new WhileLoop(
      while_condition,
      ir_body_block,
      this.spanConstructor(antlr_node)
    );
    root_node.statements.push(while_loop);
  }
  buildStatementReturn(antlr_node, root_node) {
    if (antlr_node.expr()) {
      root_node.statements.push(
        new Return(
          this.evaluate_expr(antlr_node.expr()),
          this.spanConstructor(antlr_node)
        )
      );
      return;
    }
    root_node.statements.push(
      new Return(null, this.spanConstructor(antlr_node))
    );
  }
  buildStatementBreak(antlr_node, root_node) {
    root_node.statements.push(new Break(this.spanConstructor(antlr_node)));
  }
  buildStatementContinue(antlr_node, root_node) {
    root_node.statements.push(new Continue(this.spanConstructor(antlr_node)));
  }
  createStatementLocAssign(lhs_antlr_node, antlr_assign_expr) {
    let assign_node;
    const assignee_span = this.spanConstructor(lhs_antlr_node);
    const assign_expr_span = this.spanConstructor(antlr_assign_expr);
    if (antlr_assign_expr.increment()) {
      if (antlr_assign_expr.increment().INCREMENT()) {
        assign_node = new Assignment(
          new AssignContent(new Increment(), new Expr()),
          assignee_span,
          assign_expr_span
        );
      } else {
        assign_node = new Assignment(
          new AssignContent(new Decrement(), new Expr()),
          assignee_span,
          assign_expr_span
        );
      }
    } else {
      const ir_assign_expr = new AssignContent(
        this.cast_operator(antlr_assign_expr),
        this.evaluate_expr(antlr_assign_expr.expr())
      );
      assign_node = new Assignment(
        ir_assign_expr,
        assignee_span,
        assign_expr_span
      );
    }
    if (lhs_antlr_node.expr()) {
      const var_name = lhs_antlr_node.ID().getText();
      assign_node.lhsIndexed = [
        var_name,
        this.evaluate_expr(lhs_antlr_node.expr())
      ];
    } else {
      const var_name = lhs_antlr_node.ID().getText();
      assign_node.lhsUnindexed = var_name;
    }
    return assign_node;
  }
  /** Expressions */
  evaluate_expr(antlr_node, is_positive) {
    const expression_span = this.spanConstructor(antlr_node);
    if (antlr_node.MINUS() && antlr_node.expr_list().length == 1) {
      const edge_case_unary = this.evaluateUnaryEdgeCase(
        antlr_node,
        expression_span
      );
      if (edge_case_unary) return edge_case_unary;
      return new NegativeExpr(
        this.evaluate_expr(antlr_node.expr(0), false),
        expression_span
      );
    }
    if (antlr_node.NOT()) {
      return new NotExpr(
        this.evaluate_expr(antlr_node.expr(0)),
        expression_span
      );
    }
    if (antlr_node.INT()) {
      return new IntCastExpr(
        this.evaluate_expr(antlr_node.expr(0)),
        expression_span
      );
    }
    if (antlr_node.LONG()) {
      return new LongCastExpr(
        this.evaluate_expr(antlr_node.expr(0)),
        expression_span
      );
    }
    if (antlr_node.LEN()) {
      return new LenExpr(antlr_node.ID().getText(), expression_span);
    }
    const binary_operator = this.binOpHandler(antlr_node);
    if (binary_operator) {
      return new BinExpr(
        this.evaluate_expr(antlr_node.expr(0)),
        binary_operator,
        this.evaluate_expr(antlr_node.expr(1)),
        expression_span
      );
    }
    if (antlr_node.NOT()) {
      return new NotExpr(
        this.evaluate_expr(antlr_node.expr(0)),
        expression_span
      );
    }
    if (antlr_node.location()) {
      const var_name = antlr_node.location().ID().getText();
      if (antlr_node.location().LEFT_BRACKET()) {
        return new ArrNameExpr(
          var_name,
          this.evaluate_expr(antlr_node.location().expr()),
          expression_span
        );
      }
      return new NameExpr(var_name, expression_span);
    }
    if (antlr_node.method_call()) {
      return this.build_method_call(antlr_node.method_call());
    }
    if (antlr_node.literal()) {
      const literal_node = antlr_node.literal();
      const is_positive2 = literal_node.MINUS() === null;
      if (literal_node.int_literal()) {
        const int_value = this.extract_num_literal_value(
          literal_node,
          is_positive2
        );
        return new IntLiteral(int_value, expression_span);
      }
      if (literal_node.long_literal()) {
        const long_value = this.extract_long_literal_value(
          literal_node,
          is_positive2
        );
        return new LongLiteral(long_value, expression_span);
      }
      if (antlr_node.literal().CHARLITERAL()) {
        return new IntLiteral(
          antlr_node.literal().CHARLITERAL().getText().slice(1, -1).charCodeAt(0),
          expression_span
        );
      }
      if (antlr_node.literal().BOOLLITERAL().getText() == "true") {
        return new BoolLiteral(true, expression_span);
      }
      if (antlr_node.literal().BOOLLITERAL().getText() == "false") {
        return new BoolLiteral(false, expression_span);
      }
      throw new Error();
    }
    return this.evaluate_expr(antlr_node.expr(0));
  }
  cast_operator(antlr_node) {
    if (antlr_node.increment()) {
      if (antlr_node.increment().INCREMENT()) {
        return new Increment();
      } else {
        return new Decrement();
      }
    }
    if (antlr_node.assign_op().PLUS()) {
      return new PlusAssign();
    }
    if (antlr_node.assign_op().MINUS()) {
      return new MinusAssign();
    }
    if (antlr_node.assign_op().MULTIPLY()) {
      return new MultiplyAssign();
    }
    if (antlr_node.assign_op().DIVIDE()) {
      return new DivideAssign();
    }
    if (antlr_node.assign_op().MODULO()) {
      return new ModuloAssign();
    }
    if (antlr_node.assign_op().ASSIGN()) {
      return new Assign();
    }
    throw new Error();
  }
  evaluateUnaryEdgeCase(antlr_node, span) {
    if (antlr_node.expr(0).getText() == "2147483648") {
      return new IntLiteral(-2147483648, span);
    }
    if (antlr_node.expr(0).getText() == "9223372036854775808L") {
      return new LongLiteral(-9223372036854775808n, span);
    }
    return null;
  }
  binOpHandler(antrl_node) {
    if (antrl_node.PLUS()) {
      return new PlusOp();
    }
    if (antrl_node.MINUS()) {
      return new MinusOp();
    }
    if (antrl_node.MULTIPLY()) {
      return new MultiplyOp();
    }
    if (antrl_node.DIVIDE()) {
      return new DivideOp();
    }
    if (antrl_node.MODULO()) {
      return new ModuloOp();
    }
    if (antrl_node.LESS_THAN()) {
      return new LessThanOp();
    }
    if (antrl_node.GREATER_THAN()) {
      return new GreaterThanOp();
    }
    if (antrl_node.LESS_EQUAL()) {
      return new LessEqualOp();
    }
    if (antrl_node.GREATER_EQUAL()) {
      return new GreaterEqualOp();
    }
    if (antrl_node.EQUAL()) {
      return new EqualOp();
    }
    if (antrl_node.NOT_EQUAL()) {
      return new NotEqualOp();
    }
    if (antrl_node.AND()) {
      return new AndOp();
    }
    if (antrl_node.OR()) {
      return new OrOp();
    }
    return null;
  }
  spanConstructor(antlr_node) {
    const start_pos = new Position(
      antlr_node.start.line,
      antlr_node.start.column
    );
    const stop_column = antlr_node.stop?.column + antlr_node.stop?.text.length - 1;
    const end_pos = new Position(antlr_node.stop?.line, stop_column);
    return new Span(start_pos, end_pos);
  }
  terminalSpanConstructor(antlr_node) {
    const start_pos = new Position(
      antlr_node.symbol.line,
      antlr_node.symbol.column
    );
    const end_pos = new Position(
      antlr_node.symbol.line,
      antlr_node.symbol.column + antlr_node.getText().length - 1
    );
    return new Span(start_pos, end_pos);
  }
  param_span_constructor(type_node, name_node) {
    const start_pos = new Position(
      type_node.start.line,
      type_node.start.column
    );
    const end_pos = new Position(
      name_node.symbol.line,
      name_node.symbol.column + name_node.getText().length - 1
    );
    return new Span(start_pos, end_pos);
  }
  cast_datatype(antlr_node) {
    if (antlr_node.BOOL()) {
      return new BoolType();
    }
    if (antlr_node.INT()) {
      return new IntType();
    }
    if (antlr_node.LONG()) {
      return new LongType();
    }
    throw new Error();
  }
  cast_array_datatype(antlr_node, array_size) {
    if (array_size < 1) {
      this.buildErrorMessage(
        `Array size must be greater than 0`,
        antlr_node,
        "unknown"
      );
    }
    if (antlr_node.BOOL()) {
      return new BoolArrayType(array_size);
    }
    if (antlr_node.INT()) {
      return new IntArrayType(array_size);
    }
    if (antlr_node.LONG()) {
      return new LongArrayType(array_size);
    }
    throw new Error();
  }
  extract_num_literal_value(antlr_node, is_positive) {
    let value;
    if (antlr_node.int_literal().DECIMALLITERAL()) {
      value = BigInt(antlr_node.int_literal().DECIMALLITERAL().getText());
    } else {
      value = BigInt(antlr_node.int_literal().HEXLITERAL().getText());
    }
    if (!is_positive) {
      value = -value;
    }
    if (value < BigInt(-2147483648n) || value > BigInt(2147483647n)) {
      this.buildErrorMessage(
        `Integer literal out of range: ${value}`,
        antlr_node,
        value.toString()
      );
    }
    return Number(value);
  }
  extract_long_literal_value(antlr_node, is_positive) {
    let long_value;
    if (antlr_node.long_literal().LONGDECLITERAL()) {
      long_value = BigInt(
        antlr_node.long_literal().LONGDECLITERAL().getText().replace("L", "")
      );
    } else {
      long_value = BigInt(
        antlr_node.long_literal().LONGHEXLITERAL().getText().replace("L", "")
      );
    }
    if (!is_positive) {
      long_value = BigInt(-1) * long_value;
    }
    if (long_value < BigInt(-9223372036854775808n) || long_value > BigInt(9223372036854775807n)) {
      this.buildErrorMessage(
        `Long literal out of range: ${long_value}`,
        antlr_node,
        long_value.toString()
      );
    }
    return long_value;
  }
  add_string_literal(stringLiteral) {
    if (!this.stringLiteralMap.has(stringLiteral)) {
      this.stringLiteralMap.set(stringLiteral, 1);
      return;
    }
    this.stringLiteralMap.set(
      stringLiteral,
      this.stringLiteralMap.get(stringLiteral) + 1
    );
  }
  evaluate_extern_arg(antlr_node, method_name) {
    if (antlr_node.STRINGLITERAL()) {
      const stringLiteral = antlr_node.STRINGLITERAL().getText().slice(1, -1);
      this.add_string_literal(stringLiteral);
      return new StringLiteral(stringLiteral, this.spanConstructor(antlr_node));
    }
    return this.evaluate_expr(antlr_node.expr());
  }
}
class IrChecker {
  constructor(p2, filename) {
    this.error_messages = [];
    this.currentFunction = null;
    this.escapable = false;
    this.program = p2;
    this.ok = true;
    this.scope = p2.scope;
  }
  run() {
    this.checkProgram(this.program);
    return this.error_messages;
  }
  emit(error_text, span, identifier) {
    this.ok = false;
    if (span) {
      if (span.start.line === span.end.line && span.start.col === span.end.col) {
        this.error_messages.push(
          `Semantic error at line ${span.start.line}, column ${span.start.col}: ${error_text} (identifier: ${identifier})`
        );
      } else if (span.start.line === span.end.line) {
        this.error_messages.push(
          `Semantic error at line ${span.start.line}, column ${span.start.col}-${span.end.col}: ${error_text} (identifier: ${identifier})`
        );
      } else if (span.start.col === span.end.col) {
        this.error_messages.push(
          `Semantic error at line ${span.start.line}-${span.end.line}, column ${span.start.col}: ${error_text} (identifier: ${identifier})`
        );
      } else {
        this.error_messages.push(
          `Semantic error at line ${span.start.line}-${span.end.line}, column ${span.start.col}-${span.end.col}: ${error_text} (identifier: ${identifier})`
        );
      }
    } else {
      this.error_messages.push(
        `Semantic error: ${error_text} (identifier: ${identifier})`
      );
    }
  }
  checkProgram(p2) {
    for (const i2 of p2.imports) {
      this.checkImport(i2);
    }
    let containsMain = false;
    for (const m2 of p2.methods) {
      this.escapable = false;
      this.checkMethod(m2);
      if (m2[1].method_name === "main") {
        containsMain = true;
      }
    }
    if (!containsMain) {
      this.emit("Program must contain a main method", p2.span, "main");
    }
  }
  checkImport(imp) {
  }
  checkMethod(method) {
    this.currentFunction = method[1];
    if (method[0] === "main") {
      if (!(method[1].returnType instanceof VoidType)) {
        this.emit(
          "Main method must have return type void",
          method[1].span,
          method[0]
        );
      }
      if (method[1].params.ordered_params.length !== 0) {
        this.emit(
          "Main method must have no parameters",
          method[1].span,
          method[0]
        );
      }
    }
    this.checkBlock(method[1].body);
    if (!(this.currentFunction.returnType instanceof VoidType)) ;
  }
  checkBlock(block) {
    this.scope = block.scope;
    block.statements.forEach((s2) => {
      this.checkStatement(s2);
    });
    this.scope = this.scope.parent;
  }
  checkStatement(statement) {
    if (statement instanceof Assignment) {
      this.checkAssignment(statement);
    } else if (statement instanceof MethodCallExpr) {
      this.checkMethodCallExpr(statement);
    } else if (statement instanceof IfElse) {
      this.checkIfElse(statement);
    } else if (statement instanceof ForLoop) {
      this.checkForLoop(statement);
    } else if (statement instanceof WhileLoop) {
      this.checkWhileLoop(statement);
    } else if (statement instanceof Return) {
      this.checkReturn(statement);
    } else if (statement instanceof Break) {
      this.checkBreak(statement);
    } else if (statement instanceof Continue) {
      this.checkContinue(statement);
    } else {
      this.emit("Unknown statement type", void 0, "unknown");
    }
  }
  checkAssignment(assignment) {
    let lhs_type = new InvalidType();
    let var_name = "";
    if (assignment.lhsIndexed) {
      const expr = assignment.lhsIndexed[1];
      this.checkExpr(expr);
      var_name = assignment.lhsIndexed[0];
      const arrType = this.scope?.lookup(var_name);
      if (!(arrType instanceof ArrayType)) {
        this.emit("Cannot index into non-array type", void 0, var_name);
        return;
      }
      lhs_type = this.inferType(arrType);
      if (!(this.inferType(expr) instanceof IntType)) {
        this.emit("Index must be an integer", void 0, var_name);
      }
    } else {
      var_name = assignment.lhsUnindexed;
      const field = this.scope?.lookup(var_name);
      if (!field) {
        this.emit("Variable not found", void 0, var_name);
      } else {
        if (field instanceof ArrayType) {
          this.emit("Cannot assign to array type", void 0, var_name);
        }
        lhs_type = this.inferType(field);
      }
    }
    this.checkExpr(assignment.rhs.expr);
    const rhs_type = assignment.rhs.expr;
    if (lhs_type instanceof LongType || lhs_type instanceof LongArrayType) {
      assignment.rhs.isLong = true;
    }
    if (assignment.rhs.operator instanceof Increment || assignment.rhs.operator instanceof Decrement) {
      if (!lhs_type.equals(new IntType()) && !lhs_type.equals(new LongType())) {
        this.emit(
          "Increment only allowed on int or long types",
          assignment.assignee_span,
          var_name
        );
      }
      return;
    }
    if (!(assignment.rhs.operator instanceof Assign)) {
      if (!(lhs_type.equals(new IntType()) || lhs_type.equals(new LongType()))) {
        this.emit(
          "Compound assignment only allowed on int or long types",
          assignment.assignee_span,
          var_name
        );
      }
    }
    if (!this.inferType(assignment.rhs.expr).equals(lhs_type)) {
      this.emit(
        "Type mismatch in assignment, left type: " + lhs_type.constructor.name + " right type: " + this.inferType(rhs_type).constructor.name,
        assignment.assignee_span,
        var_name
      );
    }
  }
  inferType(expr) {
    if (expr === void 0) return new InvalidType();
    if (expr instanceof IntType || expr instanceof IntLiteral || expr instanceof IntCastExpr || // expr instanceof IntArrayType ||
    expr instanceof LenExpr || expr.constructor?.name == "IntArrayType") {
      return new IntType();
    }
    if (expr instanceof LongType || expr instanceof LongLiteral || expr instanceof LongCastExpr || expr.constructor?.name == "LongArrayType") {
      return new LongType();
    }
    if (expr instanceof BoolType || expr instanceof BoolLiteral || expr instanceof NotExpr || expr.constructor?.name == "BoolArrayType") {
      return new BoolType();
    }
    if (expr instanceof StringType || expr instanceof StringLiteral) {
      return new StringType();
    }
    if (expr instanceof BinExpr) {
      return this.inferBinExpr(expr);
    }
    if (expr instanceof NameExpr) {
      const datatype = this.scope?.lookup(expr.name);
      if (datatype) {
        return datatype;
      }
      return this.inferType(void 0);
    }
    if (expr instanceof ArrNameExpr) {
      const type = this.inferType(expr.expression);
      if (!(type instanceof IntLiteral || type.equals(new IntType()))) {
        this.emit("Index must be an integer", expr.span, expr.name);
      }
      return this.inferType(this.scope?.lookup(expr.name));
    }
    if (expr instanceof MethodCallExpr) {
      return this.getMethodReturnType(expr.methodName);
    }
    if (expr instanceof NegativeExpr) {
      return this.inferType(expr.expr);
    }
    return new InvalidType();
  }
  inferBinExpr(binExpr) {
    if (binExpr.binOp instanceof EqOp) {
      return new BoolType();
    }
    if (binExpr.binOp instanceof CondOp) {
      return new BoolType();
    }
    if (binExpr.binOp instanceof RelationOp) {
      return new BoolType();
    }
    if (binExpr.binOp instanceof ArithOp) {
      const leftType = this.inferType(binExpr.expr1);
      const rightType = this.inferType(binExpr.expr2);
      if (!leftType.equals(rightType)) {
        this.emit(
          "Type mismatch in binary expression",
          binExpr.span,
          "unknown"
        );
      }
      return this.inferType(binExpr.expr1);
    }
    return new InvalidType();
  }
  checkIfElse(ifElse) {
    this.checkBlock(ifElse.trueBody);
    this.checkExpr(ifElse.condition);
    if (!this.inferType(ifElse.condition).equals(new BoolType())) {
      this.emit("Type mismatch in if/else condition", ifElse.span, "unknown");
    }
    if (ifElse.falseBody) {
      this.checkBlock(ifElse.falseBody);
    }
  }
  checkForLoop(forLoop) {
    const previous_escape = this.escapable;
    this.escapable = true;
    this.checkAssignment(forLoop.init);
    this.checkExpr(forLoop.condition);
    if (!this.inferType(forLoop.condition).equals(new BoolType())) {
      this.emit("Type mismatch in for loop condition", forLoop.span, "unknown");
    }
    this.checkAssignment(forLoop.update);
    this.checkBlock(forLoop.body);
    this.escapable = previous_escape;
  }
  checkWhileLoop(whileLoop) {
    const previous_escape = this.escapable;
    this.escapable = true;
    this.checkExpr(whileLoop.condition);
    if (!(this.inferType(whileLoop.condition) instanceof BoolType)) {
      this.emit(
        "Type mismatch in while loop condition",
        whileLoop.span,
        "unknown"
      );
    }
    this.checkBlock(whileLoop.body);
    this.escapable = previous_escape;
  }
  checkReturn(returnStmt) {
    const name = this.currentFunction?.method_name;
    if (!this.currentFunction) {
      this.emit(
        "Return statement is not inside a function",
        returnStmt.span,
        "unknown"
      );
      return;
    }
    const lhs_type = this.currentFunction?.returnType;
    if (lhs_type instanceof VoidType) {
      if (returnStmt.expr !== null) {
        this.emit(
          `Void method ${name} cannot return a value`,
          returnStmt.span,
          name ? name : "unknown"
        );
      }
    }
    if (returnStmt.expr === null) {
      if (!(lhs_type instanceof VoidType)) {
        this.emit(
          `Return type mismatch, expected void but got ${lhs_type}`,
          returnStmt.span,
          name ? name : "unknown"
        );
      }
      return;
    }
    const rhs_type = returnStmt.expr;
    if (!this.inferType(rhs_type).equals(lhs_type)) {
      this.emit(
        `Return type mismatch, expected ${lhs_type.constructor.name} but got ${this.inferType(rhs_type).constructor.name}`,
        returnStmt.span,
        name ? name : "unknown"
      );
    }
  }
  checkBreak(breakStmt) {
    if (!this.escapable) {
      this.emit(
        "Break statement is not inside a loop",
        breakStmt.span,
        "unknown"
      );
    }
  }
  checkContinue(continueStmt) {
    if (!this.escapable) {
      this.emit(
        "Continue statement is not inside a loop",
        continueStmt.span,
        "unknown"
      );
    }
  }
  checkExpr(expr) {
    if (expr instanceof BinExpr) {
      this.checkBinaryOperation(expr);
    } else if (expr instanceof NameExpr) {
      this.checkNameExpr(expr);
    } else if (expr instanceof ArrNameExpr) {
      this.checkArrNameExpr(expr);
    } else if (expr instanceof MethodCallExpr) {
      this.checkMethodCallExpr(expr);
      if (this.getMethodReturnType(expr.methodName).equals(new VoidType())) {
        this.emit(
          "Method call used in an expression must return a value",
          expr.span,
          expr.methodName
        );
      }
    } else if (expr instanceof CastExpr) {
      this.checkCastExpr(expr);
    } else if (expr instanceof LenExpr) {
      this.checkLenExpr(expr);
    } else if (expr instanceof BinExpr) {
      this.checkBinExpr(expr);
    } else if (expr instanceof NotExpr) {
      this.checkNotExpr(expr);
    } else if (expr instanceof NegativeExpr) {
      this.checkUnaryOperation(expr);
    } else {
      if (!this.inferType(expr).equals(new InvalidType())) {
        return;
      }
      this.emit("Unknown expression type", void 0, "unknown");
    }
  }
  checkBinaryOperation(binary_expr) {
    this.checkExpr(binary_expr.expr1);
    this.checkExpr(binary_expr.expr2);
    const lhs_type = this.inferType(binary_expr.expr1);
    const rhs_type = this.inferType(binary_expr.expr2);
    if (!lhs_type.equals(rhs_type)) {
      this.emit(
        "Type mismatch in binary expression",
        binary_expr.span,
        "unknown"
      );
    }
    const type_isnt_numeric = !(lhs_type instanceof IntType) && !(lhs_type instanceof LongType);
    const type_is_bool = lhs_type instanceof BoolType;
    if (binary_expr.binOp instanceof ArithOp || binary_expr.binOp instanceof RelationOp) {
      if (type_isnt_numeric) {
        this.emit(
          "Type mismatch in binary expression",
          binary_expr.span,
          "unknown"
        );
      }
    }
    if (binary_expr.binOp instanceof EqOp) {
      if (type_isnt_numeric && !type_is_bool) {
        this.emit(
          "Type mismatch in equality check",
          binary_expr.span,
          "unknown"
        );
      }
    }
    if (binary_expr.binOp instanceof CondOp) {
      if (!type_is_bool) {
        this.emit(
          "Type mismatch in conditional check",
          binary_expr.span,
          "unknown"
        );
      }
    }
  }
  checkNameExpr(nameExpr) {
    const type = this.scope?.lookup(nameExpr.name);
    if (!type) {
      this.emit("Variable not found", nameExpr.span, nameExpr.name);
    }
  }
  checkArrNameExpr(arrNameExpr) {
    const type = this.scope?.lookup(arrNameExpr.name);
    if (!type) {
      this.emit("Variable not found", arrNameExpr.span, arrNameExpr.name);
    }
  }
  checkMethodCallExpr(methodCallExpr) {
    const closestVar = this.scope?.lookup(methodCallExpr.methodName);
    const method = this.program.methods.get(methodCallExpr.methodName);
    if (closestVar && !(closestVar instanceof Method)) {
      this.emit(
        "Most direct declaration of method is shadowed by a variable",
        methodCallExpr.span,
        methodCallExpr.methodName
      );
    }
    const imports = this.program.imports.get(methodCallExpr.methodName);
    if (!method && !imports) {
      this.emit(
        "Method not found",
        methodCallExpr.span,
        methodCallExpr.methodName
      );
      return;
    }
    if (imports) {
      methodCallExpr.args.filter((arg) => !(arg instanceof StringLiteral)).forEach((arg) => {
        this.checkExpr(arg);
        const type = this.inferType(arg);
        if (type instanceof InvalidType || type instanceof VoidType) {
          this.emit(
            "Invalid type in method call",
            methodCallExpr.span,
            methodCallExpr.methodName
          );
        }
      });
      return;
    }
    if (method && method.span.start.line > methodCallExpr.span.start.line) {
      this.emit(
        "Method called before declaration",
        methodCallExpr.span,
        methodCallExpr.methodName
      );
      return;
    }
    if (method && method.params.ordered_params.length !== methodCallExpr.args.length) {
      this.emit(
        "Method call has incorrect number of arguments",
        methodCallExpr.span,
        methodCallExpr.methodName
      );
      return;
    }
    for (let i2 = 0; i2 < methodCallExpr.args.length; i2++) {
      const arg = methodCallExpr.args[i2];
      const param = method?.params.ordered_params[i2];
      if (!param) {
        this.emit(
          "Method call has too many arguments",
          methodCallExpr.span,
          methodCallExpr.methodName
        );
        return;
      }
      const argType = this.inferType(arg);
      const paramType = param[1].type;
      if (!argType.equals(paramType)) {
        this.emit(
          "Type mismatch in method call argument, expected " + paramType.constructor.name + " but got " + argType.constructor.name,
          methodCallExpr.span,
          methodCallExpr.methodName
        );
        return;
      }
    }
  }
  checkCastExpr(castExpr) {
    if (castExpr.constructor.name == "IntCastExpr" || castExpr.constructor.name == "LongCastExpr") {
      if (!(this.inferType(castExpr.expr).equals(new IntType()) || this.inferType(castExpr.expr).equals(new LongType()))) {
        this.emit("Type mismatch in cast expression", castExpr.span, "unknown");
      }
    }
  }
  checkLenExpr(lenExpr) {
    const name = lenExpr.name;
    const type = this.scope?.lookup(name);
    if (type === null || !(type instanceof ArrayType)) {
      this.emit(
        "Argument of len operator must be an array variable",
        lenExpr.span,
        name
      );
    }
  }
  checkBinExpr(binExpr) {
    if (binExpr.binOp instanceof EqOp) {
      if (!this.inferType(binExpr.expr1).equals(this.inferType(binExpr.expr2))) {
        this.emit("Type mismatch in equality check", binExpr.span, "unknown");
      }
    } else if (binExpr.binOp instanceof ArithOp || binExpr.binOp instanceof RelationOp) {
      if (!(this.inferType(binExpr.expr1).equals(new IntType()) && this.inferType(binExpr.expr1).equals(new LongType()) && this.inferType(binExpr.expr2).equals(new IntType()) && this.inferType(binExpr.expr2).equals(new LongType()))) {
        this.emit(
          "Type mismatch in binary expression",
          binExpr.span,
          "unknown"
        );
      }
    } else if (binExpr.binOp instanceof CondOp) {
      if (!this.inferType(binExpr.expr1).equals(new BoolType()) || !this.inferType(binExpr.expr2).equals(new BoolType())) {
        this.emit(
          "Type mismatch in binary expression",
          binExpr.span,
          "unknown"
        );
      }
    }
  }
  checkNotExpr(notExpr) {
    if (!this.inferType(notExpr.expr).equals(new BoolType())) {
      this.emit("Type mismatch in not expression", notExpr.span, "unknown");
    }
  }
  checkUnaryOperation(unaryOperation) {
    if (!(this.inferType(unaryOperation.expr).equals(new IntType()) || this.inferType(unaryOperation.expr).equals(new LongType()))) {
      this.emit(
        "Type mismatch in unary operation",
        unaryOperation.span,
        "unknown"
      );
    }
  }
  getMethodReturnType(methodName) {
    const method = this.program.methods.get(methodName);
    const imports = this.program.imports.get(methodName);
    if (method) {
      return method.returnType;
    }
    if (imports) {
      return new IntType();
    }
    return new InvalidType();
  }
  // checks if no matter which flow we take in the block body, the method will always return
  checkBlockStrictReturns(block) {
    for (const statement of block.statements) {
      if (statement instanceof Return) {
        return true;
      }
      if (statement instanceof IfElse) {
        const trueBodyReturns = this.checkBlockStrictReturns(
          statement.trueBody
        );
        if (!trueBodyReturns) {
          continue;
        }
        if (statement.falseBody) {
          if (this.checkBlockStrictReturns(statement.falseBody)) {
            return true;
          }
        }
      }
    }
    return false;
  }
}
function isConstantStr(posUse) {
  const constRegex = /^-?[0-9]+[Lb]?$/;
  return constRegex.test(posUse);
}
var literalType = /* @__PURE__ */ ((literalType2) => {
  literalType2[literalType2["bool"] = 0] = "bool";
  literalType2[literalType2["int"] = 1] = "int";
  literalType2[literalType2["long"] = 2] = "long";
  return literalType2;
})(literalType || {});
class BranchBlocks {
  constructor(conditionVar, trueBlock, falseBlock) {
    this.conditionVar = conditionVar;
    this.trueBlock = trueBlock;
    this.falseBlock = falseBlock;
  }
}
class BasicBlock {
  constructor(label, curScope, parentScope, instructions, phiInstructions) {
    this.label = label;
    this.curScope = curScope;
    this.parentScope = parentScope;
    this.mutPredecessorBlocks = [];
    this.allDomPredecessors = /* @__PURE__ */ new Set();
    this.successors = [];
    this.predecessors = [];
    this.domSuccessors = [];
    this.domPredecessors = [];
    this.in = /* @__PURE__ */ new Set();
    this.out = /* @__PURE__ */ new Set();
    this.cpIn = /* @__PURE__ */ new Set();
    this.cpOut = /* @__PURE__ */ new Set();
    this.aeIn = /* @__PURE__ */ new Set();
    this.aeOut = /* @__PURE__ */ new Set();
    this.instructions = [new LabelInstruction(label), ...instructions];
    this.phiInstructions = phiInstructions || [];
    this.branchSuccessors = null;
    this.joinSuccessor = null;
    this.mutPredecessors = /* @__PURE__ */ new Set();
  }
  //duplicates the current block shallowly
  duplicate() {
    const dupBlock = new BasicBlock(
      this.label,
      this.curScope,
      this.parentScope,
      []
    );
    dupBlock.instructions = this.instructions.map((inst) => inst.duplicate());
    dupBlock.branchSuccessors = this.branchSuccessors === null ? null : new BranchBlocks(
      this.branchSuccessors.conditionVar,
      this.branchSuccessors.trueBlock,
      this.branchSuccessors.falseBlock
    );
    dupBlock.joinSuccessor = this.joinSuccessor;
    dupBlock.mutPredecessors = new Set(this.mutPredecessors);
    dupBlock.mutPredecessorBlocks = this.mutPredecessorBlocks.slice();
    return dupBlock;
  }
  toString() {
    const instStr = this.instructions.map((inst) => inst.toString()).join("\n");
    return `${instStr}`.trim();
  }
  getSuccessors() {
    if (this.joinSuccessor !== null) {
      return [this.joinSuccessor];
    } else if (this.branchSuccessors !== null) {
      return [
        this.branchSuccessors.trueBlock,
        this.branchSuccessors.falseBlock
      ];
    }
    return [];
  }
  getPredecessors() {
    return this.mutPredecessorBlocks;
  }
  popPredecessor(predecessor) {
    this.mutPredecessors.delete(predecessor.label);
    this.mutPredecessorBlocks = this.mutPredecessorBlocks.filter(
      (p2) => p2.label !== predecessor.label
    );
  }
}
class Instruction {
  constructor(weight = 1) {
    this.weight = weight;
    this.destReg = null;
  }
  toString() {
    return "Instruction";
  }
  getDest() {
    return null;
  }
  getSrcs() {
    return [];
  }
  replaceSrcs(srcMap) {
    return false;
  }
  isConstant() {
    return this.getSrcs().every((src) => isConstantStr(src));
  }
  setReg(reg) {
    if (this.destReg !== null) {
      throw new Error("destReg already set, webs didn't merge correctly");
    }
    this.destReg = reg;
  }
  addMethodNameToVarName(methodName, program) {
    throw new Error("addMethodNameToVarName not implemented for Instruction");
  }
  duplicate() {
    throw new Error("duplicate not implemented for Instruction");
  }
}
class NegateInstruction extends Instruction {
  constructor(src, dest) {
    super();
    this.src = src;
    this.dest = dest;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    return `${regStr} Negate: ${this.dest} <- !${this.src}`;
  }
  getDest() {
    return this.dest;
  }
  getSrcs() {
    return [this.src].filter((arg) => !isConstantStr(arg));
  }
  replaceSrcs(srcMap) {
    if (srcMap.has(this.src)) {
      this.src = srcMap.get(this.src);
      return true;
    }
    return false;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new NegateInstruction(this.src, this.dest);
  }
}
class BinOpInstruction extends Instruction {
  constructor(expr1, binOp, expr2, dest) {
    super();
    this.expr1 = expr1;
    this.binOp = binOp;
    this.expr2 = expr2;
    this.dest = dest;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    return `${regStr} Binary Operation ${this.dest} <- ${this.expr1} ${this.binOp.toString()} ${this.expr2}`;
  }
  getDest() {
    return this.dest;
  }
  getSrcs() {
    return [this.expr1, this.expr2].filter((arg) => !isConstantStr(arg));
  }
  replaceSrcs(srcMap) {
    let hasChanged = false;
    if (srcMap.has(this.expr1)) {
      this.expr1 = srcMap.get(this.expr1);
      hasChanged = true;
    }
    if (srcMap.has(this.expr2)) {
      this.expr2 = srcMap.get(this.expr2);
      hasChanged = true;
    }
    return hasChanged;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.expr1.includes("[")) {
      let arrayName = this.expr1.split("[")[0];
      let index = this.expr1.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.expr1 = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.expr1) && !isConstantStr(this.expr1)) {
      this.expr1 = `${methodName}_${this.expr1}`;
    }
    if (this.expr2.includes("[")) {
      let arrayName = this.expr2.split("[")[0];
      let index = this.expr2.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.expr2 = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.expr2) && !isConstantStr(this.expr2)) {
      this.expr2 = `${methodName}_${this.expr2}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new BinOpInstruction(this.expr1, this.binOp, this.expr2, this.dest);
  }
}
class CopyInstruction extends Instruction {
  constructor(dest, src) {
    super();
    this.dest = dest;
    this.src = src;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    return `${regStr} Copy: ${this.dest} <- ${this.src}`;
  }
  getCombinedSrc() {
    return this.src;
  }
  getCombinedDest() {
    return this.dest;
  }
  getDest() {
    return this.dest;
  }
  getSrcs() {
    return [this.src].filter((arg) => !isConstantStr(arg));
  }
  replaceSrcs(srcMap) {
    if (srcMap.has(this.src)) {
      this.src = srcMap.get(this.src);
      return true;
    }
    return false;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new CopyInstruction(this.dest, this.src);
  }
}
class LoadConstantInstruction extends Instruction {
  constructor(dest, value, literalType2) {
    super();
    this.dest = dest;
    this.value = value;
    this.literalType = literalType2;
  }
  getNumericRep() {
    if (this.literalType === 0) {
      return `${this.value}b`;
    } else if (this.literalType === 1) {
      return this.value;
    } else if (this.literalType === 2) {
      return `${this.value}L`;
    }
    return this.value;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    if (this.literalType === 0) {
      return `${regStr} Load Bool Constant: ${this.dest} <- ${this.value}`;
    } else if (this.literalType === 1) {
      return `${regStr} Load Int Constant: ${this.dest} <- ${this.value}`;
    } else if (this.literalType === 2) {
      return `${regStr} Load Long Constant: ${this.dest} <- ${this.value}`;
    }
    return `${regStr} Load Constant: ${this.dest} <- ${this.value}`;
  }
  getDest() {
    return this.dest;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new LoadConstantInstruction(this.dest, this.value, this.literalType);
  }
}
class CallInstruction extends Instruction {
  constructor(methodName, args, returnVar) {
    super();
    this.methodName = methodName;
    this.args = args;
    this.returnVar = returnVar;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    if (this.returnVar) {
      return `${regStr} ${this.returnVar} <- ${this.methodName}(${this.args.join(", ")})`;
    }
    return `${this.methodName}(${this.args.join(", ")})`;
  }
  getSrcs() {
    return this.args.filter((arg) => !(arg instanceof StringLiteral)).filter((arg) => {
      return !isConstantStr(arg);
    });
  }
  getDest() {
    return this.returnVar ? this.returnVar : null;
  }
  replaceSrcs(srcMap) {
    let hasChanged = false;
    this.args = this.args.map((arg) => {
      if (arg instanceof StringLiteral) {
        return arg;
      }
      if (srcMap.has(arg)) {
        hasChanged = true;
        return srcMap.get(arg);
      }
      return arg;
    });
    return hasChanged;
  }
  addMethodNameToVarName(methodName, program) {
    this.args = this.args.map((arg) => {
      if (!(arg instanceof StringLiteral) && arg.includes("[")) {
        let arrayName = arg.split("[")[0];
        let index = arg.split("[")[1].split("]")[0];
        if (!program.isGlobalVariable(arrayName)) {
          arrayName = `${methodName}_${arrayName}`;
        }
        if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
          index = `${methodName}_${index}`;
        }
        return `${arrayName}[${index}]`;
      } else if (!(arg instanceof StringLiteral) && !program.isGlobalVariable(arg) && !isConstantStr(arg)) {
        return `${methodName}_${arg}`;
      } else {
        return arg;
      }
    });
    if (this.returnVar && this.returnVar.includes("[")) {
      let arrayName = this.returnVar.split("[")[0];
      let index = this.returnVar.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.returnVar = `${arrayName}[${index}]`;
    } else if (this.returnVar && !program.isGlobalVariable(this.returnVar) && !isConstantStr(this.returnVar)) {
      this.returnVar = `${methodName}_${this.returnVar}`;
    }
  }
  duplicate() {
    return new CallInstruction(this.methodName, this.args, this.returnVar);
  }
}
class JumpBoolInstruction extends Instruction {
  constructor(conditionVar, currentLabel, trueLabel, falseLabel) {
    super();
    this.conditionVar = conditionVar;
    this.currentLabel = currentLabel;
    this.trueLabel = trueLabel;
    this.falseLabel = falseLabel;
  }
  toString() {
    return `Jump Bool: if ${this.conditionVar} then ${this.trueLabel} else ${this.falseLabel}`;
  }
  getSrcs() {
    return [this.conditionVar].filter((arg) => !isConstantStr(arg));
  }
  replaceSrcs(srcMap) {
    if (srcMap.has(this.conditionVar)) {
      this.conditionVar = srcMap.get(this.conditionVar);
      return true;
    }
    return false;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.conditionVar.includes("[")) {
      let arrayName = this.conditionVar.split("[")[0];
      let index = this.conditionVar.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.conditionVar = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.conditionVar) && !isConstantStr(this.conditionVar)) {
      this.conditionVar = `${methodName}_${this.conditionVar}`;
    }
  }
  duplicate() {
    return new JumpBoolInstruction(this.conditionVar, this.currentLabel, this.trueLabel, this.falseLabel);
  }
}
class LeftShiftInstruction extends BinOpInstruction {
  constructor(dest, src, amount, isNegative) {
    super(src, new LeftShiftOp(), amount, dest);
    this.dest = dest;
    this.src = src;
    this.amount = amount;
    this.isNegative = isNegative;
  }
  getSrcs() {
    return [this.src];
  }
  getDest() {
    return this.dest;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    if (this.isNegative) {
      return `${regStr} left Shift: ${this.dest} <- -(${this.src} << ${this.amount})`;
    }
    return `${regStr} left Shift: ${this.dest} <- ${this.src} << ${this.amount}`;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new LeftShiftInstruction(this.dest, this.src, this.amount, this.isNegative);
  }
}
class AndModInstruction extends BinOpInstruction {
  constructor(dest, src, amount) {
    super(src, new BitAndOp(), amount, dest);
    this.dest = dest;
    this.src = src;
    this.amount = amount;
  }
  getSrcs() {
    return [this.src];
  }
  getDest() {
    return this.dest;
  }
  getAmountShifted() {
    if (this.amount.endsWith("L")) {
      return `${BigInt(this.amount.slice(0, -1)) - 1n}L`;
    }
    return (BigInt(this.amount) - 1n).toString();
  }
  getAmountAnded() {
    return this.amount;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    return `${regStr} and mod : ${this.dest} <- ${this.src} & ${this.getAmountShifted()}`;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new AndModInstruction(this.dest, this.src, this.amount);
  }
}
class RightShiftInstruction extends BinOpInstruction {
  constructor(dest, src, amount, isNegative) {
    super(src, new RightShiftOp(), amount, dest);
    this.dest = dest;
    this.src = src;
    this.amount = amount;
    this.isNegative = isNegative;
  }
  getSrcs() {
    return [this.src];
  }
  getDest() {
    return this.dest;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    if (this.isNegative) {
      return `${regStr} right Shift: ${this.dest} <- -(${this.src} >> ${this.amount})`;
    }
    return `${regStr} right Shift: ${this.dest} <- ${this.src} >> ${this.amount}`;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new RightShiftInstruction(this.dest, this.src, this.amount, this.isNegative);
  }
}
class MagicDivideInstruction extends BinOpInstruction {
  constructor(dest, src, magicNum, shiftNum, addNum) {
    super(src, new DivideOp(), magicNum.toString(), dest);
    this.dest = dest;
    this.src = src;
    this.magicNum = magicNum;
    this.shiftNum = shiftNum;
    this.addNum = addNum;
  }
  getSrcs() {
    return [this.src];
  }
  getDest() {
    return this.dest;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    return `${regStr} magic divide: ${this.dest} <- ((uint64)${this.src} * ${this.magicNum}) >> ${this.shiftNum}`;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new MagicDivideInstruction(this.dest, this.src, this.magicNum, this.shiftNum, this.addNum);
  }
}
class CastInstruction extends Instruction {
  constructor(dest, src, castType) {
    super();
    this.dest = dest;
    this.src = src;
    this.castType = castType;
  }
  toString() {
    const regStr = this.destReg ? `(${this.destReg})` : "";
    if (this.castType === 0) {
      return `${regStr} Cast: ${this.dest} <- ${this.src} (bool)`;
    } else if (this.castType === 1) {
      return `${regStr} Cast: ${this.dest} <- ${this.src} (int)`;
    } else if (this.castType === 2) {
      return `${regStr} Cast: ${this.dest} <- ${this.src} (long)`;
    }
    return `${regStr} Cast: ${this.dest} <- ${this.src}`;
  }
  getDest() {
    return this.dest;
  }
  getSrcs() {
    return [this.src].filter((arg) => !isConstantStr(arg));
  }
  replaceSrcs(srcMap) {
    if (srcMap.has(this.src)) {
      this.src = srcMap.get(this.src);
      return true;
    }
    return false;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
    if (this.dest.includes("[")) {
      let arrayName = this.dest.split("[")[0];
      let index = this.dest.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.dest = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.dest) && !isConstantStr(this.dest)) {
      this.dest = `${methodName}_${this.dest}`;
    }
  }
  duplicate() {
    return new CastInstruction(this.dest, this.src, this.castType);
  }
}
class ReturnInstruction extends Instruction {
  // a return can either return something or nothing
  constructor(src) {
    super();
    this.src = src;
    this.src = src;
  }
  toString() {
    return this.src ? `return ${this.src}` : "return";
  }
  getSrcs() {
    return this.src ? [this.src].filter((arg) => !isConstantStr(arg)) : [];
  }
  replaceSrcs(srcMap) {
    if (this.src === null) {
      return false;
    }
    if (srcMap.has(this.src)) {
      this.src = srcMap.get(this.src);
      return true;
    }
    return false;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.src && this.src.includes("[")) {
      let arrayName = this.src.split("[")[0];
      let index = this.src.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.src = `${arrayName}[${index}]`;
    } else if (this.src && !program.isGlobalVariable(this.src) && !isConstantStr(this.src)) {
      this.src = `${methodName}_${this.src}`;
    }
  }
  duplicate() {
    return new ReturnInstruction(this.src);
  }
}
class JumpDirectInstruction extends Instruction {
  constructor(label, target) {
    super();
    this.label = label;
    this.target = target;
    this.target = target;
  }
  toString() {
    return `Jump Direct: goto ${this.label}`;
  }
  addMethodNameToVarName(methodName, program) {
  }
  duplicate() {
    return new JumpDirectInstruction(this.label, this.target);
  }
}
class LabelInstruction extends Instruction {
  constructor(label) {
    super();
    this.label = label;
  }
  toString() {
    return `Label: ${this.label}:`;
  }
  addMethodNameToVarName(methodName, program) {
  }
  duplicate() {
    return new LabelInstruction(this.label);
  }
}
class CreateArrayInstruction extends Instruction {
  constructor(name, size, dataType) {
    super();
    this.name = name;
    this.size = size;
    this.dataType = dataType;
  }
  toString() {
    return `Create Array: ${this.name}[${this.size}] of type ${this.dataType}`;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.name.includes("[")) {
      let arrayName = this.name.split("[")[0];
      let index = this.name.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.name = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.name) && !isConstantStr(this.name)) {
      this.name = `${methodName}_${this.name}`;
    }
  }
  duplicate() {
    return new CreateArrayInstruction(this.name, this.size, this.dataType);
  }
}
class CreateVarInstruction extends Instruction {
  constructor(name, dataType) {
    super();
    this.name = name;
    this.dataType = dataType;
  }
  toString() {
    return `Create Variable: ${this.name} of type ${this.dataType}`;
  }
  getDest() {
    return this.name;
  }
  addMethodNameToVarName(methodName, program) {
    if (this.name.includes("[")) {
      let arrayName = this.name.split("[")[0];
      let index = this.name.split("[")[1].split("]")[0];
      if (!program.isGlobalVariable(arrayName)) {
        arrayName = `${methodName}_${arrayName}`;
      }
      if (!program.isGlobalVariable(index) && !isConstantStr(index)) {
        index = `${methodName}_${index}`;
      }
      this.name = `${arrayName}[${index}]`;
    } else if (!program.isGlobalVariable(this.name) && !isConstantStr(this.name)) {
      this.name = `${methodName}_${this.name}`;
    }
  }
  duplicate() {
    return new CreateVarInstruction(this.name, this.dataType);
  }
}
class Loop {
  constructor(breakTo, continueTo) {
    this.breakTo = breakTo;
    this.continueTo = continueTo;
  }
  toString() {
    return "Loop";
  }
  addMethodNameToVarName(methodName, program) {
  }
  duplicate() {
    return new Loop(this.breakTo, this.continueTo);
  }
}
function areSetsEqual(set1, set2) {
  return setUnion(set1, set2).size === setIntersection(set1, set2).size;
}
function setSample(set) {
  return set.values().next().value;
}
function setPop(set) {
  if (set.size === 0) {
    throw new Error("Set is empty");
  }
  const poppedVal = set.values().next().value;
  set.delete(poppedVal);
  return poppedVal;
}
function setUnion(a2, b2) {
  const fusedArray = [...a2, ...b2];
  const stringSet = new Set(fusedArray.map((x2) => x2.toString()));
  const filteredArray = fusedArray.filter((elt) => {
    const hasElt = stringSet.has(elt.toString());
    stringSet.delete(elt.toString());
    return hasElt;
  });
  return new Set(filteredArray);
}
function strictSetUnion(a2, b2) {
  return /* @__PURE__ */ new Set([...a2, ...b2]);
}
function setIntersection(a2, b2) {
  const stringSet = new Set([...b2].map((x2) => x2.toString()));
  return new Set([...a2].filter((x2) => stringSet.has(x2.toString())));
}
function strictSetIntersection(a2, b2) {
  return new Set([...a2].filter((elt) => b2.has(elt)));
}
function setDifference(a2, b2) {
  const stringSet = new Set([...b2].map((x2) => x2.toString()));
  return new Set([...a2].filter((x2) => !stringSet.has(x2.toString())));
}
function getSplitName(name) {
  const splitName = name.split(/\[|\]/);
  if (splitName.length > 1) {
    return splitName[1];
  }
  return splitName[0];
}
function safeExtractNum(value) {
  const intParse = safeParseInt(value);
  const longParse = safeParseLong(value);
  const boolParse = safeParseBool(value);
  if (longParse !== null) {
    return `${longParse}L`;
  }
  if (intParse !== null) {
    return intParse.toString();
  }
  if (boolParse !== null) {
    return `${boolParse}b`;
  }
  return null;
}
function safeParseLong(value) {
  if (/^-?\d+L$/.test(value)) {
    return BigInt(value.slice(0, -1));
  }
  return null;
}
function safeParseInt(value) {
  if (/^-?\d+$/.test(value)) {
    return BigInt(value);
  }
  return null;
}
function safeParseBool(value) {
  if (/^-?\d+b$/.test(value)) {
    return value.slice(0, -1);
  }
  return null;
}
function foldInstr(instr) {
  if (instr instanceof BinOpInstruction) {
    return foldBinOpInstr(instr);
  }
  return instr;
}
function foldBinOpInstr(instr) {
  const fakeSpan = new Span(new Position(-1, -1), new Position(-1, -1));
  const num1 = safeParseInt(instr.expr1);
  const num2 = safeParseInt(instr.expr2);
  const num1L = safeParseLong(instr.expr1);
  const num2L = safeParseLong(instr.expr2);
  const num1b = safeParseBool(instr.expr1);
  const num2b = safeParseBool(instr.expr2);
  if (num1L !== null && num2L !== null) {
    const tempExpr1 = new LongLiteral(BigInt(num1L), fakeSpan);
    const tempExpr2 = new LongLiteral(BigInt(num2L), fakeSpan);
    const wrapperExpr = new BinExpr(
      tempExpr1,
      instr.binOp,
      tempExpr2,
      fakeSpan
    );
    const result = ControlFlowGraph.constantFold(wrapperExpr);
    if (result instanceof BoolLiteral) {
      return new CopyInstruction(instr.dest, result.b ? "1b" : "0b");
    }
    if (result instanceof LongLiteral) {
      return new CopyInstruction(instr.dest, `${result.val.toString()}L`);
    }
  }
  if (num1 !== null && num2 !== null) {
    const tempExpr1 = new IntLiteral(Number(num1), fakeSpan);
    const tempExpr2 = new IntLiteral(Number(num2), fakeSpan);
    const wrapperExpr = new BinExpr(
      tempExpr1,
      instr.binOp,
      tempExpr2,
      fakeSpan
    );
    const result = ControlFlowGraph.constantFold(wrapperExpr);
    if (result instanceof BoolLiteral) {
      return new CopyInstruction(instr.dest, result.b ? "1b" : "0b");
    }
    if (result instanceof IntLiteral) {
      return new CopyInstruction(instr.dest, result.val.toString());
    }
  }
  if (num1b !== null && num2b !== null) {
    const tempExpr1 = new BoolLiteral(num1b === "1", fakeSpan);
    const tempExpr2 = new BoolLiteral(num2b === "1", fakeSpan);
    const wrapperExpr = new BinExpr(
      tempExpr1,
      instr.binOp,
      tempExpr2,
      fakeSpan
    );
    const result = ControlFlowGraph.constantFold(wrapperExpr);
    return new CopyInstruction(instr.dest, result.b ? "1b" : "0b");
  }
  return instr;
}
function isArrayVariable(key) {
  return getSplitName(key) !== key;
}
function getPowOf2(numStr) {
  const isNotInt = numStr.endsWith("b") || numStr.endsWith("L");
  const extension = isNotInt ? numStr.slice(-1) : "";
  const parsedNum = isNotInt ? numStr.slice(0, -1) : numStr;
  try {
    const n2 = BigInt(parsedNum);
    if (n2 <= 0n || (n2 & n2 - 1n) !== 0n) return null;
    let exponent = 0;
    let value = n2;
    while (value > 1n) {
      value >>= 1n;
      exponent++;
    }
    return exponent.toString() + extension;
  } catch {
    return null;
  }
}
function getNegPowOf2(numStr) {
  if (!numStr.startsWith("-")) {
    return null;
  }
  return getPowOf2(numStr.slice(1));
}
function collectAllBlocks(entry) {
  const visited = /* @__PURE__ */ new Set();
  const stack = [entry];
  while (stack.length > 0) {
    const block = stack.pop();
    if (!visited.has(block)) {
      visited.add(block);
      if (block.joinSuccessor) stack.push(block.joinSuccessor);
      if (block.branchSuccessors) {
        stack.push(block.branchSuccessors.trueBlock);
        stack.push(block.branchSuccessors.falseBlock);
      }
    }
  }
  return Array.from(visited);
}
function removeRedundantMoves(asm) {
  const lines = asm.split("\n");
  const optimizedLines = [];
  const skippedIndices = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < lines.length; i2++) {
    if (skippedIndices.has(i2)) continue;
    const currentLine = lines[i2].trim();
    if (!currentLine) {
      optimizedLines.push(lines[i2]);
      continue;
    }
    if (currentLine.endsWith(":") || currentLine.startsWith("j")) {
      optimizedLines.push(lines[i2]);
      continue;
    }
    if (currentLine.startsWith("mov")) {
      const nextLine = i2 + 1 < lines.length ? lines[i2 + 1].trim() : "";
      if (nextLine.startsWith("mov")) {
        const currentArgs = currentLine.split(",").map((arg) => arg.trim());
        const nextArgs = nextLine.split(",").map((arg) => arg.trim());
        if (currentArgs[0] === nextArgs[1] && currentArgs[1] === nextArgs[0]) {
          skippedIndices.add(i2 + 1);
          continue;
        }
      }
      if (currentLine.includes("$0") && nextLine.startsWith("xor")) {
        const reg = currentLine.split(",")[1].trim();
        if (nextLine.includes(reg)) {
          skippedIndices.add(i2 + 1);
          optimizedLines.push(
            `xor${currentLine.includes("q") ? "q" : "l"} ${reg}, ${reg}`
          );
          continue;
        }
      }
    }
    if (currentLine.startsWith("subq $") && currentLine.endsWith(", %rsp")) {
      const nextLine = i2 + 1 < lines.length ? lines[i2 + 1].trim() : "";
      if (nextLine.startsWith("addq $") && nextLine.endsWith(", %rsp")) {
        const subAmount = parseInt(currentLine.split("$")[1]);
        const addAmount = parseInt(nextLine.split("$")[1]);
        if (subAmount === addAmount) {
          skippedIndices.add(i2 + 1);
          continue;
        }
      }
    }
    optimizedLines.push(lines[i2]);
  }
  return optimizedLines.join("\n");
}
class ControlFlowGraph {
  constructor(program) {
    this.orderedDataTypes = [];
    this.scopeRenames = /* @__PURE__ */ new Map();
    this.scopeParents = /* @__PURE__ */ new Map();
    this.instrWeight = 1;
    this.program = program;
    this.nextTempId = 0;
    this.orderedMethods = [];
    this.labelCounter = 0;
    this.scopeCounter = 1;
    this.curScope = 0;
    program.natives.forEach((dataType, name) => {
      this.addRename(-1, name);
    });
    this.scopeParents.set(0, -1);
  }
  genPurgeArr(statements) {
    let skipStatement = false;
    const skipStatements = statements.map((stmt) => {
      if (skipStatement) {
        return true;
      }
      if (stmt instanceof Continue || stmt instanceof Break) {
        skipStatement = true;
        return false;
      }
      return false;
    });
    return skipStatements;
  }
  isGlobalVariable(key) {
    return this.getGlobals().has(key);
  }
  addRename(scope, name) {
    const nameUsed = scope === -1 ? name : `${name}_${scope}`;
    if (!this.scopeRenames.has(scope)) {
      this.scopeRenames.set(scope, []);
    }
    this.scopeRenames.get(scope)?.push(nameUsed);
  }
  getRename(name) {
    if (safeParseInt(name)) {
      return name;
    }
    let scope = this.curScope;
    let expectedRename = scope === -1 ? name : `${name}_${scope}`;
    while (!this.scopeRenames.get(scope)?.includes(expectedRename)) {
      scope = this.scopeParents.get(scope);
      expectedRename = scope === -1 ? name : `${name}_${scope}`;
    }
    return expectedRename;
  }
  clearRenames() {
    const globalNames = this.scopeRenames.get(-1);
    this.scopeRenames.clear();
    this.scopeRenames.set(-1, globalNames);
  }
  getNextTempVar() {
    this.nextTempId += 1;
    return `t${this.nextTempId}`;
  }
  //takes in the entryBlock of each method ??? if each method has multple BasicBlocks
  buildCFG() {
    const controlFlowGraphs = [];
    this.program.methods.forEach((method) => {
      method.params.ordered_params.forEach(([param, field], index) => {
        this.addRename(this.curScope, param);
        method.params.ordered_params[index][0] = this.getRename(param);
      });
      controlFlowGraphs.push(this.buildMethodCFG(method));
      this.orderedMethods.push(method.method_name);
      this.orderedDataTypes.push(method.returnType);
      this.clearRenames();
    });
    return controlFlowGraphs;
  }
  buildFields(curBlock, scope) {
    scope.symbols.forEach((field) => {
      if (field.type instanceof ArrayType) {
        const size = field.type.array_size;
        curBlock.instructions.push(
          new CreateArrayInstruction(field.name, size, field.type)
        );
        return;
      }
      this.addRename(this.curScope, field.name);
      curBlock.instructions.push(
        new CreateVarInstruction(this.getRename(field.name), field.type)
      );
    });
  }
  getGlobals() {
    const globals = /* @__PURE__ */ new Set();
    for (const variable of this.program.natives.keys()) {
      globals.add(variable);
    }
    return globals;
  }
  //need to include children and predecessors if only returning entryBlock
  //currently dont have access to other blocks
  buildMethodCFG(method) {
    const entryBlock = new BasicBlock(
      method.method_name,
      this.curScope,
      this.curScope,
      []
    );
    let curBlock = entryBlock;
    const fakeEntry = new BasicBlock("fakeEntry", -27, -27, []);
    this.addPredecessor(curBlock, fakeEntry);
    this.buildFields(curBlock, method.body.scope);
    method.params.ordered_params.forEach(([param, field], index) => {
      this.addRename(this.curScope, param);
    });
    method.body.statements.forEach((statement) => {
      curBlock = this.buildStatement(statement, curBlock, null, method);
    });
    entryBlock.popPredecessor(fakeEntry);
    return entryBlock;
  }
  buildExpression(expr, curBlock, method) {
    {
      const newExpr = ControlFlowGraph.constantFold(expr);
      if (newExpr !== expr) {
        return this.buildExpression(newExpr, curBlock, method);
      }
    }
    if (expr instanceof NegativeExpr) {
      const dest = this.getNextTempVar();
      const negatedExpr = expr.expr;
      if (negatedExpr instanceof IntLiteral) {
        const negatedInstr = new LoadConstantInstruction(
          dest,
          (-negatedExpr.val).toString(),
          literalType.int
        );
        negatedInstr.weight = this.instrWeight;
        curBlock.instructions.push(negatedInstr);
        return [curBlock, dest];
      } else if (negatedExpr instanceof LongLiteral) {
        const negatedInstr = new LoadConstantInstruction(
          dest,
          (-negatedExpr.val).toString(),
          literalType.long
        );
        negatedInstr.weight = this.instrWeight;
        curBlock.instructions.push(negatedInstr);
        return [curBlock, dest];
      } else {
        let tempDest = "";
        [curBlock, tempDest] = this.buildExpression(
          expr.expr,
          curBlock,
          method
        );
        const negateInstr = new NegateInstruction(tempDest, dest);
        negateInstr.weight = this.instrWeight;
        curBlock.instructions.push(negateInstr);
      }
      return [curBlock, dest];
    } else if (expr instanceof NotExpr) {
      const dest = this.getNextTempVar();
      const shortCircuitBlock = this.buildShortCircuitBlocks(
        curBlock,
        expr,
        method,
        dest
      );
      return [shortCircuitBlock, dest];
    } else if (expr instanceof NameExpr) {
      this.getRename(expr.name);
      return [curBlock, this.getRename(expr.name)];
    } else if (expr instanceof ArrNameExpr) {
      const indexExpr = expr.expression;
      if (indexExpr instanceof IntLiteral) {
        const arrIndex = `${expr.name}[${indexExpr.val}]`;
        const indexDest2 = this.getNextTempVar();
        const copyInstr2 = new CopyInstruction(indexDest2, arrIndex);
        copyInstr2.weight = this.instrWeight;
        curBlock.instructions.push(copyInstr2);
        return [curBlock, indexDest2];
      }
      let indexDest;
      [curBlock, indexDest] = this.buildExpression(indexExpr, curBlock, method);
      const rightExprDest = this.getNextTempVar();
      const arraySrc = `${expr.name}[${indexDest}]`;
      const copyInstr = new CopyInstruction(rightExprDest, arraySrc);
      copyInstr.weight = this.instrWeight;
      curBlock.instructions.push(copyInstr);
      return [curBlock, rightExprDest];
    } else if (expr instanceof CastExpr) {
      const dest = this.getNextTempVar();
      const valToCast = expr.expr;
      const castType = expr instanceof IntCastExpr ? literalType.int : literalType.long;
      if (valToCast instanceof IntLiteral || valToCast instanceof LongLiteral) {
        const constantValue = valToCast.val.toString();
        const constantInstr = new LoadConstantInstruction(
          dest,
          constantValue,
          castType
        );
        constantInstr.weight = this.instrWeight;
        curBlock.instructions.push(constantInstr);
      } else {
        let subExprVar;
        [curBlock, subExprVar] = this.buildExpression(
          valToCast,
          curBlock,
          method
        );
        const castInstr = new CastInstruction(dest, subExprVar, castType);
        castInstr.weight = this.instrWeight;
        curBlock.instructions.push(castInstr);
      }
      return [curBlock, dest];
    } else if (expr instanceof LenExpr) {
      const methodBodySymbols = method.body.scope.lookup(expr.name);
      if (!(methodBodySymbols instanceof ArrayType) || methodBodySymbols.array_size === void 0) {
        throw new Error("Could not find array length for " + expr.name);
      }
      const length = methodBodySymbols.array_size.toString();
      const dest = this.getNextTempVar();
      const loadInstr = new LoadConstantInstruction(
        dest,
        length,
        literalType.int
      );
      loadInstr.weight = this.instrWeight;
      curBlock.instructions.push(loadInstr);
      return [curBlock, dest];
    } else if (expr instanceof MethodCallExpr) {
      let args;
      const callReturnVar = this.getNextTempVar();
      [curBlock, args] = this.handleMethodCallArgs(expr.args, curBlock, method);
      const dest = callReturnVar;
      const callInstr = new CallInstruction(
        expr.methodName,
        args,
        callReturnVar
      );
      callInstr.weight = this.instrWeight;
      curBlock.instructions.push(callInstr);
      return [curBlock, dest];
    } else if (expr instanceof BinExpr) {
      const dest = this.getNextTempVar();
      if (expr.binOp instanceof CondOp) {
        const shortCircuitBlock = this.buildShortCircuitBlocks(
          curBlock,
          expr,
          method,
          dest
        );
        return [shortCircuitBlock, dest];
      } else {
        let lhsBlock, rhsDest;
        let lhsDest, rhsBlock;
        [lhsBlock, lhsDest] = this.buildExpression(
          expr.expr1,
          curBlock,
          method
        );
        [rhsBlock, rhsDest] = this.buildExpression(
          expr.expr2,
          lhsBlock,
          method
        );
        const binOpInstr = new BinOpInstruction(
          lhsDest,
          expr.binOp,
          rhsDest,
          dest
        );
        binOpInstr.weight = this.instrWeight;
        rhsBlock.instructions.push(binOpInstr);
        return [rhsBlock, dest];
      }
    } else if (expr instanceof IntLiteral) {
      const dest = this.getNextTempVar();
      const loadInstr = new LoadConstantInstruction(
        dest,
        expr.val.toString(),
        literalType.int
      );
      loadInstr.weight = this.instrWeight;
      curBlock.instructions.push(loadInstr);
      return [curBlock, dest];
    } else if (expr instanceof LongLiteral) {
      const dest = this.getNextTempVar();
      const loadInstr = new LoadConstantInstruction(
        dest,
        expr.val.toString(),
        literalType.long
      );
      loadInstr.weight = this.instrWeight;
      curBlock.instructions.push(loadInstr);
      return [curBlock, dest];
    } else if (expr instanceof BoolLiteral) {
      const dest = this.getNextTempVar();
      const boolLoad = expr.b ? "1" : "0";
      const loadInstr = new LoadConstantInstruction(
        dest,
        boolLoad,
        literalType.bool
      );
      loadInstr.weight = this.instrWeight;
      curBlock.instructions.push(loadInstr);
      return [curBlock, dest];
    }
    return [curBlock, this.getNextTempVar()];
  }
  addBlockSuccessor(curBlock, nextBlock) {
    if (curBlock.joinSuccessor !== null || curBlock.getPredecessors().length === 0) {
      return;
    }
    curBlock.joinSuccessor = nextBlock;
    this.addPredecessor(nextBlock, curBlock);
  }
  addPredecessor(curBlock, predecessor) {
    curBlock.mutPredecessors.add(predecessor.label);
    curBlock.mutPredecessorBlocks.push(predecessor);
  }
  addBlockBranch(curBlock, branchBlock) {
    const trueBlock = branchBlock.trueBlock;
    const falseBlock = branchBlock.falseBlock;
    curBlock.branchSuccessors = branchBlock;
    trueBlock.mutPredecessors.add(curBlock.label);
    trueBlock.mutPredecessorBlocks.push(curBlock);
    falseBlock.mutPredecessors.add(curBlock.label);
    falseBlock.mutPredecessorBlocks.push(curBlock);
    const jumpInstr = new JumpBoolInstruction(
      branchBlock.conditionVar,
      curBlock.label,
      trueBlock.label,
      falseBlock.label
    );
    jumpInstr.weight = this.instrWeight;
    curBlock.instructions.push(jumpInstr);
  }
  static bigIntToNumber(val) {
    const isNegative = val < 0n;
    if (isNegative) {
      val = val * -1n;
      let temp = Number(val & 0xffffffffn);
      return -temp;
    }
    return Number(val & 0xffffffffn);
  }
  static bigIntToLong(val) {
    const isNegative = val < 0n;
    if (isNegative) {
      val = val * -1n;
      let temp = BigInt(val & 0xffffffffffffffffn);
      return -temp;
    }
    return BigInt(val & 0xffffffffffffffffn);
  }
  static constantFold(expr) {
    if (expr instanceof BinExpr) {
      const foldSpan = expr.span;
      const left = this.constantFold(expr.expr1);
      const right = this.constantFold(expr.expr2);
      let cond = null;
      if (left instanceof IntLiteral && right instanceof IntLiteral) {
        let calculation = null;
        switch (expr.binOp.toString()) {
          case "+":
            calculation = BigInt(left.val) + BigInt(right.val);
            break;
          case "-":
            calculation = BigInt(left.val) - BigInt(right.val);
            break;
          case "*":
            calculation = BigInt(left.val) * BigInt(right.val);
            break;
          case "/":
            if (right.val === 0) {
              break;
            }
            calculation = BigInt(left.val) / BigInt(right.val);
            break;
          case "%":
            if (right.val === 0) {
              break;
            }
            calculation = BigInt(left.val) % BigInt(right.val);
            break;
          case "<=":
            cond = BigInt(left.val) <= BigInt(right.val);
            break;
          case "<":
            cond = BigInt(left.val) < BigInt(right.val);
            break;
          case ">=":
            cond = BigInt(left.val) >= BigInt(right.val);
            break;
          case ">":
            cond = left.val > BigInt(right.val);
            break;
          case "==":
            cond = BigInt(left.val) === BigInt(right.val);
            break;
          case "!=":
            cond = BigInt(left.val) !== BigInt(right.val);
            break;
        }
        if (calculation !== null) {
          return new IntLiteral(this.bigIntToNumber(calculation), foldSpan);
        }
        if (cond !== null) {
          return new BoolLiteral(cond, foldSpan);
        }
        if (left === expr.expr1 && right === expr.expr2) {
          return expr;
        }
        return new BinExpr(left, expr.binOp, right, expr.span);
      } else if (left instanceof LongLiteral && right instanceof LongLiteral) {
        let calculation = null;
        switch (expr.binOp.toString()) {
          case "+":
            calculation = BigInt(left.val) + BigInt(right.val);
            break;
          case "-":
            calculation = BigInt(left.val) - BigInt(right.val);
            break;
          case "*":
            calculation = BigInt(left.val) * BigInt(right.val);
            break;
          case "/":
            if (right.val === 0n) {
              break;
            }
            calculation = BigInt(left.val) / BigInt(right.val);
            break;
          case "%":
            if (right.val === 0n) {
              break;
            }
            calculation = BigInt(left.val) % BigInt(right.val);
            break;
          case "<=":
            cond = BigInt(left.val) <= BigInt(right.val);
            break;
          case "<":
            cond = BigInt(left.val) < BigInt(right.val);
            break;
          case ">=":
            cond = BigInt(left.val) >= BigInt(right.val);
            break;
          case ">":
            cond = BigInt(left.val) > BigInt(right.val);
            break;
          case "==":
            cond = BigInt(left.val) === BigInt(right.val);
            break;
          case "!=":
            cond = BigInt(left.val) !== BigInt(right.val);
            break;
        }
        if (calculation !== null) {
          return new LongLiteral(this.bigIntToLong(calculation), foldSpan);
        }
        if (cond !== null) {
          return new BoolLiteral(cond, foldSpan);
        }
        if (left === expr.expr1 && right === expr.expr2) {
          return expr;
        }
        return new BinExpr(left, expr.binOp, right, expr.span);
      } else if (left instanceof BoolLiteral && right instanceof BoolLiteral) {
        switch (expr.binOp.toString()) {
          case "&&":
            return new BoolLiteral(left.b && right.b, foldSpan);
          case "||":
            return new BoolLiteral(left.b || right.b, foldSpan);
          case "==":
            return new BoolLiteral(left.b === right.b, foldSpan);
          case "!=":
            return new BoolLiteral(left.b !== right.b, foldSpan);
        }
        if (left === expr.expr1 && right === expr.expr2) {
          return expr;
        }
        return new BinExpr(left, expr.binOp, right, expr.span);
      }
    }
    if (expr instanceof NotExpr) {
      const foldSpan = expr.span;
      const expr1 = this.constantFold(expr.expr);
      if (expr1 instanceof BoolLiteral) {
        return new BoolLiteral(!expr1.b, foldSpan);
      }
      if (expr1 === expr.expr) {
        return expr;
      }
      return new NotExpr(expr1, expr.span);
    }
    if (expr instanceof IntCastExpr) {
      const foldSpan = expr.span;
      const expr1 = this.constantFold(expr.expr);
      if (expr1 instanceof IntLiteral) {
        return new IntLiteral(expr1.val, foldSpan);
      }
      if (expr1 instanceof LongLiteral) {
        return new IntLiteral(Number(expr1.val & 0xffffffffn), foldSpan);
      }
      if (expr1 === expr.expr) {
        return expr;
      }
      return new IntCastExpr(expr1, expr.span);
    }
    if (expr instanceof LongCastExpr) {
      const foldSpan = expr.span;
      const expr1 = this.constantFold(expr.expr);
      if (expr1 instanceof LongLiteral) {
        return new LongLiteral(expr1.val, foldSpan);
      }
      if (expr1 instanceof IntLiteral) {
        return new LongLiteral(BigInt(expr1.val), foldSpan);
      }
      if (expr1 === expr.expr) {
        return expr;
      }
      return new LongCastExpr(expr1, expr.span);
    }
    if (expr instanceof NegativeExpr) {
      const foldSpan = expr.span;
      const expr1 = this.constantFold(expr.expr);
      if (expr1 instanceof IntLiteral) {
        return new IntLiteral(-expr1.val, foldSpan);
      }
      if (expr1 instanceof LongLiteral) {
        return new LongLiteral(-expr1.val, foldSpan);
      }
      if (expr1 === expr.expr) {
        return expr;
      }
      return new NegativeExpr(expr1, expr.span);
    }
    if (expr instanceof IntLiteral) {
      return expr;
    }
    if (expr instanceof LongLiteral) {
      return expr;
    }
    if (expr instanceof BoolLiteral) {
      return expr;
    }
    return expr;
  }
  //returns join block at the end
  buildShortCircuitBlocks(curBlock, expr, method, dest) {
    const trueLabel = `labelT_${this.labelCounter}`;
    const loadInstr = new LoadConstantInstruction(dest, "1", literalType.bool);
    loadInstr.weight = this.instrWeight;
    const trueBlock = new BasicBlock(
      trueLabel,
      curBlock.curScope,
      curBlock.parentScope,
      [loadInstr]
    );
    const falseLoadInstr = new LoadConstantInstruction(
      dest,
      "0",
      literalType.bool
    );
    falseLoadInstr.weight = this.instrWeight;
    const falseLabel = `labelF_${this.labelCounter}`;
    const falseBlock = new BasicBlock(
      falseLabel,
      curBlock.curScope,
      curBlock.parentScope,
      [falseLoadInstr]
    );
    const endLabel = `end_${this.labelCounter}`;
    const endBlock = new BasicBlock(
      endLabel,
      curBlock.curScope,
      curBlock.parentScope,
      []
    );
    this.labelCounter++;
    this.buildConditional(expr, curBlock, trueBlock, falseBlock, method);
    this.addBlockSuccessor(trueBlock, endBlock);
    this.addBlockSuccessor(falseBlock, endBlock);
    return endBlock;
  }
  buildConditional(expr, entryBlock, trueBlock, falseBlock, method) {
    const scope = entryBlock.curScope;
    const parentScope = entryBlock.parentScope;
    if (expr instanceof BinExpr && expr.binOp instanceof AndOp) {
      const statement2Start = `shortCircuitT_${this.labelCounter++}`;
      const shortCircuitBlock = new BasicBlock(
        statement2Start,
        scope,
        parentScope,
        []
      );
      this.buildConditional(
        expr.expr1,
        entryBlock,
        shortCircuitBlock,
        falseBlock,
        method
      );
      this.buildConditional(
        expr.expr2,
        shortCircuitBlock,
        trueBlock,
        falseBlock,
        method
      );
      return;
    }
    if (expr instanceof BinExpr && expr.binOp instanceof OrOp) {
      const statement2Start = `shortCircuitF_${this.labelCounter++}`;
      const shortCircuitBlock = new BasicBlock(
        statement2Start,
        scope,
        parentScope,
        []
      );
      this.buildConditional(
        expr.expr1,
        entryBlock,
        trueBlock,
        shortCircuitBlock,
        method
      );
      this.buildConditional(
        expr.expr2,
        shortCircuitBlock,
        trueBlock,
        falseBlock,
        method
      );
      return;
    }
    if (expr instanceof NotExpr) {
      this.buildConditional(
        expr.expr,
        entryBlock,
        falseBlock,
        trueBlock,
        method
      );
      return;
    }
    const [curBlock, dest] = this.buildExpression(expr, entryBlock, method);
    const branchBlock = new BranchBlocks(dest, trueBlock, falseBlock);
    this.addBlockBranch(curBlock, branchBlock);
  }
  buildStatement(stmt, curBlock, loop, method) {
    if (stmt instanceof Assignment) {
      curBlock = this.handleAssignment(stmt, curBlock, method);
      return curBlock;
    } else if (stmt instanceof MethodCallExpr) {
      const [sameBlock, argTemps] = this.handleMethodCallArgs(
        stmt.args,
        curBlock,
        method
      );
      const callInstr = new CallInstruction(stmt.methodName, argTemps);
      callInstr.weight = this.instrWeight;
      sameBlock.instructions.push(callInstr);
      return sameBlock;
    } else if (stmt instanceof IfElse) {
      const condDest = this.getNextTempVar();
      const shortCircuitBlock = this.buildShortCircuitBlocks(
        curBlock,
        stmt.condition,
        method,
        condDest
      );
      const exprTLabel = `exprT_${this.labelCounter}`;
      const exprFLabel = `exprF_${this.labelCounter}`;
      const endLabel = `end_${this.labelCounter}`;
      const sourceScope = this.curScope;
      const trueScope = this.scopeCounter++;
      const falseScope = this.scopeCounter++;
      this.scopeParents.set(trueScope, sourceScope);
      this.scopeParents.set(falseScope, sourceScope);
      this.labelCounter++;
      let curTrueBlock = new BasicBlock(exprTLabel, trueScope, sourceScope, []);
      let curFalseBlock = new BasicBlock(
        exprFLabel,
        falseScope,
        sourceScope,
        []
      );
      const ifBranches = new BranchBlocks(
        condDest,
        curTrueBlock,
        curFalseBlock
      );
      this.addBlockBranch(shortCircuitBlock, ifBranches);
      if (stmt.falseBody) {
        const skipFalseStatements = this.genPurgeArr(stmt.falseBody.statements);
        this.curScope = falseScope;
        this.buildFields(curFalseBlock, stmt.falseBody.scope);
        stmt.falseBody.statements.filter((_2, i2) => !skipFalseStatements[i2]).forEach((stmt2) => {
          curFalseBlock = this.buildStatement(
            stmt2,
            curFalseBlock,
            loop,
            method
          );
        });
      }
      this.curScope = trueScope;
      const skipTrueStatements = this.genPurgeArr(stmt.trueBody.statements);
      this.buildFields(curTrueBlock, stmt.trueBody.scope);
      stmt.trueBody.statements.filter((_2, i2) => !skipTrueStatements[i2]).forEach((stmt2) => {
        curTrueBlock = this.buildStatement(stmt2, curTrueBlock, loop, method);
      });
      this.curScope = sourceScope;
      const endBlock = new BasicBlock(endLabel, sourceScope, sourceScope, []);
      this.addBlockSuccessor(curTrueBlock, endBlock);
      this.addBlockSuccessor(curFalseBlock, endBlock);
      return endBlock;
    } else if (stmt instanceof ForLoop) {
      curBlock = this.buildStatement(stmt.init, curBlock, loop, method);
      this.instrWeight *= 100;
      const condDest = this.getNextTempVar();
      const headerLabel = `for_${this.labelCounter}`;
      const exprTLabel = `forT_${this.labelCounter}`;
      const exprFLabel = `forF_${this.labelCounter}`;
      const updateLabel = `update_${this.labelCounter}`;
      this.labelCounter++;
      const parentScope = curBlock.parentScope;
      const sourceScope = this.curScope;
      const trueScope = this.scopeCounter++;
      this.scopeParents.set(trueScope, sourceScope);
      const headerBlock = new BasicBlock(
        headerLabel,
        sourceScope,
        parentScope,
        []
      );
      this.addBlockSuccessor(curBlock, headerBlock);
      const shortCircuitBlock = this.buildShortCircuitBlocks(
        headerBlock,
        stmt.condition,
        method,
        condDest
      );
      let curTrueBlock = new BasicBlock(
        exprTLabel,
        trueScope,
        sourceScope,
        []
      );
      const endBlock = new BasicBlock(exprFLabel, sourceScope, sourceScope, []);
      const forBranches = new BranchBlocks(condDest, curTrueBlock, endBlock);
      this.addBlockBranch(shortCircuitBlock, forBranches);
      const updateBlock = new BasicBlock(
        updateLabel,
        sourceScope,
        parentScope,
        []
      );
      this.handleAssignment(stmt.update, updateBlock, method);
      this.curScope = trueScope;
      this.buildFields(curTrueBlock, stmt.body.scope);
      const newLoop = new Loop(endBlock, updateBlock);
      const skipStatements = this.genPurgeArr(stmt.body.statements);
      stmt.body.statements.filter((_2, i2) => !skipStatements[i2]).forEach((stmt2) => {
        curTrueBlock = this.buildStatement(
          stmt2,
          curTrueBlock,
          newLoop,
          method
        );
      });
      this.curScope = sourceScope;
      const jumpBlock = new BasicBlock(
        `skip_${this.labelCounter++}`,
        sourceScope,
        sourceScope,
        []
      );
      this.addBlockSuccessor(curTrueBlock, updateBlock);
      this.addBlockSuccessor(updateBlock, jumpBlock);
      this.addBlockSuccessor(jumpBlock, headerBlock);
      this.instrWeight /= 100;
      return endBlock;
    } else if (stmt instanceof WhileLoop) {
      this.instrWeight *= 100;
      const condDest = this.getNextTempVar();
      const whileLabel = `while_${this.labelCounter}`;
      const exprTLabel = `whileT_${this.labelCounter}`;
      const exprFLabel = `whileF_${this.labelCounter}`;
      this.labelCounter++;
      const sourceScope = this.curScope;
      const trueScope = this.scopeCounter++;
      this.scopeParents.set(trueScope, sourceScope);
      const whileHeader = new BasicBlock(
        whileLabel,
        sourceScope,
        curBlock.parentScope,
        []
      );
      this.addBlockSuccessor(curBlock, whileHeader);
      const shortCircuitBlock = this.buildShortCircuitBlocks(
        whileHeader,
        stmt.condition,
        method,
        condDest
      );
      let curTrueBlock = new BasicBlock(exprTLabel, trueScope, sourceScope, []);
      const endBlock = new BasicBlock(exprFLabel, sourceScope, sourceScope, []);
      const whileBranches = new BranchBlocks(condDest, curTrueBlock, endBlock);
      this.addBlockBranch(shortCircuitBlock, whileBranches);
      const jumpBlock = new BasicBlock(
        `skip_${this.labelCounter++}`,
        sourceScope,
        sourceScope,
        []
      );
      const newLoop = new Loop(endBlock, jumpBlock);
      this.curScope = trueScope;
      this.buildFields(curTrueBlock, stmt.body.scope);
      const skipStatements = this.genPurgeArr(stmt.body.statements);
      stmt.body.statements.filter((_2, i2) => !skipStatements[i2]).forEach((stmt2) => {
        curTrueBlock = this.buildStatement(
          stmt2,
          curTrueBlock,
          newLoop,
          method
        );
      });
      this.curScope = sourceScope;
      this.addBlockSuccessor(curTrueBlock, jumpBlock);
      this.addBlockSuccessor(jumpBlock, whileHeader);
      this.instrWeight /= 100;
      return endBlock;
    } else if (stmt instanceof Return) {
      let retTemp;
      if (stmt.expr) {
        [curBlock, retTemp] = this.buildExpression(stmt.expr, curBlock, method);
        const retInstr = new ReturnInstruction(retTemp);
        curBlock.instructions.push(retInstr);
        return curBlock;
      } else {
        const nullRetInstr = new ReturnInstruction(null);
        curBlock.instructions.push(nullRetInstr);
        return curBlock;
      }
    } else if (stmt instanceof Break) {
      if (loop) {
        this.addBlockSuccessor(curBlock, loop.breakTo);
      }
      return curBlock;
    } else if (stmt instanceof Continue) {
      if (loop) {
        this.addBlockSuccessor(curBlock, loop.continueTo);
      }
      return curBlock;
    } else {
      throw new Error("Statement type does not exist.");
    }
  }
  handleAssignment(stmt, curBlock, method) {
    let leftExprDest;
    let arrayIndex = null;
    if (stmt.lhsIndexed) {
      leftExprDest = stmt.lhsIndexed[0];
      let lhsArrayIndexExpr = stmt.lhsIndexed[1];
      if (lhsArrayIndexExpr instanceof IntLiteral) {
        arrayIndex = lhsArrayIndexExpr.val;
      } else {
        [curBlock, arrayIndex] = this.buildExpression(
          stmt.lhsIndexed[1],
          curBlock,
          method
        );
      }
      leftExprDest = `${leftExprDest}[${arrayIndex}]`;
    } else {
      leftExprDest = this.getRename(stmt.lhsUnindexed);
    }
    let rightExprDest;
    if (stmt.rhs.expr instanceof IntLiteral || stmt.rhs.expr instanceof LongLiteral) {
      rightExprDest = this.getNextTempVar();
      let type = stmt.rhs.expr instanceof IntLiteral ? literalType.int : literalType.long;
      const loadInstr = new LoadConstantInstruction(
        rightExprDest,
        stmt.rhs.expr.val.toString(),
        type
      );
      loadInstr.weight = this.instrWeight;
      curBlock.instructions.push(loadInstr);
    } else if (stmt.rhs.expr instanceof BoolLiteral) {
      rightExprDest = this.getNextTempVar();
      const loadInstr = new LoadConstantInstruction(
        rightExprDest,
        stmt.rhs.expr.b ? "1" : "0",
        literalType.bool
      );
      loadInstr.weight = this.instrWeight;
      curBlock.instructions.push(loadInstr);
    } else if (stmt.rhs.expr instanceof MethodCallExpr) {
      let argTemps = [];
      [curBlock, argTemps] = this.handleMethodCallArgs(
        stmt.rhs.expr.args,
        curBlock,
        method
      );
      rightExprDest = this.getNextTempVar();
      const callInstr = new CallInstruction(
        stmt.rhs.expr.methodName,
        argTemps,
        rightExprDest
      );
      callInstr.weight = this.instrWeight;
      curBlock.instructions.push(callInstr);
    } else if (stmt.rhs.operator instanceof IncrementOperator) {
      let one = this.getNextTempVar();
      if (stmt.rhs.operator instanceof Increment) {
        if (stmt.rhs.isLong) {
          const loadInstr = new LoadConstantInstruction(
            one,
            "1",
            literalType.long
          );
          loadInstr.weight = this.instrWeight;
          curBlock.instructions.push(loadInstr);
        } else {
          const loadInstr = new LoadConstantInstruction(
            one,
            "1",
            literalType.int
          );
          loadInstr.weight = this.instrWeight;
          curBlock.instructions.push(loadInstr);
        }
        const binInstr = new BinOpInstruction(
          leftExprDest,
          new PlusOp(),
          one,
          leftExprDest
        );
        binInstr.weight = this.instrWeight;
        curBlock.instructions.push(binInstr);
        return curBlock;
      } else {
        if (stmt.rhs.isLong) {
          const loadInstr = new LoadConstantInstruction(
            one,
            "1",
            literalType.long
          );
          loadInstr.weight = this.instrWeight;
          curBlock.instructions.push(loadInstr);
        } else {
          const loadInstr = new LoadConstantInstruction(
            one,
            "1",
            literalType.int
          );
          loadInstr.weight = this.instrWeight;
          curBlock.instructions.push(loadInstr);
        }
        const binInstr = new BinOpInstruction(
          leftExprDest,
          new MinusOp(),
          one,
          leftExprDest
        );
        binInstr.weight = this.instrWeight;
        curBlock.instructions.push(binInstr);
        return curBlock;
      }
    } else {
      [curBlock, rightExprDest] = this.buildExpression(
        stmt.rhs.expr,
        curBlock,
        method
      );
    }
    if (!(stmt.rhs.operator instanceof Assign || stmt.rhs.operator instanceof IncrementOperator)) {
      const resultTemp = this.getNextTempVar();
      if (stmt.rhs.operator instanceof PlusAssign) {
        const binInstr = new BinOpInstruction(
          leftExprDest,
          new PlusOp(),
          rightExprDest,
          resultTemp
        );
        binInstr.weight = this.instrWeight;
        curBlock.instructions.push(binInstr);
      } else if (stmt.rhs.operator instanceof MinusAssign) {
        const binInstr = new BinOpInstruction(
          leftExprDest,
          new MinusOp(),
          rightExprDest,
          resultTemp
        );
        binInstr.weight = this.instrWeight;
        curBlock.instructions.push(binInstr);
      } else if (stmt.rhs.operator instanceof MultiplyAssign) {
        const binInstr = new BinOpInstruction(
          leftExprDest,
          new MultiplyOp(),
          rightExprDest,
          resultTemp
        );
        binInstr.weight = this.instrWeight;
        curBlock.instructions.push(binInstr);
      } else if (stmt.rhs.operator instanceof DivideAssign) {
        const binInstr = new BinOpInstruction(
          leftExprDest,
          new DivideOp(),
          rightExprDest,
          resultTemp
        );
        binInstr.weight = this.instrWeight;
        curBlock.instructions.push(binInstr);
      } else if (stmt.rhs.operator instanceof ModuloAssign) {
        const binInstr = new BinOpInstruction(
          leftExprDest,
          new ModuloOp(),
          rightExprDest,
          resultTemp
        );
        binInstr.weight = this.instrWeight;
        curBlock.instructions.push(binInstr);
      }
      const copyInstr = new CopyInstruction(leftExprDest, resultTemp);
      copyInstr.weight = this.instrWeight;
      curBlock.instructions.push(copyInstr);
    } else {
      const copyInstr = new CopyInstruction(leftExprDest, rightExprDest);
      copyInstr.weight = this.instrWeight;
      curBlock.instructions.push(copyInstr);
    }
    return curBlock;
  }
  handleMethodCallArgs(args, curBlock, method) {
    let argTemps = [];
    for (const arg of args) {
      let argTemp = "";
      if (arg instanceof IntLiteral) {
        argTemp = arg.val.toString();
      } else if (arg instanceof LongLiteral) {
        argTemp = arg.val.toString() + "L";
      } else if (arg instanceof BoolLiteral) {
        argTemp = arg.b ? "1b" : "0b";
      } else if (arg instanceof StringLiteral) {
        argTemp = arg;
      } else {
        [curBlock, argTemp] = this.buildExpression(arg, curBlock, method);
      }
      argTemps.push(argTemp);
    }
    return [curBlock, argTemps];
  }
  toDot(methodName) {
    const visited = /* @__PURE__ */ new Set();
    const blockIds = /* @__PURE__ */ new Map();
    let nextId = 0;
    const getBlockId = (block) => {
      if (!blockIds.has(block)) {
        blockIds.set(block, nextId++);
      }
      return blockIds.get(block);
    };
    const formatInstructions = (block) => {
      return block.instructions.map((instr) => {
        let str = instr.toString();
        str = str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/"/g, '\\"');
        return str;
      }).join("\\n");
    };
    const generateDot = (block) => {
      if (visited.has(block)) {
        return [];
      }
      visited.add(block);
      const lines = [];
      const blockId = getBlockId(block);
      lines.push(
        `    block${blockId} [shape=box, label="${formatInstructions(block)}"];`
      );
      for (const instr of block.instructions) {
        if (instr instanceof JumpBoolInstruction) {
          lines.push(
            `    block${blockId} -> ${instr.trueLabel} [label="true"];`
          );
          lines.push(
            `    block${blockId} -> ${instr.falseLabel} [label="false"];`
          );
        } else if (instr instanceof JumpDirectInstruction) {
          lines.push(`    block${blockId} -> ${instr.label} [label="jump"];`);
        }
      }
      return lines;
    };
    const methodCFG = this.buildMethodCFG(
      this.program.methods.get(methodName)
    );
    const dotLines = [
      `digraph ${methodName} {`,
      '    node [fontname="Courier"];',
      '    edge [fontname="Courier"];',
      ...generateDot(methodCFG),
      "}"
    ];
    return dotLines.join("\n");
  }
}
class AsmUtils {
  // private scratchRegs = ["%rax", "%rdx"];
  // private intrScratchRegs = ["%eax", "%edx"];
  // private scratchRegs = ["%r10", "%r11"];
  // private intrScratchRegs = ["%r10d", "%r11d"];
  constructor() {
    this.scratchRegs = ["%rax", "%r11", "%rdx"];
    this.intrScratchRegs = ["%eax", "%r11d", "%edx"];
  }
  getScratchRegArray(isLong) {
    return isLong ? [...this.scratchRegs] : [...this.intrScratchRegs];
  }
  getLongScratchReg(index) {
    return this.scratchRegs[index];
  }
  getScratchReg(index) {
    return this.intrScratchRegs[index];
  }
  getInstrSuffix(isLong) {
    return isLong ? "q" : "l";
  }
  calculateNextAddressOffset(currentAddres, isLong) {
    const alignment = 8;
    return isLong && currentAddres % alignment == 0 ? 8 : isLong ? 12 : 4;
  }
  buildMovInstructionStr(src1, src2, areLongs) {
    const suffix = areLongs ? "q" : "l";
    if (src1 === src2) {
      return "";
    }
    if (src1 === "$0" || src1 === "$0x0") {
      return `xor${suffix} ${src2}, ${src2}`;
    }
    return `mov${suffix} ${src1}, ${src2}`;
  }
  buildRegMoveInstructionStr(src1, regIndex, isLong) {
    return this.buildMovInstructionStr(
      src1,
      this.getScratchRegArray(isLong)[regIndex],
      isLong
    );
  }
  safeParseLong(value) {
    if (/^-?\d+L$/.test(value)) {
      return BigInt(value.slice(0, -1));
    }
    return null;
  }
  safeParseInt(value) {
    if (/^-?\d+$/.test(value)) {
      return BigInt(value);
    }
    if (/^-?\d+b$/.test(value)) {
      return BigInt(value.slice(0, -1));
    }
    return null;
  }
}
var LongCallerSavedReg = /* @__PURE__ */ ((LongCallerSavedReg2) => {
  LongCallerSavedReg2["rdi"] = "%rdi";
  LongCallerSavedReg2["rsi"] = "%rsi";
  LongCallerSavedReg2["rcx"] = "%rcx";
  LongCallerSavedReg2["r8"] = "%r8";
  LongCallerSavedReg2["r9"] = "%r9";
  LongCallerSavedReg2["r10"] = "%r10";
  return LongCallerSavedReg2;
})(LongCallerSavedReg || {});
var LongCalleeSavedReg = /* @__PURE__ */ ((LongCalleeSavedReg2) => {
  LongCalleeSavedReg2["r12"] = "%r12";
  LongCalleeSavedReg2["r13"] = "%r13";
  LongCalleeSavedReg2["r14"] = "%r14";
  LongCalleeSavedReg2["r15"] = "%r15";
  LongCalleeSavedReg2["rbx"] = "%rbx";
  return LongCalleeSavedReg2;
})(LongCalleeSavedReg || {});
var ReservedLongReg = /* @__PURE__ */ ((ReservedLongReg2) => {
  ReservedLongReg2["rax"] = "%rax";
  ReservedLongReg2["r11"] = "%r11";
  ReservedLongReg2["rdx"] = "%rdx";
  return ReservedLongReg2;
})(ReservedLongReg || {});
function getLongCallerSavedRegs() {
  return new Set(Object.values(LongCallerSavedReg));
}
function getCallKilledReges(argLength) {
  const orderedMethodCallArgs = [
    "%rdi",
    "%rsi",
    //rdx is supposed to come here, but it is part of our scratch registers, so it will never be assigned
    // by the colorer
    "%rcx",
    "%r8",
    "%r9"
    /* r9 */
  ];
  const sliceUsed = argLength > 2 ? argLength - 1 : argLength;
  return orderedMethodCallArgs.slice(0, sliceUsed);
}
function getLongRegs() {
  const callerSaved = new Set(Object.values(LongCallerSavedReg));
  const calleeSaved = new Set(Object.values(LongCalleeSavedReg));
  return setUnion(callerSaved, calleeSaved);
}
function castToIntReg(reg) {
  const dConventionRegex = /%r\d*$/;
  const eConventionRegex = /%r[^\d][^]*$/;
  if (dConventionRegex.test(reg.toString())) {
    return reg.toString() + "d";
  }
  if (eConventionRegex.test(reg.toString())) {
    return reg.toString().replace("r", "e");
  }
  return reg;
}
function castToLongReg(reg) {
  const rConventionRegex = /%e[^]*$/;
  const dConventionRegex = /%r[^]*d$/;
  if (rConventionRegex.test(reg.toString())) {
    return reg.toString().replace("e", "r");
  }
  if (dConventionRegex.test(reg.toString())) {
    return reg.toString().slice(0, -1);
  }
  return reg;
}
function isLongReg(reg) {
  return castToLongReg(reg) === reg;
}
class RegCache {
  constructor(stackTracker) {
    this.stackTracker = stackTracker;
    this.outOfSinkVars = /* @__PURE__ */ new Set();
    this.spillEnabled = true;
    this.utils = new AsmUtils();
    this.spilledVars = /* @__PURE__ */ new Set();
    this.varToRegister = /* @__PURE__ */ new Map();
    this.registerToVar = /* @__PURE__ */ new Map();
  }
  clear() {
    this.varToRegister = /* @__PURE__ */ new Map();
    this.registerToVar = /* @__PURE__ */ new Map();
    this.outOfSinkVars.clear();
    this.spilledVars.clear();
  }
  removeRegCacheVar(varName) {
    const posReg = this.varToRegister.get(varName);
    if (posReg === void 0) {
      return;
    }
    this.registerToVar.delete(posReg);
    this.varToRegister.delete(varName);
    this.spilledVars.delete(varName);
  }
  restoreAllRegVars() {
    const restoreStack = [];
    this.spilledVars.forEach((varName) => {
      restoreStack.push(this.restoreRegVar(varName));
    });
    return restoreStack.join("\n");
  }
  restoreRegVars(varsToRestore) {
    const restoreStack = [];
    this.spilledVars.forEach((varName) => {
      if (!varsToRestore.has(varName)) {
        this.spilledVars.delete(varName);
        return;
      }
      restoreStack.push(this.restoreRegVar(varName));
    });
    return restoreStack.join("\n");
  }
  restoreRegVar(varName) {
    if (!this.spilledVars.has(varName)) {
      return "";
    }
    const stackMemLoc = this.stackTracker.varToMemory.get(varName);
    if (stackMemLoc === void 0) {
      throw new Error("mem location is not stored in stack for some reason!");
    }
    const regUsed = this.varToRegister.get(varName);
    if (regUsed === void 0) {
      throw new Error("register not stored in cache!");
    }
    this.spilledVars.delete(varName);
    const isLong = this.stackTracker.checkIsLong(varName);
    const startComment = `# restoring ${varName} into register ${regUsed}`;
    const endComment = `# end of restoring ${varName}`;
    if (isLong) {
      return [startComment, `movq ${stackMemLoc}, ${regUsed}`, endComment].join(
        "\n"
      );
    }
    return [startComment, `movl ${stackMemLoc}, ${regUsed}`, endComment].join(
      "\n"
    );
  }
  // get register for a variable
  fetchVar(varName, isLong) {
    if (!this.spillEnabled && this.spilledVars.has(varName)) {
      return null;
    }
    if (this.outOfSinkVars.has(varName)) {
      if (isLong === void 0) {
        throw new Error("can't if reg to assign is long");
      }
      this.stackTracker.setMemLocation(varName, isLong);
      this.updateRegisterSize(varName);
    }
    if (this.varToRegister.has(varName)) {
      const varRegister = this.varToRegister.get(varName);
      return `${varRegister}`;
    }
    return null;
  }
  // allocate a register for a variable
  allocateRegister(varName, reg) {
    let regUsed = reg;
    if (regUsed === void 0 || regUsed === null) {
      throw new Error("what happened :sob:");
    }
    if (this.stackTracker.checkIsLong(varName)) {
      regUsed = castToLongReg(reg);
    } else {
      regUsed = castToIntReg(reg);
    }
    this.insertReg(varName, regUsed);
    if (!this.stackTracker.varToMemory.has(varName)) {
      this.outOfSinkVars.add(varName);
    }
  }
  updateRegisterSize(varName) {
    if (!this.varToRegister.has(varName)) {
      throw new Error("variable not stored in cache!");
    }
    const ogRegUsed = this.varToRegister.get(varName);
    if (ogRegUsed === void 0) {
      throw new Error("what happened :sob:");
    }
    const newRegUsed = this.stackTracker.checkIsLong(varName) ? castToLongReg(ogRegUsed) : castToIntReg(ogRegUsed);
    this.insertReg(varName, newRegUsed);
    this.outOfSinkVars.delete(varName);
  }
  insertReg(varName, regUsed) {
    const longReg = castToLongReg(regUsed);
    const intReg = castToIntReg(regUsed);
    let posVar = this.registerToVar.get(longReg);
    posVar = posVar === void 0 ? this.registerToVar.get(intReg) : posVar;
    posVar = posVar === void 0 ? "" : posVar;
    const posReg = this.varToRegister.get(varName);
    if (posReg !== void 0) {
      this.registerToVar.delete(posReg);
    }
    this.registerToVar.delete(longReg);
    this.registerToVar.delete(intReg);
    this.varToRegister.delete(posVar);
    this.spilledVars.delete(posVar);
    this.varToRegister.set(varName, regUsed);
    this.registerToVar.set(regUsed, varName);
    if (this.registerToVar.size !== this.varToRegister.size) {
      throw new Error("size mismatch");
    }
  }
  flushCache(regesKilled, liveVars) {
    this.spillEnabled = false;
    let spillInstrs = [];
    this.registerToVar.forEach((varName, reg) => {
      if (this.spilledVars.has(varName) || liveVars !== null && varName in liveVars) {
        return;
      }
      const longReg = castToLongReg(reg);
      if (!regesKilled.has(longReg)) {
        return;
      }
      this.spilledVars.add(varName);
      const isLong = isLongReg(reg);
      const { memLocation: memLoc } = this.stackTracker.getAnyMemLoc(
        varName,
        1,
        isLong
      );
      spillInstrs.push(this.utils.buildMovInstructionStr(reg, memLoc, isLong));
    });
    return ["# flushing cache", ...spillInstrs].join("\n");
  }
  enableCache() {
    this.spillEnabled = true;
  }
  areSpillsEnabled() {
    return this.spillEnabled;
  }
}
class StackTracker {
  constructor() {
    this.curStackPtr = 0;
    this.varToMemory = /* @__PURE__ */ new Map();
    this.longVars = /* @__PURE__ */ new Set();
    this.strLiteralMap = /* @__PURE__ */ new Map();
    this.globalVars = /* @__PURE__ */ new Map();
    this.arrNames = /* @__PURE__ */ new Set();
    this.utils = new AsmUtils();
    this.maxMethodStackShift = 0;
    this.isMacOS = false;
    this.regCache = new RegCache(this);
  }
  removeRegCacheVar(varName) {
    this.regCache.removeRegCacheVar(varName);
  }
  addRegCacheVar(varName, reg) {
    this.regCache.allocateRegister(varName, reg);
  }
  getMaxStackPtr() {
    return this.maxMethodStackShift;
  }
  flushCache(regesKilled, liveVars) {
    return this.regCache.flushCache(regesKilled, liveVars);
  }
  enableCache() {
    this.regCache.enableCache();
  }
  restoreAllCacheVars() {
    return this.regCache.restoreAllRegVars();
  }
  restoreSomeCacheVars(varsToRestore) {
    return this.regCache.restoreRegVars(varsToRestore);
  }
  clearScope(parent) {
    const parentCopy = parent.duplicate();
    this.varToMemory = parentCopy.varToMemory;
    this.longVars = parentCopy.longVars;
    this.curStackPtr = parentCopy.curStackPtr;
    this.arrNames = parentCopy.arrNames;
    this.maxMethodStackShift = Math.max(
      this.maxMethodStackShift,
      parentCopy.maxMethodStackShift
    );
  }
  clear() {
    this.varToMemory = /* @__PURE__ */ new Map();
    this.longVars = /* @__PURE__ */ new Set();
    this.curStackPtr = 0;
    this.maxMethodStackShift = 0;
    this.regCache.clear();
    this.globalVars.forEach((type, name) => {
      if (type instanceof LongType || type instanceof LongArrayType) {
        this.longVars.add(name);
      }
    });
  }
  duplicate() {
    const newStack = new StackTracker();
    newStack.varToMemory = new Map(this.varToMemory);
    newStack.longVars = new Set(this.longVars);
    newStack.curStackPtr = this.curStackPtr;
    newStack.strLiteralMap = /* @__PURE__ */ new Map();
    this.strLiteralMap.forEach((posibleNames, string) => {
      newStack.strLiteralMap.set(string, [...posibleNames]);
    });
    newStack.globalVars = new Map(this.globalVars);
    newStack.arrNames = new Set(this.arrNames);
    newStack.maxMethodStackShift = this.maxMethodStackShift;
    return newStack;
  }
  addArrName(arrName, isLong) {
    this.arrNames.add(arrName);
    if (isLong) {
      this.longVars.add(arrName);
    }
  }
  setGlobalDatatype(globarVar, type) {
    this.globalVars.set(globarVar, type);
    if (type instanceof LongType || type instanceof LongArrayType) {
      this.longVars.add(globarVar);
    }
  }
  getAnyMemLoc(varName, regIndex, isLong) {
    let varLoads = "";
    if (this.regCache.areSpillsEnabled()) {
      varLoads = this.regCache.restoreRegVar(getSplitName(varName));
    }
    const cacheFetch = this.regCache.fetchVar(varName, isLong);
    if (cacheFetch !== null) {
      return {
        loadInstrs: varLoads,
        memLocation: cacheFetch
      };
    }
    if (!isLong) {
      isLong = false;
    }
    const { arrayName, indexVar } = this.buildImplicitArrayLocationString(varName);
    if (arrayName === null || indexVar === null) {
      const storedMemLoc = this.fetchMemLocation(varName);
      if (storedMemLoc !== null) {
        return {
          loadInstrs: varLoads,
          memLocation: storedMemLoc
        };
      }
      const { loadInstrs: globalVarLoad, memLocation: globalVarMem } = this.getGlobalVarMemLoc(varName, regIndex);
      if (globalVarLoad !== null && globalVarMem !== null) {
        return {
          loadInstrs: [varLoads, globalVarLoad].join("\n"),
          memLocation: globalVarMem
        };
      }
      return {
        loadInstrs: varLoads,
        memLocation: this.getNewMemLocation(varName, isLong)
      };
    }
    const { loadInstrs: globalArrLoad, memLocation: globalArrMem } = this.getGlobalArrMemLoc(arrayName, indexVar, regIndex);
    if (globalArrLoad !== null && globalArrMem !== null) {
      return {
        loadInstrs: [varLoads, globalArrLoad].join("\n"),
        memLocation: globalArrMem
      };
    }
    const arrStart = `${arrayName}[0]`;
    isLong = this.longVars.has(arrStart);
    const arrayStartLoc = this.getExplicitMemLocation(arrStart);
    const arrayStart = arrayStartLoc.split("(")[0];
    const regExtended = this.utils.getLongScratchReg(regIndex);
    const loadInstrs = this.buildArrayVarIndexOffsetInstruction(
      arrayStart,
      indexVar,
      regIndex,
      isLong
    );
    return {
      loadInstrs: [varLoads, loadInstrs].join("\n"),
      memLocation: `(${regExtended})`
    };
  }
  getExplicitMemLocation(varName) {
    const memLoc = this.fetchMemLocation(varName);
    if (memLoc === null) {
      throw new Error("mem location is not stored!");
    }
    return memLoc;
  }
  fetchMemLocation(varName) {
    const numericConstant = this.handleConstants(varName);
    if (numericConstant !== null) {
      return numericConstant;
    }
    const cacheFetch = this.regCache.fetchVar(varName, void 0);
    if (cacheFetch !== null) {
      return cacheFetch;
    }
    if (this.varToMemory.has(varName))
      return this.varToMemory.get(varName);
    return null;
  }
  getNewMemLocation(varName, isLong) {
    this.setMemLocation(varName, isLong);
    return this.getExplicitMemLocation(varName);
  }
  setMemLocation(varName, isLong) {
    const bytesInEntry = this.utils.calculateNextAddressOffset(
      this.curStackPtr,
      isLong
    );
    const stackPtrOffest = bytesInEntry + this.curStackPtr;
    this.curStackPtr = stackPtrOffest;
    this.maxMethodStackShift = Math.max(
      this.maxMethodStackShift,
      stackPtrOffest
    );
    const memoryLocation = `${-stackPtrOffest}(%rbp)`;
    this.varToMemory.set(varName, memoryLocation);
    this.longVars.delete(varName);
    if (isLong) this.longVars.add(varName);
  }
  getstrLiteral(strLiteral) {
    if (this.strLiteralMap.has(strLiteral)) {
      const asmNames = this.strLiteralMap.get(strLiteral);
      return asmNames[0];
    }
  }
  handleConstants(posConstant) {
    const longParse = this.utils.safeParseLong(posConstant);
    const intParse = this.utils.safeParseInt(posConstant);
    if (longParse !== null) {
      this.longVars.add(posConstant);
      return `$${longParse.toString()}`;
    }
    if (intParse !== null) {
      return `$${intParse.toString()}`;
    }
    return null;
  }
  buildImplicitArrayLocationString(varName) {
    if (this.varToMemory.has(varName))
      return { arrayName: null, indexVar: null };
    const splitName = varName.split(/\[|\]/);
    const emptyReturn = { arrayName: null, indexVar: null };
    if (splitName.length !== 3) return emptyReturn;
    const [arrName, index] = [...splitName];
    return { arrayName: arrName, indexVar: index };
  }
  getGlobalVarMemLoc(varName, regIndex) {
    const blankReturn = { loadInstrs: null, memLocation: null };
    if (!this.globalVars.has(varName)) {
      return blankReturn;
    }
    const regUsed = this.utils.getLongScratchReg(regIndex);
    const varUsed = this.globalVars.get(varName);
    const destUsed = varUsed instanceof ArrayType ? `${regUsed}` : `(${regUsed})`;
    const loadEffectiveAddr = `lea ${varName}(%rip), ${regUsed}`;
    return { loadInstrs: loadEffectiveAddr, memLocation: `${destUsed}` };
  }
  getGlobalArrMemLoc(varName, indexVar, regIndex) {
    const longCallerSaved = this.utils.getLongScratchReg(2);
    const blankReturn = { loadInstrs: null, memLocation: null };
    if (!this.globalVars.has(varName)) {
      return blankReturn;
    }
    const varUsed = this.globalVars.get(varName);
    if (!(varUsed instanceof ArrayType)) {
      return blankReturn;
    }
    const regUsed = this.utils.getLongScratchReg(regIndex);
    const loadEffectiveAddr = `lea ${varName}(%rip), ${longCallerSaved}`;
    const safeIndexVar = indexVar;
    const startLoadComment = `# loading address of ${varName}[${indexVar}] into ${regUsed}`;
    const loadArrInstrs = this.buildArrayVarIndexOffsetInstruction(
      longCallerSaved,
      safeIndexVar,
      regIndex,
      this.longVars.has(varName)
    );
    const totalInstrs = [
      startLoadComment,
      loadEffectiveAddr,
      // arrayStartCalc,
      loadArrInstrs
    ].join("\n");
    return { loadInstrs: totalInstrs, memLocation: `(${regUsed})` };
  }
  buildArrayVarIndexOffsetInstruction(arrayStart, indexVar, regIndex, isLong) {
    const offsetIsLiteral = this.handleConstants(arrayStart) !== null;
    const addressShift = isLong ? 8 : 4;
    const indexVarMemLoc = this.getExplicitMemLocation(indexVar);
    const regLoadInstr = this.utils.buildRegMoveInstructionStr(
      indexVarMemLoc,
      regIndex,
      false
      // indexes are ints
    );
    const regExtended = this.utils.getLongScratchReg(regIndex);
    const shortcutScale = offsetIsLiteral ? `lea ${arrayStart}(%rbp,${regExtended},${addressShift}), ${regExtended}` : `lea (${arrayStart},${regExtended},${addressShift}), ${regExtended}`;
    const endLoadComment = "# end of load instruction";
    return [
      regLoadInstr,
      // signExtendInstr, //this sign extend  may not be necessary, this is why commented out but don't delete just yet
      shortcutScale,
      // basePtrShiftInstr,
      endLoadComment
    ].filter((instr) => instr !== "").join("\n");
  }
  isArrayVar(varName) {
    return this.arrNames.has(varName);
  }
  isMemAddress(name) {
    return this.isArrayVar(name) || this.strLiteralMap.has(name);
  }
  addLongVar(varName) {
    this.longVars.add(varName);
  }
  checkIsLong(varName) {
    const longNumeral = safeParseLong(varName);
    const arrayName = varName.split(/\[|\]/)[0];
    return longNumeral !== null || this.longVars.has(varName) || this.longVars.has(arrayName);
  }
  addStrLiteral(strLiteral, asmNames) {
    this.strLiteralMap.set(strLiteral, asmNames);
  }
}
class AsmHelper {
  constructor(methodRegesKilled) {
    this.methodRegesKilled = methodRegesKilled;
    this.stackPtrShift = 0;
    this.runtimeExceptionString = "runtime exception fell off the end of the method \\n";
    this.runtimeExcceptionLabel = "runtime_exception";
    this.endLabel = "";
    this.webMap = null;
    this.headerLoaded = false;
    this.methodsLoaded = false;
    this.methodReturnTypes = /* @__PURE__ */ new Map();
    this.randIndex = 0;
    this.methodParams = [];
    this.argStoreShift = 8 * 2;
    this.utils = new AsmUtils();
    this.stackTracker = new StackTracker();
    this.scopeTrackers = /* @__PURE__ */ new Map();
    this.scopeTrackers.set(0, this.stackTracker);
    this.generatedBlocks = /* @__PURE__ */ new Set();
    this.isMacOS = false;
    this.runtimeExceptionAsm = [
      `lea ${this.runtimeExcceptionLabel}(%rip), %rdi`,
      "call " + (this.isMacOS ? "_" : "") + "printf",
      this.utils.buildRegMoveInstructionStr("$1", 0, true),
      this.utils.buildRegMoveInstructionStr("$0", 1, true),
      this.buildDivInstructionStr(true)
    ].join("\n");
    this.importSet = /* @__PURE__ */ new Set();
  }
  buildProgramHeader(imports, strLiteralMap, natives) {
    const header = this.buildDataSegment(strLiteralMap, natives);
    if ("printf" in imports === false) {
      imports.push("printf");
    }
    const importAsms = imports.map((importName) => {
      this.importSet.add(importName);
      return `.extern ${importName}`;
    }).join("\n");
    this.headerLoaded = true;
    return header + "\n" + importAsms;
  }
  preLoadProgramMethods(methods) {
    this.methodsLoaded = true;
    for (const method of methods) {
      this.methodReturnTypes.set(method.method_name, method.returnType);
    }
  }
  buildMethodParamLoads() {
    const orderedLongRegArgs = ["%rdi", "%rsi", "%rdx", "%rcx", "%r8", "%r9"];
    const orderedRegArgs = ["%edi", "%esi", "%edx", "%ecx", "%r8d", "%r9d"];
    return this.methodParams.map((param, index) => {
      if (index >= 6) return "";
      const isLong = this.stackTracker.checkIsLong(param);
      const { memLocation: memLoc, loadInstrs: loadIntrs } = this.stackTracker.getAnyMemLoc(param, 0, isLong);
      const sourceUsed = isLong ? orderedLongRegArgs[index] : orderedRegArgs[index];
      return [
        loadIntrs,
        this.utils.buildMovInstructionStr(sourceUsed, memLoc, isLong)
      ].filter((str) => str.length > 0).join("\n");
    }).join("\n");
  }
  setWebMap(webMap) {
    this.webMap = webMap;
  }
  buildMethodAsm(method, basicBlock) {
    if (this.headerLoaded === false) {
      throw new Error("Program header not loaded before method assembly");
    }
    if (this.methodsLoaded === false) {
      throw new Error("Program methods not loaded before method assembly");
    }
    this.storeMethodParams(method);
    this.stackPtrShift = this.findStackPtrShift(basicBlock);
    basicBlock.instructions.shift();
    const methodName = method.method_name;
    const asmContent = [
      this.buildMethodPrologue(methodName),
      this.buildBasicBlock(basicBlock, true),
      this.buildMethodEpilogue(methodName, true),
      ""
    ].join("\n");
    this.clear();
    return asmContent;
  }
  buildDataSegment(strLiteralMap, natives) {
    let dataSegment = this.isMacOS ? ".section __DATA,__data" : ".section .data";
    const strLiteralNameBase = "string_literal_";
    strLiteralMap.forEach((count, stringLiteral) => {
      const quotedStrLiteral = `${stringLiteral}`;
      const literalAsmNames = [];
      for (let i2 = 0; i2 < count; i2++) {
        const strLiteralName = `${strLiteralNameBase}${this.randIndex++}`;
        literalAsmNames.push(strLiteralName);
        this.stackTracker.addLongVar(quotedStrLiteral);
        dataSegment += `
${strLiteralName}: .string "${stringLiteral}"`;
        dataSegment += "\n.align 16";
        break;
      }
      this.stackTracker.addStrLiteral(quotedStrLiteral, literalAsmNames);
    });
    dataSegment += `
${this.runtimeExcceptionLabel}: .string "${this.runtimeExceptionString}"`;
    dataSegment += "\n.align 16";
    const globalVarSection = this.isMacOS ? ".section __DATA,__bss" : ".section .bss";
    let globalVars = ".align 8";
    natives.forEach((datatype, name) => {
      let totalReserved = 1;
      if (datatype instanceof ArrayType) {
        this.stackTracker.addArrName(name, datatype instanceof LongArrayType);
        totalReserved = datatype.array_size;
      }
      this.stackTracker.setGlobalDatatype(name, datatype);
      globalVars += `
${name}: .skip ${totalReserved * 8}`;
    });
    const textSection = this.isMacOS ? ".section __TEXT,__text" : ".section .text";
    const globalMain = this.isMacOS ? ".global _main" : ".global main";
    return [
      "# loading str literals",
      dataSegment,
      "# end of load",
      "# loading global vars",
      globalVarSection,
      globalVars,
      "# end of load",
      textSection,
      globalMain
    ].join("\n");
  }
  storeMethodParams(method) {
    method.params.ordered_params.slice(6).forEach(([param, field], index) => {
      this.stackTracker.setMemLocation(param, field.type instanceof LongType);
    });
    method.params.ordered_params.forEach(([param, field], index) => {
      if (index < 6) {
        const isLong = field.type instanceof LongType;
        this.stackTracker.setMemLocation(param, isLong);
      }
      this.methodParams.push(param);
    });
  }
  storeVarFieldDeclaration(instr) {
    this.stackTracker.setMemLocation(
      instr.name,
      instr.dataType instanceof LongType
    );
    return "";
  }
  storeArrFieldDeclaration(instr) {
    const isLong = instr.dataType instanceof LongArrayType;
    this.stackTracker.addArrName(instr.name, isLong);
    for (let i2 = instr.size - 1; i2 >= 0; i2--) {
      const usedName = `${instr.name}[${i2}]`;
      this.stackTracker.setMemLocation(usedName, isLong);
    }
    return "";
  }
  buildLabelInstruction(instr) {
    return `${instr.label}:`;
  }
  buildJumpBoolInstruction(instr, hasFalloff, trueFallOff) {
    const { memLocation: memLoc, loadInstrs: loadIntrs } = this.stackTracker.getAnyMemLoc(instr.conditionVar, 0);
    const regMove = this.utils.buildMovInstructionStr(memLoc, "%eax", false);
    const testInstr = `test %eax, %eax`;
    const jumpFalse = `jz ${instr.falseLabel}`;
    const jumpTrue = `jnz ${instr.trueLabel}`;
    const jumpWritten = !hasFalloff ? [jumpFalse, jumpTrue].join("\n") : trueFallOff ? jumpFalse : jumpTrue;
    return [
      `# begin shortcircuit segment`,
      loadIntrs,
      regMove,
      testInstr,
      jumpWritten,
      "# end shortcircuit segment"
    ].filter((str) => str.length > 0).join("\n");
  }
  buildMagicDivInstruction(instr) {
    const isLong = false;
    const reg1 = this.utils.getScratchReg(0);
    const reg2 = this.utils.getScratchReg(1);
    const longReg1 = this.utils.getLongScratchReg(0);
    const { memLocation: src1, loadInstrs: loadSrc1Instr } = this.stackTracker.getAnyMemLoc(instr.src, 0, isLong);
    const initMoveInstr = `movl ${src1}, ${reg1}`;
    const regLoadSrc1Instr = `movsx ${reg1}, ${longReg1}`;
    const storeRegSrc1Instr = this.utils.buildRegMoveInstructionStr(
      this.utils.getLongScratchReg(0),
      1,
      true
    );
    const mulInstr = `imulq $${instr.magicNum}, ${longReg1}`;
    const shiftInstrMul = instr.addNum === 1 ? `shr $32, ${longReg1}` : `sar $${32 + instr.shiftNum}, ${longReg1}`;
    const addInstr = instr.addNum === 0 ? "" : `addl ${reg2}, ${reg1}`;
    const lastShift = instr.addNum === 0 ? "" : `sar $${instr.shiftNum}, ${reg1}`;
    const shiftAddInstr = `sar $31, ${reg2}`;
    const subtractInstr = `subl ${reg2}, ${reg1}`;
    if (instr.destReg === null) {
      this.stackTracker.removeRegCacheVar(instr.dest);
    }
    if (instr.destReg !== null) {
      this.stackTracker.addRegCacheVar(instr.dest, instr.destReg);
    }
    const destInstrs = this.stackTracker.getAnyMemLoc(instr.dest, 1, isLong);
    const finalMoveInstr = this.utils.buildMovInstructionStr(
      reg1,
      destInstrs.memLocation,
      isLong
    );
    return [
      "# begin magic division",
      loadSrc1Instr,
      initMoveInstr,
      regLoadSrc1Instr,
      storeRegSrc1Instr,
      mulInstr,
      shiftInstrMul,
      addInstr,
      lastShift,
      shiftAddInstr,
      subtractInstr,
      destInstrs.loadInstrs,
      finalMoveInstr,
      "# end magic division"
    ].join("\n");
  }
  buildJumpDirectInstruction(instr) {
    return `jmp ${instr.label}`;
  }
  buildMethodPrologue(methodName) {
    const basePtrSaveInstr = "push %rbp";
    const basePtrUpdateInstr = "movq %rsp, %rbp";
    const methodParamsLoadInstr = this.buildMethodParamLoads();
    const stackPtrShift = this.stackPtrShift;
    const stackPtrShiftInstr = `subq $${stackPtrShift}, %rsp`;
    const methodPrologue = this.isMacOS ? "_" : "";
    const prologueIntrs = [
      methodPrologue + methodName + ":",
      "# entering prologue",
      basePtrSaveInstr,
      // scratchRegSaveIntrs,
      basePtrUpdateInstr,
      methodParamsLoadInstr,
      stackPtrShiftInstr,
      "# exiting prologue"
    ];
    return prologueIntrs.join("\n");
  }
  buildNegateInstruction(instr) {
    const { memLocation: memLoc, loadInstrs: loadIntrs } = this.stackTracker.getAnyMemLoc(instr.src, 0);
    const isLong = this.stackTracker.checkIsLong(instr.src);
    const tempRegUsed = this.utils.getScratchRegArray(isLong)[0];
    if (instr.destReg === null) {
      this.stackTracker.removeRegCacheVar(instr.dest);
    }
    if (instr.destReg !== null) {
      this.stackTracker.addRegCacheVar(instr.dest, instr.destReg);
    }
    const { memLocation: memLocDest, loadInstrs: loadIntrsDest } = this.stackTracker.getAnyMemLoc(instr.dest, 1, isLong);
    const asmCode = [
      `# ${instr.dest} = -${instr.src}`,
      loadIntrs,
      this.utils.buildMovInstructionStr(memLoc, tempRegUsed, isLong),
      `neg ${tempRegUsed}`,
      loadIntrsDest,
      this.utils.buildMovInstructionStr(tempRegUsed, memLocDest, isLong),
      "# negate instruction end"
    ].filter((str) => str.length > 0).join("\n");
    return asmCode;
  }
  buildBranches(basicBlock, isOrdered) {
    const branchBlock = basicBlock.branchSuccessors;
    if (branchBlock === null) {
      throw new Error("branch block is null");
    }
    const trueBlock = branchBlock.trueBlock;
    const falseBlock = branchBlock.falseBlock;
    const jumpInstr = new JumpBoolInstruction(
      branchBlock.conditionVar,
      "",
      branchBlock.trueBlock.label,
      branchBlock.falseBlock.label
    );
    const trueFallOff = trueBlock.mutPredecessors.size == 1;
    const hasFalloff = trueFallOff || falseBlock.mutPredecessors.size == 1;
    const jumpAsm = this.buildJumpBoolInstruction(
      jumpInstr,
      hasFalloff,
      trueFallOff
    );
    const restoreCacheAsm = this.buildRestoreCacheAsm(basicBlock);
    if (isOrdered) {
      this.removeFromTrueBranch(basicBlock);
    }
    const trueBlockCode = this.buildBasicBlock(trueBlock, isOrdered);
    if (isOrdered) {
      this.removeFromFalseBranch(basicBlock);
    }
    const falseBlockCode = this.buildBasicBlock(falseBlock, isOrdered);
    return [
      restoreCacheAsm,
      jumpAsm,
      `# true branch code`,
      trueBlockCode,
      "# end of true branch code",
      "# false branch code",
      falseBlockCode,
      "# end of false branch code"
    ].join("\n");
  }
  buildSuccessors(basicBlock, isOrdered) {
    const succesorBlock = basicBlock.joinSuccessor;
    if (succesorBlock === null) {
      throw new Error("succesor block is null");
    }
    const jumpInstr = new JumpDirectInstruction(
      succesorBlock.label,
      succesorBlock
    );
    const joinBlockCode = this.buildBasicBlock(succesorBlock, isOrdered);
    const jumpAsm = succesorBlock.mutPredecessors.size === 0 ? "" : this.buildJumpDirectInstruction(jumpInstr);
    return [
      jumpAsm,
      "# new block code",
      joinBlockCode,
      "# end of new block code"
    ].join("\n");
  }
  removeFromSuccessors(basicBlock) {
    const succesorBlock = basicBlock.joinSuccessor;
    if (succesorBlock !== null) {
      succesorBlock.mutPredecessors.delete(basicBlock.label);
    }
  }
  removeFromTrueBranch(basicBlock) {
    const branchBlock = basicBlock.branchSuccessors;
    if (branchBlock !== null) {
      branchBlock.trueBlock.mutPredecessors.delete(basicBlock.label);
    }
  }
  removeFromFalseBranch(basicBlock) {
    const branchBlock = basicBlock.branchSuccessors;
    if (branchBlock !== null) {
      branchBlock.falseBlock.mutPredecessors.delete(basicBlock.label);
    }
  }
  handleShadowSuccessor(basicBlock) {
    if (basicBlock.label.startsWith("skip_") && basicBlock.joinSuccessor) {
      this.removeFromSuccessors(basicBlock);
      basicBlock.instructions.push(
        new JumpDirectInstruction(
          basicBlock.joinSuccessor.label,
          basicBlock.joinSuccessor
        )
      );
      basicBlock.joinSuccessor = null;
    }
  }
  buildBasicBlock(basicBlock, isOrdered) {
    if (isOrdered && basicBlock.mutPredecessors.size > 0) {
      return "# skipped code for duplication";
    }
    if (!isOrdered && this.generatedBlocks.has(basicBlock.label)) {
      return "# skipped code for duplication";
    }
    if (!isOrdered) {
      const labelInstr = basicBlock.instructions[0];
      if (!(labelInstr instanceof LabelInstruction)) {
        throw new Error("First instruction is not label instruction");
      }
      labelInstr.label = basicBlock.label;
      this.handleShadowSuccessor(basicBlock);
    }
    const blockInstrs = basicBlock.instructions.map((instruction) => {
      if (instruction instanceof LoadConstantInstruction) {
        return this.buildLoadInstruction(instruction);
      }
      if (instruction instanceof ReturnInstruction) {
        return this.buildReturnInstruction(instruction);
      }
      if (instruction instanceof MagicDivideInstruction) {
        return this.buildMagicDivInstruction(instruction);
      }
      if (instruction instanceof BinOpInstruction) {
        return this.buildBinExprInstructions(instruction);
      }
      if (instruction instanceof CopyInstruction) {
        return this.buildCopyInstruction(instruction);
      }
      if (instruction instanceof CallInstruction) {
        return this.buildMethodCallInstruction(instruction);
      }
      if (instruction instanceof CastInstruction) {
        return this.buildCastInstruction(instruction);
      }
      if (instruction instanceof LabelInstruction) {
        return this.buildLabelInstruction(instruction);
      }
      if (instruction instanceof JumpDirectInstruction) {
        return this.buildJumpDirectInstruction(instruction);
      }
      if (instruction instanceof JumpBoolInstruction) {
        return "";
      }
      if (instruction instanceof CreateVarInstruction) {
        return this.storeVarFieldDeclaration(instruction);
      }
      if (instruction instanceof CreateArrayInstruction) {
        return this.storeArrFieldDeclaration(instruction);
      }
      if (instruction instanceof NegateInstruction) {
        return this.buildNegateInstruction(instruction);
      }
      throw new Error("Unknown instruction");
    });
    if (!isOrdered) {
      this.generatedBlocks.add(basicBlock.label);
    }
    const blockCode = blockInstrs.filter((instr) => instr.length > 0).join("\n");
    this.generatedBlocks.add(basicBlock.label);
    if (basicBlock.branchSuccessors) {
      return [blockCode, this.buildBranches(basicBlock, isOrdered)].join("\n");
    }
    if (basicBlock.joinSuccessor) {
      if (isOrdered) {
        this.removeFromSuccessors(basicBlock);
      }
      return [
        blockCode,
        this.buildRestoreCacheAsm(basicBlock),
        this.buildSuccessors(basicBlock, isOrdered)
      ].join("\n");
    }
    return blockCode;
  }
  buildLoadInstruction(loadInstr) {
    if (loadInstr.destReg === null) {
      this.stackTracker.removeRegCacheVar(loadInstr.dest);
    }
    if (loadInstr.destReg !== null) {
      this.stackTracker.addRegCacheVar(loadInstr.dest, loadInstr.destReg);
    }
    const isLong = loadInstr.literalType === literalType.long;
    const { memLocation: memoryLocation, loadInstrs: preloadIntrs } = this.stackTracker.getAnyMemLoc(loadInstr.dest, 0, isLong);
    const longCommentSuffix = isLong ? "L" : "";
    const regUsed = this.utils.getScratchRegArray(isLong)[1];
    const tempMove = this.utils.buildMovInstructionStr(
      `$${loadInstr.value}`,
      regUsed,
      isLong
    );
    return [
      `# ${loadInstr.dest} = ${loadInstr.value}${longCommentSuffix}`,
      preloadIntrs,
      tempMove,
      this.utils.buildMovInstructionStr(regUsed, memoryLocation, isLong)
    ].filter((str) => str.length > 0).join("\n");
  }
  buildReturnInstruction(returnInstr) {
    const returnInstructionSrc = returnInstr.src;
    if (!returnInstructionSrc)
      return "# returning \n" + this.buildMethodEpilogue();
    const { loadInstrs: loadIntrs, memLocation: returnVal } = this.stackTracker.getAnyMemLoc(returnInstructionSrc, 0);
    if (!returnVal) throw new Error();
    const isLong = this.stackTracker.checkIsLong(returnInstructionSrc);
    const returnReg = isLong ? "%rax" : "%eax";
    return [
      "# returning\n",
      loadIntrs,
      this.utils.buildMovInstructionStr(returnVal, returnReg, isLong),
      this.buildMethodEpilogue()
    ].join("\n");
  }
  isBooleanOp(op) {
    const booleanReturns = ["==", "!=", "<", ">", "<=", ">="];
    return booleanReturns.includes(op);
  }
  buildBinExprInstructions(binoOpInstr) {
    const src1Long = this.stackTracker.checkIsLong(binoOpInstr.expr1);
    const { memLocation: src1, loadInstrs: loadSrc1Instr } = this.stackTracker.getAnyMemLoc(binoOpInstr.expr1, 0, src1Long);
    const { memLocation: src2, loadInstrs: loadSrc2Instr } = this.stackTracker.getAnyMemLoc(binoOpInstr.expr2, 1, src1Long);
    const isLong = this.stackTracker.checkIsLong(binoOpInstr.expr1);
    const scratchArrUsed = this.utils.getScratchRegArray(isLong);
    const regLoadSrc1Instr = this.utils.buildRegMoveInstructionStr(
      src1,
      0,
      src1Long
    );
    const srcReg1 = scratchArrUsed[0];
    const src2Reg = scratchArrUsed[1];
    const regLoadSrc2Instr = this.utils.buildRegMoveInstructionStr(
      src2,
      1,
      src1Long
    );
    let binOpInstr = "";
    switch (binoOpInstr.binOp.toString()) {
      case "+":
        binOpInstr = this.buildAddInstructionStr(isLong);
        break;
      case "-":
        binOpInstr = this.buildSubInstructionStr(isLong);
        break;
      case "*":
        binOpInstr = this.buildMulInstructionStr(isLong);
        break;
      case "==":
        binOpInstr = this.buildEqInstructionStr(isLong);
        break;
      case "!=":
        binOpInstr = this.buildNeqInstructionStr(isLong);
        break;
      case "<":
        binOpInstr = this.buildLtInstructionStr(isLong);
        break;
      case ">":
        binOpInstr = this.buildGtInstructionStr(isLong);
        break;
      case "<=":
        binOpInstr = this.buildLeInstructionStr(isLong);
        break;
      case ">=":
        binOpInstr = this.buildGeInstructionStr(isLong);
        break;
      case "&&":
        binOpInstr = this.buildAndInstructionStr(isLong);
        break;
      case "||":
        binOpInstr = this.buildOrInstructionStr(isLong);
        break;
      //for both division and mod
      case "%":
        binOpInstr = this.buildModInstructionStr(isLong);
        break;
      case "/":
        binOpInstr = this.buildDivInstructionStr(isLong);
        break;
      case ">>":
        if (!(binoOpInstr instanceof RightShiftInstruction)) {
          throw new Error("incorrect instruction type");
        }
        binOpInstr = this.buildRightShiftInstructionStr(
          srcReg1,
          src2Reg,
          src2,
          binoOpInstr.isNegative,
          src1Long
        );
        break;
      case "<<":
        if (!(binoOpInstr instanceof LeftShiftInstruction)) {
          throw new Error("incorrect instruction type");
        }
        binOpInstr = this.buildLeftShiftInstructionStr(
          srcReg1,
          src2,
          binoOpInstr.isNegative
        );
        break;
      case "&":
        if (!(binoOpInstr instanceof AndModInstruction)) {
          throw new Error("incorrect instruction type");
        }
        binOpInstr = this.buildModAndInstructionStr(
          srcReg1,
          src2Reg,
          binoOpInstr.getAmountShifted(),
          binoOpInstr.getAmountAnded(),
          src1Long
        );
        break;
      default:
        console.log(binoOpInstr.binOp.toString());
        throw new Error("unrecognized bin op ! \n");
    }
    if (binoOpInstr.destReg === null) {
      this.stackTracker.removeRegCacheVar(binoOpInstr.dest);
    }
    if (binoOpInstr.destReg !== null) {
      this.stackTracker.addRegCacheVar(binoOpInstr.dest, binoOpInstr.destReg);
    }
    const bineExprResRegIdx = 0;
    const destMutateRegIdx = 1;
    const isBooleanDest = this.isBooleanOp(binoOpInstr.binOp.toString());
    const newScratchArr = isBooleanDest ? this.utils.getScratchRegArray(false) : scratchArrUsed;
    const isDestLong = src1Long && !isBooleanDest;
    const { memLocation: destMemLoc, loadInstrs: destLoadIntrs } = this.stackTracker.getAnyMemLoc(
      binoOpInstr.dest,
      destMutateRegIdx,
      isDestLong
    );
    const storeDestInstr = this.utils.buildMovInstructionStr(
      newScratchArr[bineExprResRegIdx],
      destMemLoc,
      isDestLong
    );
    const startComment = `# ${binoOpInstr.dest} = ${binoOpInstr.expr1} ${binoOpInstr.binOp.toString()} ${binoOpInstr.expr2}`;
    const endComment = "# end of bin op";
    return [
      startComment,
      loadSrc1Instr,
      regLoadSrc1Instr,
      loadSrc2Instr,
      regLoadSrc2Instr,
      binOpInstr,
      destLoadIntrs,
      storeDestInstr,
      endComment
    ].filter((str) => str.length > 0).join("\n");
  }
  buildRightShiftInstructionStr(reg1, reg2, immediate, isNeg, isLong) {
    const dollarLessImmediate = immediate.slice(1);
    const bttExtractVal = ((BigInt(1) << BigInt(dollarLessImmediate)) - 1n).toString();
    const suffix = isLong ? "q" : "l";
    const moveInstr = this.utils.buildMovInstructionStr(reg1, reg2, isLong);
    const signInstr = isLong ? `sar $63, ${reg2}` : `sar $31, ${reg2}`;
    const getValToAddInstr = `and${suffix} $${bttExtractVal}, ${reg2}`;
    const boundInstr = `add${suffix} ${reg2}, ${reg1}`;
    const negateInstr = isNeg ? `NEG ${reg1}` : "";
    const shiftInstr = `sar ${immediate}, ${reg1}`;
    return [
      moveInstr,
      signInstr,
      getValToAddInstr,
      boundInstr,
      shiftInstr,
      negateInstr
    ].filter((instr) => instr !== "").join("\n");
  }
  buildLeftShiftInstructionStr(reg, immediate, isNeg) {
    const negateInstr = isNeg ? `NEG ${reg}` : "";
    const shiftInstr = `sal ${immediate}, ${reg}`;
    return [shiftInstr, negateInstr].filter((instr) => instr !== "").join("\n");
  }
  buildModAndInstructionStr(reg1, reg2, andImmediate, ogNum, isLong) {
    const suffix = isLong ? "q" : "l";
    const shiftAmmount = isLong ? "63" : "31";
    const leftShiftAmount = getPowOf2(ogNum);
    if (leftShiftAmount === null) {
      throw new Error("left shift amount is null");
    }
    const storeMove = this.utils.buildMovInstructionStr(reg1, reg2, isLong);
    const andInstr = `and${suffix} $${andImmediate}, ${reg1}`;
    const shiftInstr = `sar $${shiftAmmount}, ${reg2}`;
    const rescaleInstr = `sal $${leftShiftAmount}, ${reg2}`;
    const rangeShift = `add${suffix} ${reg2}, ${reg1}`;
    return [storeMove, andInstr, shiftInstr, rescaleInstr, rangeShift].join(
      "\n"
    );
  }
  buildCopyInstruction(copyInstr) {
    const instrSrc = copyInstr.getCombinedSrc();
    const instrDest = copyInstr.getCombinedDest();
    const srcMutateReg = 0;
    const destMutateReg = 1;
    const { memLocation: src, loadInstrs: srcLoadIntrs } = this.stackTracker.getAnyMemLoc(instrSrc, srcMutateReg);
    const isLong = this.stackTracker.checkIsLong(instrSrc);
    const scratchArrUsed = this.utils.getScratchRegArray(isLong);
    const interimmovle = this.utils.buildRegMoveInstructionStr(
      src,
      srcMutateReg,
      isLong
    );
    if (copyInstr.destReg === null) {
      this.stackTracker.removeRegCacheVar(copyInstr.dest);
    }
    if (copyInstr.destReg !== null) {
      this.stackTracker.addRegCacheVar(copyInstr.dest, copyInstr.destReg);
    }
    const { memLocation: dest, loadInstrs: destLoadIntrs } = this.stackTracker.getAnyMemLoc(instrDest, destMutateReg, isLong);
    const actualmovle = this.utils.buildMovInstructionStr(
      scratchArrUsed[srcMutateReg],
      dest,
      isLong
    );
    const startComment = `# ${instrDest} = ${instrSrc}`;
    const endComment = "# end of copy instruction";
    return [
      startComment,
      srcLoadIntrs,
      interimmovle,
      destLoadIntrs,
      actualmovle,
      endComment
    ].filter((str) => str.length > 0).join("\n");
  }
  buildRestoreCacheAsm(curBlock) {
    const blockInstrs = curBlock.instructions;
    const lastInstr = blockInstrs[blockInstrs.length - 1];
    const liveWebs = /* @__PURE__ */ new Set();
    if (this.webMap === null) {
      return this.stackTracker.restoreAllCacheVars();
    }
    this.webMap.forEach((webs) => {
      webs.forEach((web) => {
        if (web.liveRange.has(lastInstr) || web.entry.has(lastInstr)) {
          liveWebs.add(web);
        }
      });
    });
    const sucLabels = /* @__PURE__ */ new Set();
    curBlock.getSuccessors().forEach((succ) => {
      sucLabels.add(succ.instructions[0]);
    });
    liveWebs.forEach((web) => {
      let isKilled = true;
      sucLabels.forEach((labelInstr) => {
        if (web.liveRange.has(labelInstr)) {
          isKilled = false;
        }
      });
      if (isKilled) {
        liveWebs.delete(web);
      }
    });
    const restoreVars = new Set([...liveWebs].map((web) => web.varName));
    const reloadInstrs = this.stackTracker.restoreSomeCacheVars(restoreVars);
    if (reloadInstrs.length === 0) {
      return "";
    }
    return ["# restoring cache", reloadInstrs, "# end of restoring cache"].join(
      "\n"
    );
  }
  buildMethodCallInstruction(callInstr) {
    const commentPreffix = callInstr.returnVar ? `${callInstr.returnVar} = ` : "";
    const methodCallStartEmptyComment = `# ${callInstr.methodName}(${callInstr.args.join(", ")})`;
    const methodCallStartStoreComment = `# ${commentPreffix}${callInstr.methodName}(${callInstr.args.join(", ")})`;
    const methocdCallStartComment = callInstr.returnVar ? methodCallStartStoreComment : methodCallStartEmptyComment;
    let regesKilled = this.methodRegesKilled.get(callInstr.methodName);
    regesKilled = regesKilled === void 0 ? getLongCallerSavedRegs() : regesKilled;
    const callArgLoading = this.buildMethodCallArgLoading(callInstr);
    const liveVars = this.findLiveVarsAfterInstr(callInstr);
    const flushInstrs = this.stackTracker.flushCache(regesKilled, liveVars);
    const methodCallAsm = "call " + (this.isMacOS ? "_" : "") + callInstr.methodName;
    this.stackTracker.enableCache();
    if (callInstr.returnVar) {
      if (callInstr.destReg === null) {
        this.stackTracker.removeRegCacheVar(callInstr.returnVar);
      }
      if (callInstr.destReg !== null) {
        this.stackTracker.addRegCacheVar(
          callInstr.returnVar,
          callInstr.destReg
        );
      }
      this.stackTracker.enableCache();
      const isLong = this.isMethodReturnLong(callInstr.methodName);
      const returnReg = isLong ? "%rax" : "%eax";
      const { memLocation: returnMemLoc, loadInstrs: loadIntrs } = this.stackTracker.getAnyMemLoc(callInstr.returnVar, 0, isLong);
      const returnToVarAsm = this.utils.buildMovInstructionStr(
        returnReg,
        returnMemLoc,
        isLong
      );
      return [
        methocdCallStartComment,
        callArgLoading,
        flushInstrs,
        methodCallAsm,
        loadIntrs,
        // regRestoreInstrs,
        returnToVarAsm,
        this.buildExternStackOffLoading(callInstr),
        "# end of method call"
      ].filter((str) => str.length > 0).join("\n");
    }
    return [
      methocdCallStartComment,
      callArgLoading,
      flushInstrs,
      methodCallAsm,
      // regRestoreInstrs,
      this.buildExternStackOffLoading(callInstr),
      "# end of method call"
    ].join("\n");
  }
  findLiveVarsAfterInstr(instr) {
    if (this.webMap === null) {
      return null;
    }
    const curWebs = /* @__PURE__ */ new Set();
    this.webMap.forEach((webs) => {
      webs.filter((web) => !web.isLastUse(instr)).forEach((web) => curWebs.add(web.varName));
    });
    return curWebs;
  }
  buildMethodCallRegArgLoading(callInstr) {
    const orderedLongRegArgs = ["%rdi", "%rsi", "%rdx", "%rcx", "%r8", "%r9"];
    const orderedRegArgs = ["%edi", "%esi", "%edx", "%ecx", "%r8d", "%r9d"];
    const paramLoadStr = callInstr.args.slice(0, 6).map((param, index) => {
      const toLongReg = orderedLongRegArgs[index];
      const isString = param instanceof StringLiteral;
      const strParam = isString ? param.val : param.toString();
      const isMemAddress = this.stackTracker.isMemAddress(strParam);
      const isLong = this.stackTracker.checkIsLong(strParam) || isMemAddress;
      const regUsed = isLong ? orderedLongRegArgs[index] : orderedRegArgs[index];
      const strLiteralVar = isString ? this.stackTracker.getstrLiteral(strParam) : null;
      const liveVars = this.findLiveVarsAfterInstr(callInstr);
      if (strLiteralVar !== null) {
        const flushInstr2 = this.stackTracker.flushCache(
          /* @__PURE__ */ new Set([toLongReg]),
          liveVars
        );
        const storeInstr = `lea ${strLiteralVar}(%rip), ${regUsed}`;
        return [flushInstr2, storeInstr].join("\n");
      }
      const { memLocation: methodArg, loadInstrs: loadIntrs } = this.stackTracker.getAnyMemLoc(strParam, 0);
      const flushInstr = this.stackTracker.flushCache(
        /* @__PURE__ */ new Set([toLongReg]),
        liveVars
      );
      return [
        loadIntrs,
        flushInstr,
        this.utils.buildMovInstructionStr(methodArg, regUsed, isLong)
      ].filter((str) => str.length > 0).join("\n");
    }).join("\n");
    return [
      `# beginning of ${callInstr.methodName} reg arg loading:`,
      paramLoadStr,
      "# end of reg arg loading"
    ].join("\n");
  }
  buildDCAFStackArgLoading(callInstr) {
    let rbpCount = this.argStoreShift;
    const paramLoadStr = callInstr.args.slice(6).map((param) => {
      const isString = param instanceof StringLiteral;
      const strParam = isString ? param.val : param.toString();
      const isMemAddress = this.stackTracker.isMemAddress(strParam);
      const isLong = this.stackTracker.checkIsLong(strParam) || isMemAddress;
      const memOffset = this.utils.calculateNextAddressOffset(
        rbpCount,
        isLong
      );
      rbpCount = rbpCount + memOffset;
      const memUsed = `${-rbpCount}(%rsp)`;
      const { memLocation: methodArg, loadInstrs: loadIntrs } = this.stackTracker.getAnyMemLoc(strParam, 0);
      const interimReg = this.utils.getScratchRegArray(isLong)[0];
      return [
        loadIntrs,
        this.utils.buildRegMoveInstructionStr(methodArg, 0, isLong),
        // in case we are using arguments passed from the stack
        this.utils.buildMovInstructionStr(interimReg, memUsed, isLong)
      ].filter((str) => str.length > 0).join("\n");
    }).join("\n");
    return [
      `# beginning of ${callInstr.methodName} stack arg loading:`,
      paramLoadStr,
      "# end of stack arg loading"
    ].join("\n");
  }
  buildExternStackArgLoading(callInstr) {
    const paramLoadStr = callInstr.args.slice(6).reverse().map((param) => {
      const isString = param instanceof StringLiteral;
      const strParam = isString ? param.val : param.toString();
      const isMemAddress = this.stackTracker.isMemAddress(strParam);
      const isLong = this.stackTracker.checkIsLong(strParam) || isMemAddress;
      const { memLocation: methodArg, loadInstrs: loadIntrs } = this.stackTracker.getAnyMemLoc(strParam, 0);
      const strLiteralVar = isString ? this.stackTracker.getstrLiteral(strParam) : null;
      if (strLiteralVar !== null) {
        return [
          `lea ${strLiteralVar}(%rip), ${this.utils.getLongScratchReg(0)}`,
          `push ${this.utils.getLongScratchReg(0)}`
        ].join("\n");
      }
      return [
        loadIntrs,
        this.utils.buildRegMoveInstructionStr(methodArg, 0, isLong),
        `push ${this.utils.getLongScratchReg(0)}`
      ].filter((str) => str.length > 0).join("\n");
    }).join("\n");
    const alignmentInstr = callInstr.args.length > 6 && callInstr.args.length % 2 == 1 ? "push %rax" : "";
    return [
      `# beginning of ${callInstr.methodName} stack arg loading:`,
      alignmentInstr,
      paramLoadStr,
      "# end of stack arg loading"
    ].join("\n");
  }
  buildExternStackOffLoading(callInstr) {
    const isImported = this.importSet.has(callInstr.methodName);
    if (!isImported) return "";
    return [
      "# restoring extern call stack",
      this.buildExternStackArgLoading(callInstr).split("\n").filter((instr) => instr.startsWith("push")).map((instr) => instr.replace("push", "pop")).join("\n"),
      "# end of restoring extern call stack"
    ].join("\n");
  }
  buildMethodCallStackArgLoading(callInstr) {
    const isImported = this.importSet.has(callInstr.methodName);
    return isImported ? this.buildExternStackArgLoading(callInstr) : this.buildDCAFStackArgLoading(callInstr);
  }
  buildMethodCallArgLoading(callInstr) {
    return [
      this.buildMethodCallRegArgLoading(callInstr),
      this.buildMethodCallStackArgLoading(callInstr)
    ].join("\n");
  }
  buildCastInstruction(castInstr) {
    const isLongDest = castInstr.castType === literalType.long;
    if (isLongDest) {
      this.stackTracker.addLongVar(castInstr.dest);
    }
    const clearTempRegInstr = this.utils.buildRegMoveInstructionStr(
      "$0",
      0,
      true
    );
    const isLongSrc = this.stackTracker.checkIsLong(castInstr.src);
    const signExtendInstr = isLongDest && !isLongSrc ? `movsx ${this.utils.getScratchReg(0)}, ${this.utils.getLongScratchReg(
      0
    )}` : "";
    const { memLocation: memSrc, loadInstrs: srcLoadIntrs } = this.stackTracker.getAnyMemLoc(castInstr.src, 0, isLongSrc);
    if (castInstr.destReg === null) {
      this.stackTracker.removeRegCacheVar(castInstr.dest);
    }
    if (castInstr.destReg !== null) {
      this.stackTracker.addRegCacheVar(castInstr.dest, castInstr.destReg);
    }
    const { memLocation: memDest, loadInstrs: destLoadIntrs } = this.stackTracker.getAnyMemLoc(castInstr.dest, 1, isLongDest);
    const destReg = this.utils.getScratchRegArray(isLongDest)[0];
    const dataMoveInstr = this.utils.buildRegMoveInstructionStr(
      memSrc,
      0,
      isLongSrc
    );
    const dataMoveInstr2 = this.utils.buildMovInstructionStr(
      destReg,
      memDest,
      isLongDest
    );
    const startComment = `# ${castInstr.dest} = ${literalType[castInstr.castType]}(${castInstr.src})`;
    const endComment = "# end of cast";
    return [
      startComment,
      clearTempRegInstr,
      srcLoadIntrs,
      dataMoveInstr,
      signExtendInstr,
      destLoadIntrs,
      dataMoveInstr2,
      endComment
    ].filter((str) => str.length > 0).join("\n");
  }
  buildMethodEpilogue(methodName, isFinal = false) {
    const basePtrRestoreInstr = "pop %rbp";
    const stackPtrShift = this.stackPtrShift;
    const stackPtrRestoreInstr = `addq $${stackPtrShift}, %rsp`;
    const mainAppend = methodName === "main" ? "xor %rax, %rax" : "";
    const exceptionAsm = methodName != void 0 && !(this.methodReturnTypes.get(methodName) instanceof VoidType) ? this.runtimeExceptionAsm : "";
    const exitInstr = "ret";
    const endLabelInstr = isFinal && this.endLabel !== "" ? `${this.endLabel}:` : "";
    const epilogueIntrs = [
      "# entering epilogue",
      endLabelInstr,
      exceptionAsm,
      stackPtrRestoreInstr,
      basePtrRestoreInstr,
      mainAppend,
      exitInstr,
      "# exiting epilogue"
    ];
    return epilogueIntrs.filter((str) => str.length > 0).join("\n");
  }
  clear() {
    this.stackTracker.clear();
    this.stackPtrShift = 0;
    this.methodParams = [];
    this.argStoreShift = 8 * 2;
    this.scopeTrackers.clear();
    this.scopeTrackers.set(0, this.stackTracker);
    this.generatedBlocks.clear();
  }
  isMethodReturnLong(methodName) {
    const returnType = this.methodReturnTypes.get(methodName);
    return returnType instanceof LongType;
  }
  buildAddInstructionStr(isLong) {
    return this.builbinOpInsructionStr("add", isLong);
  }
  buildSubInstructionStr(isLong) {
    return this.builbinOpInsructionStr("sub", isLong);
  }
  buildMulInstructionStr(isLong) {
    return this.builbinOpInsructionStr("imul", isLong);
  }
  buildEqInstructionStr(isLong) {
    return this.buildCompInstructionStr("e", isLong);
  }
  buildNeqInstructionStr(isLong) {
    return this.buildCompInstructionStr("ne", isLong);
  }
  buildLtInstructionStr(isLong) {
    return this.buildCompInstructionStr("l", isLong);
  }
  buildLeInstructionStr(isLong) {
    return this.buildCompInstructionStr("le", isLong);
  }
  buildGtInstructionStr(isLong) {
    return this.buildCompInstructionStr("g", isLong);
  }
  buildGeInstructionStr(isLong) {
    return this.buildCompInstructionStr("ge", isLong);
  }
  buildCompInstructionStr(instructionSuffix, isLong) {
    const scratchArrUsed = this.utils.getScratchRegArray(isLong);
    const opSuffix = isLong ? "q" : "l";
    const CompareInstr = `cmp${opSuffix} ${scratchArrUsed[1]}, ${scratchArrUsed[0]}`;
    const byteReg = `${this.utils.getLongScratchReg(1)}b`;
    const setInstr = `set${instructionSuffix} ${byteReg} `;
    const intReg = this.utils.getScratchReg(0);
    const fillInstr = `movzx ${byteReg}, ${intReg}`;
    return [CompareInstr, setInstr, fillInstr].join("\n");
  }
  buildDivInstructionStr(isLong) {
    const scratchArrUsed = this.utils.getScratchRegArray(isLong);
    const suffix = isLong ? "q" : "l";
    const loadReg = isLong ? "%rax" : "%eax";
    const signExtendInstr = isLong ? "cqo" : "cltd";
    const tempBinOpInstr = `idiv${suffix} ${scratchArrUsed[1]}`;
    const moveBackInstr = this.utils.buildMovInstructionStr(
      loadReg,
      scratchArrUsed[0],
      isLong
    );
    return [
      // loadIntr,
      signExtendInstr,
      tempBinOpInstr,
      moveBackInstr
    ].join("\n");
  }
  buildModInstructionStr(isLong) {
    const scratchArrUsed = this.utils.getScratchRegArray(isLong);
    const suffix = isLong ? "q" : "l";
    const modReg = isLong ? "%rdx" : "%edx";
    const signExtendInstr = isLong ? "cqo" : "cltd";
    const tempBinOpInstr = `idiv${suffix} ${scratchArrUsed[1]}`;
    const moveBackInstr = this.utils.buildMovInstructionStr(
      modReg,
      scratchArrUsed[0],
      isLong
    );
    return [
      // loadInstr,
      signExtendInstr,
      tempBinOpInstr,
      moveBackInstr
    ].join("\n");
  }
  buildAndInstructionStr(isLong) {
    return this.builbinOpInsructionStr("and", isLong);
  }
  buildOrInstructionStr(isLong) {
    return this.builbinOpInsructionStr("or", isLong);
  }
  builbinOpInsructionStr(instrName, isLong) {
    const scratchArray = this.utils.getScratchRegArray(isLong);
    const suffix = this.utils.getInstrSuffix(isLong);
    return `${instrName}${suffix} ${scratchArray[1]}, ${scratchArray[0]}`;
  }
  findStackPtrShift(basicBlock) {
    const saveTracker = this.stackTracker.duplicate();
    const saveMethodParams = [...this.methodParams];
    this.buildBasicBlock(basicBlock, false);
    const stackPtrShift = this.stackTracker.getMaxStackPtr() + 16;
    this.stackTracker = saveTracker;
    this.scopeTrackers.set(0, this.stackTracker);
    this.methodParams = saveMethodParams;
    const declSize = 8;
    const prologueSavedSpace = declSize * 2;
    const numBytesRequired = stackPtrShift;
    const currentSpacing = prologueSavedSpace + numBytesRequired;
    let extraShift = 0;
    switch (currentSpacing % 16) {
      case 0:
        extraShift = 0;
        break;
      case 4:
        extraShift = 12;
        break;
      case 8:
        extraShift = 8;
        break;
      case 12:
        extraShift = 4;
        break;
    }
    return extraShift + numBytesRequired;
  }
}
const _DefContainer = class _DefContainer {
  constructor(blockName, dest, exprSrc) {
    this.blockName = blockName;
    this.dest = dest;
    this.exprSrc = exprSrc;
    this.isReplaceable = true;
    this.localCount = _DefContainer.globalCount;
    _DefContainer.globalCount++;
  }
  toString() {
    return `${this.blockName} assign #${this.localCount}: ${this.dest} = ${this.exprSrc.toString()}`;
  }
  static resetGlobalCount() {
    _DefContainer.globalCount = 0;
  }
};
_DefContainer.globalCount = 0;
let DefContainer = _DefContainer;
class DataFlowUtils {
  getSurvivingDefinitions(currentDefinitions, block) {
    const killedDefs = this.getKilledDefinitions(currentDefinitions, block);
    return setDifference(currentDefinitions, killedDefs);
  }
  getKilledDefinitions(currentDefinitions, block) {
    const blockDefinitions = this.getVarDefinitions(block);
    const killedDefs = /* @__PURE__ */ new Set();
    currentDefinitions.forEach((def) => {
      if (blockDefinitions.has(def.dest)) {
        killedDefs.add(def);
      }
    });
    return killedDefs;
  }
  getDefinitionExprs(block) {
    const defMap = /* @__PURE__ */ new Map();
    block.instructions.forEach((instruction) => {
      const dest = instruction.getDest();
      if (dest) {
        const defContainer = new DefContainer(block.label, dest, instruction);
        defMap.set(dest, defContainer);
      }
    });
    const definitions = /* @__PURE__ */ new Set([...defMap.values()]);
    DefContainer.resetGlobalCount();
    return definitions;
  }
  getVarDefinitions(block) {
    const defExprs = this.getDefinitionExprs(block);
    const definitions = /* @__PURE__ */ new Set();
    defExprs.forEach((def) => {
      definitions.add(def.dest);
    });
    return definitions;
  }
  getUses(block) {
    let uses = /* @__PURE__ */ new Set();
    block.instructions.forEach((instruction) => {
      const instructionUses = this.getInstructionUses(instruction);
      uses = setUnion(uses, instructionUses);
    });
    if (block.branchSuccessors) {
      uses.add(block.branchSuccessors.conditionVar);
    }
    return uses;
  }
  addPotentialUse(uses, dest) {
    const potentialUse = getSplitName(dest);
    if (dest !== potentialUse) {
      uses.add(potentialUse);
    }
  }
  getInstructionUses(instruction) {
    const uses = /* @__PURE__ */ new Set();
    if (instruction instanceof NegateInstruction) {
      uses.add(getSplitName(instruction.src));
      return uses;
    }
    if (instruction instanceof BinOpInstruction) {
      uses.add(getSplitName(instruction.expr1));
      uses.add(getSplitName(instruction.expr2));
      return uses;
    }
    if (instruction instanceof CopyInstruction) {
      uses.add(getSplitName(instruction.src));
      this.addPotentialUse(uses, instruction.dest);
      return uses;
    }
    if (instruction instanceof CallInstruction) {
      instruction.args.filter((arg) => !(arg instanceof StringLiteral)).forEach((arg) => {
        uses.add(getSplitName(arg));
      });
      return uses;
    }
    if (instruction instanceof JumpBoolInstruction) {
      uses.add(instruction.conditionVar);
      return uses;
    }
    if (instruction instanceof CastInstruction) {
      uses.add(getSplitName(instruction.src));
      return uses;
    }
    if (instruction instanceof ReturnInstruction) {
      if (instruction.src) {
        uses.add(getSplitName(instruction.src));
      }
      return uses;
    }
    if (instruction instanceof LoadConstantInstruction) {
      const splitName = getSplitName(instruction.dest);
      if (splitName !== instruction.dest) {
        uses.add(splitName);
      }
      return uses;
    }
    return uses;
  }
  computeReachingDefinitions(blocks) {
    DefContainer.resetGlobalCount();
    const inMap = /* @__PURE__ */ new Map();
    const outMap = /* @__PURE__ */ new Map();
    const genMap = /* @__PURE__ */ new Map();
    blocks.forEach((block) => {
      const gen = this.getDefinitionExprs(block);
      genMap.set(block, gen);
      inMap.set(block, /* @__PURE__ */ new Set());
      outMap.set(block, new Set(gen));
    });
    let changed = true;
    while (changed) {
      changed = false;
      for (const block of blocks) {
        let newIn = /* @__PURE__ */ new Set();
        block.getPredecessors().forEach((pred) => {
          outMap.get(pred)?.forEach((def) => newIn.add(def));
        });
        const gen = genMap.get(block);
        const surviving = this.getSurvivingDefinitions(newIn, block);
        const newOut = /* @__PURE__ */ new Set([...gen, ...surviving]);
        const oldIn = inMap.get(block);
        const oldOut = outMap.get(block);
        const inChanged = oldIn.size !== newIn.size || [...oldIn].some((def) => !newIn.has(def));
        const outChanged = oldOut.size !== newOut.size || [...oldOut].some((def) => !newOut.has(def));
        if (inChanged || outChanged) {
          inMap.set(block, newIn);
          outMap.set(block, newOut);
          changed = true;
        }
      }
    }
    return inMap;
  }
}
class InstructionMetadata {
  constructor(instr, isReplaceable) {
    this.instr = instr;
    this.isReplaceable = isReplaceable;
  }
}
class CpOptimizer {
  constructor(program) {
    this.program = program;
    this.dataflowUtils = new DataFlowUtils();
  }
  propagateConstants(blocks, methodName, maxTimes = 10) {
    if (maxTimes === 0) {
      return;
    }
    blocks.forEach((block) => {
      block.cpIn = /* @__PURE__ */ new Set();
      block.cpOut = /* @__PURE__ */ new Set();
    });
    const firstBlock = blocks[0];
    firstBlock.cpIn = /* @__PURE__ */ new Set();
    firstBlock.cpOut = this.dataflowUtils.getDefinitionExprs(firstBlock);
    const changed = new Set(
      blocks.filter((block) => block.label !== firstBlock.label)
    );
    while (changed.size > 0) {
      const block = setPop(changed);
      const oldOut = block.cpOut;
      block.cpIn = /* @__PURE__ */ new Set();
      block.getPredecessors().forEach((pred) => {
        block.cpIn = setUnion(block.cpIn, pred.cpOut);
      });
      const newDefs = this.dataflowUtils.getDefinitionExprs(block);
      const survivingInDefs = this.dataflowUtils.getSurvivingDefinitions(
        block.cpIn,
        block
      );
      this.disableOldReassignments(survivingInDefs, newDefs);
      block.cpOut = setUnion(newDefs, survivingInDefs);
      if (setUnion(oldOut, block.cpOut).size !== oldOut.size) {
        block.getSuccessors().forEach((succ) => changed.add(succ));
      }
    }
    let copiedExpr = false;
    blocks.forEach((block) => {
      copiedExpr = this.cleanBlock(block) || copiedExpr;
    });
    if (copiedExpr) {
      this.propagateConstants(blocks, methodName, maxTimes - 1);
    }
  }
  disableOldReassignments(oldDefs, newDefs) {
    const relabeledDefs = new Set([...newDefs].map((def) => def.dest));
    oldDefs.forEach((def) => {
      const srcs = def.exprSrc.getSrcs();
      srcs.forEach((src) => {
        if (relabeledDefs.has(src)) {
          def.isReplaceable = false;
        }
      });
    });
  }
  removeArrayStatements(replaceMap) {
    [...replaceMap.keys()].forEach((key) => {
      if (isArrayVariable(key) || isArrayVariable(replaceMap.get(key))) {
        replaceMap.delete(key);
      }
    });
  }
  isGlobalVariable(key) {
    return this.program.getGlobals().has(key);
  }
  removeGlobalStatements(replaceMap) {
    const globals = this.program.getGlobals();
    [...replaceMap.keys()].forEach((key) => {
      if (globals.has(key)) {
        replaceMap.delete(key);
      }
    });
  }
  cleanBlock(block, maxTimes = 1) {
    if (maxTimes === 0) return false;
    let hasChanged = false;
    const reachingDefMap = /* @__PURE__ */ new Map();
    const replaceMap = /* @__PURE__ */ new Map();
    block.cpIn.forEach((def) => {
      reachingDefMap.set(def.dest, /* @__PURE__ */ new Set());
    });
    block.cpIn.forEach((def) => {
      const metadata = new InstructionMetadata(def.exprSrc, def.isReplaceable);
      reachingDefMap.get(def.dest)?.add(metadata);
    });
    reachingDefMap.forEach((value, key) => {
      if (value.size === 1) {
        const instructionMd = setSample(value);
        const instruction = instructionMd.instr;
        const isReplaceable = instructionMd.isReplaceable;
        if (instruction instanceof LoadConstantInstruction) {
          replaceMap.set(key, instruction.getNumericRep());
        }
        if (instruction instanceof CopyInstruction && isReplaceable) {
          replaceMap.set(key, instruction.src);
        }
      }
    });
    this.removeArrayStatements(replaceMap);
    this.removeGlobalStatements(replaceMap);
    const killers = /* @__PURE__ */ new Map();
    block.instructions.forEach((instruction) => {
      hasChanged = instruction.replaceSrcs(replaceMap) || hasChanged;
      const dest = instruction.getDest();
      if (dest && !this.isGlobalVariable(dest) && !isArrayVariable(dest)) {
        replaceMap.delete(dest);
        if (instruction instanceof LoadConstantInstruction) {
          if (safeExtractNum(instruction.getNumericRep()) !== null) {
            replaceMap.set(dest, instruction.getNumericRep());
          }
        }
        if (instruction instanceof CopyInstruction) {
          const src = instruction.src;
          if (!isArrayVariable(src)) {
            replaceMap.set(dest, src);
          }
          if (!killers.has(src)) {
            killers.set(src, []);
          }
          killers.get(src)?.push(dest);
        }
        if (instruction instanceof BinOpInstruction) {
          if (!killers.has(instruction.expr1)) {
            killers.set(instruction.expr1, []);
          }
          if (!killers.has(instruction.expr2)) {
            killers.set(instruction.expr2, []);
          }
          killers.get(instruction.expr1)?.push(dest);
          killers.get(instruction.expr2)?.push(dest);
          const outputInstr = foldInstr(instruction);
          if (outputInstr instanceof CopyInstruction) {
            replaceMap.set(dest, outputInstr.src);
          }
        }
        killers.get(dest)?.forEach((killer) => {
          replaceMap.delete(killer);
        });
      }
    });
    this.replaceCopies(block);
    if (block.branchSuccessors) {
      const conditionVar = block.branchSuccessors.conditionVar;
      if (replaceMap.has(conditionVar)) {
        block.branchSuccessors.conditionVar = replaceMap.get(
          conditionVar
        );
      }
    }
    if (hasChanged) {
      this.cleanBlock(block, 0);
      return true;
    }
    return false;
  }
  replaceCopies(block) {
    block.instructions = block.instructions.map((instruction) => {
      if (instruction instanceof CopyInstruction) {
        const extractedNum = safeExtractNum(instruction.src);
        if (extractedNum !== null) {
          const numType = extractedNum.includes("b") ? literalType.bool : extractedNum.includes("L") ? literalType.long : literalType.int;
          const numUsed = numType === literalType.int ? instruction.src : instruction.src.slice(0, -1);
          return new LoadConstantInstruction(
            instruction.dest,
            numUsed,
            numType
          );
        }
      }
      return instruction;
    });
  }
  removeBlockSuccessors(deleteBlock) {
    deleteBlock.getSuccessors().forEach((succ) => {
      succ.popPredecessor(deleteBlock);
      if (succ.getPredecessors().length === 0) {
        this.removeBlockSuccessors(succ);
      }
    });
    deleteBlock.joinSuccessor = null;
    deleteBlock.branchSuccessors = null;
  }
}
class DceOptimizer {
  constructor(program, localMethods) {
    this.program = program;
    this.localMethods = localMethods;
    this.isLocal = true;
    this.dataflowUtils = new DataFlowUtils();
    this.killableMethods = /* @__PURE__ */ new Set();
  }
  eliminateDeadCode(blocks, methodName, maxTimes = 1) {
    if (maxTimes === 0) {
      return;
    }
    blocks.forEach((block) => {
      block.in = /* @__PURE__ */ new Set();
      block.out = /* @__PURE__ */ new Set();
      if (block.branchSuccessors) {
        const boolExtracteced = safeParseBool(
          block.branchSuccessors.conditionVar
        );
        if (boolExtracteced) {
          this.removeDeadBranch(block, boolExtracteced === "1");
        }
      }
    });
    const lastBlock = blocks[blocks.length - 1];
    this.cleanBlock(lastBlock);
    lastBlock.in = this.dataflowUtils.getUses(lastBlock);
    const changed = new Set(
      blocks.filter((block) => block.label !== lastBlock.label)
    );
    while (changed.size > 0) {
      const block = setPop(changed);
      const oldIn = block.in;
      block.out = /* @__PURE__ */ new Set();
      block.getSuccessors().forEach((succ) => {
        block.out = setUnion(block.out, succ.in);
      });
      const uses = this.dataflowUtils.getUses(block);
      const rhs = setDifference(
        block.out,
        this.dataflowUtils.getVarDefinitions(block)
      );
      block.in = setUnion(uses, rhs);
      if (setUnion(oldIn, block.in).size !== setIntersection(oldIn, block.in).size) {
        block.getPredecessors().forEach((pred) => changed.add(pred));
      }
    }
    let eliminatedBlock = false;
    const methodIndex = this.program.orderedMethods.indexOf(methodName);
    this.isLocal = true;
    blocks.forEach((block) => {
      eliminatedBlock = this.cleanBlock(block) || eliminatedBlock;
    });
    if (this.isLocal) {
      this.localMethods.add(methodName);
      if (this.program.orderedDataTypes[methodIndex].equals(new VoidType())) {
        this.killableMethods.add(methodName);
      }
    }
    if (eliminatedBlock) {
      this.eliminateDeadCode(blocks, methodName, maxTimes - 1);
    }
  }
  cleanBlock(block, maxTimes = 10) {
    let earliestReturn = null;
    if (maxTimes === 0) {
      return false;
    }
    let hasChanged = false;
    let uses = new Set(block.out.values());
    const globals = this.program.getGlobals();
    if (block.branchSuccessors) {
      uses.add(block.branchSuccessors.conditionVar);
      this.dataflowUtils.addPotentialUse(
        uses,
        block.branchSuccessors.conditionVar
      );
    }
    const toDelete = /* @__PURE__ */ new Set();
    block.instructions.reverse();
    block.instructions.forEach((instruction, index) => {
      if (instruction instanceof CallInstruction) {
        const isDeadMethod = this.isDeadMethod(instruction);
        if (isDeadMethod) {
          toDelete.add(index);
          hasChanged = true;
          return;
        }
        if (!this.isLocalMethod(instruction)) {
          this.isLocal = false;
        }
      }
      if (instruction instanceof ReturnInstruction) {
        earliestReturn = index;
      }
      const dest = instruction.getDest();
      const instructionUses = this.dataflowUtils.getInstructionUses(instruction);
      if (dest) {
        const splitName = dest.split(/\[|\]/)[0];
        this.isLocal = this.isLocal && !globals.has(splitName);
        if (this.isRemovable(dest, uses) && !(instruction instanceof CallInstruction)) {
          toDelete.add(index);
          hasChanged = true;
        }
        uses.delete(dest);
      }
      if (!toDelete.has(index)) {
        uses = setUnion(uses, instructionUses);
      }
    });
    if (earliestReturn !== null) {
      for (let i2 = 0; i2 < earliestReturn; i2++) {
        toDelete.add(i2);
        hasChanged = true;
      }
      this.removeBlockSuccessors(block);
    }
    block.instructions = block.instructions.filter((instr, index) => {
      return !toDelete.has(index);
    }).reverse();
    if (hasChanged) {
      this.cleanBlock(block, maxTimes - 1);
      return true;
    }
    return false;
  }
  removeBlockSuccessors(deleteBlock) {
    deleteBlock.getSuccessors().forEach((succ) => {
      succ.popPredecessor(deleteBlock);
      if (succ.getPredecessors().length === 0) {
        this.removeBlockSuccessors(succ);
      }
    });
    deleteBlock.joinSuccessor = null;
    deleteBlock.branchSuccessors = null;
  }
  removeDeadBranch(block, keepTrueBlock) {
    const deleteBlock = !keepTrueBlock ? block.branchSuccessors?.trueBlock : block.branchSuccessors?.falseBlock;
    const remainingBlock = !keepTrueBlock ? block.branchSuccessors?.falseBlock : block.branchSuccessors?.trueBlock;
    this.program.addBlockSuccessor(block, remainingBlock);
    deleteBlock.popPredecessor(block);
    if (deleteBlock.getPredecessors().length === 0) {
      this.removeBlockSuccessors(deleteBlock);
    }
    block.branchSuccessors = null;
    return true;
  }
  isRemovable(dest, curentUses) {
    const globals = this.program.getGlobals();
    const splitName = dest.split(/\[|\]/)[0];
    return !curentUses.has(dest) && splitName === dest && !globals.has(splitName);
  }
  isLocalMethod(instruction) {
    return this.localMethods.has(instruction.methodName);
  }
  isDeadMethod(instruction) {
    return this.killableMethods.has(instruction.methodName);
  }
}
class ExprContainer {
  constructor(expr1, binOp, expr2, result) {
    this.expr1 = expr1;
    this.binOp = binOp;
    this.expr2 = expr2;
    this.result = result;
    this.renamed = false;
  }
  /**
   * Generate a unique signature for this expression
   */
  getSignature() {
    return `${this.expr1}${this.binOp.toString()}${this.expr2}`;
  }
  /**
   * Check if this expression uses a given variable
   */
  usesVar(varName) {
    return this.expr1 === varName || this.expr2 === varName;
  }
  /**
   * Check if this expression matches a given signature
   */
  matches(signature) {
    return this.getSignature() === signature;
  }
  /**
   * Get all variables used in this expression
   */
  getUsedVars() {
    return [this.expr1, this.expr2];
  }
}
class CastExprContainer {
  constructor(expr, type, result) {
    this.expr = expr;
    this.type = type;
    this.result = result;
  }
  getSignature() {
    return `cast(${this.expr},${this.type})`;
  }
  usesVar(varName) {
    return this.expr === varName;
  }
  getUsedVars() {
    return [this.expr];
  }
}
class methodCallContainer {
  constructor(methodName, args, result) {
    this.methodName = methodName;
    this.args = args;
    this.result = result;
  }
  getSignature() {
    return `${this.methodName}(${this.args.join(",")})`;
  }
  usesVar(varName) {
    return this.args.includes(varName);
  }
  getUsedVars() {
    return [...this.args.map((arg) => arg.toString())];
  }
}
class CseOptimizer {
  constructor(program, localMethodSet) {
    this.program = program;
    this.localMethodSet = localMethodSet;
    this.counter = -1;
  }
  getNewCseName() {
    this.counter++;
    return `cse_${this.counter}`;
  }
  /**
   * Main entry point for Common Subexpression Elimination
   * Returns true if any changes were made, false otherwise
   */
  eliminateCommonSubexpressions(blocks) {
    blocks.forEach((block) => {
      block.aeIn = /* @__PURE__ */ new Set();
      block.aeOut = /* @__PURE__ */ new Set();
    });
    const firstBlock = blocks[0];
    firstBlock.aeOut = this.getGeneratedExpressions(firstBlock);
    const changed = new Set(
      blocks.filter((block) => block.label !== firstBlock.label)
    );
    while (changed.size > 0) {
      const block = setPop(changed);
      const oldOut = new Set(block.aeOut);
      block.aeIn = this.intersectPredecessorAE(block);
      const generatedExpr = this.getGeneratedExpressions(block);
      const survivingExpr = this.getSurvivingExpressions(block.aeIn, block);
      block.aeOut = setUnion(generatedExpr, survivingExpr);
      if (!areSetsEqual(oldOut, block.aeOut)) {
        block.getSuccessors().forEach((succ) => changed.add(succ));
      }
    }
    let hasChanged = false;
    blocks.forEach((block) => {
      this.modifyPredecessors(block);
      hasChanged = this.replaceRedundantExpressions(block);
    });
    return hasChanged;
  }
  // when copying over expressions from parent blocks we need to make sure we are considering all possible
  // variable names storage
  modifyPredecessors(curBlock) {
    const predecessors = curBlock.getPredecessors();
    const aeContainers = curBlock.aeIn;
    const redefMap = /* @__PURE__ */ new Map();
    const containerWeights = /* @__PURE__ */ new Map();
    const usedContainers = new Set(
      [...aeContainers].filter(
        (container) => container instanceof ExprContainer
      )
    );
    usedContainers.forEach((container) => {
      if (container.renamed) return;
      container.result = this.getNewCseName();
      container.renamed = true;
      redefMap.set(container.getSignature(), container.result);
    });
    predecessors.forEach((pred) => {
      const prevContainers = pred.instructions.filter((instr) => instr instanceof BinOpInstruction).map((instr) => {
        if (!(instr instanceof BinOpInstruction)) {
          throw new Error("instr is not BinOpInstruction");
        }
        const newContainer = new ExprContainer(
          instr.expr1,
          instr.binOp,
          instr.expr2,
          instr.dest
        );
        containerWeights.set(newContainer.getSignature(), instr.weight);
        return newContainer;
      });
      prevContainers.forEach((container) => {
        if (redefMap.has(container.getSignature())) {
          const cseVar = redefMap.get(container.getSignature());
          if (cseVar === void 0) {
            throw new Error("cseVar is undefined");
          }
          const copyOver = new CopyInstruction(cseVar, container.result);
          copyOver.weight = containerWeights.get(container.getSignature());
          pred.instructions.push(copyOver);
        }
      });
    });
  }
  /**
   * Compute the intersection of all predecessor OUT sets
   */
  intersectPredecessorAE(block) {
    const preds = block.getPredecessors();
    const signatures = /* @__PURE__ */ new Map();
    preds.forEach((pred) => {
      pred.aeOut.forEach((expr) => {
        const sig = expr.getSignature();
        if (!signatures.has(sig)) {
          signatures.set(sig, []);
        }
        signatures.get(sig).push(expr);
      });
    });
    const result = /* @__PURE__ */ new Set();
    const signatureValues = [...signatures.values()];
    signatureValues.filter((exprs) => exprs.length === preds.length).forEach((expr) => {
      result.add(expr[0]);
    });
    return result;
  }
  /**
   * Get expressions generated in this block
   */
  getGeneratedExpressions(block) {
    const generated = /* @__PURE__ */ new Set();
    const killed = /* @__PURE__ */ new Set();
    let breakEquiv = false;
    block.instructions.reverse().forEach((instr) => {
      if (breakEquiv) {
        return;
      }
      const dest = instr.getDest();
      if (instr instanceof BinOpInstruction) {
        if (killed.has(instr.expr1) || killed.has(instr.expr2)) {
          return;
        }
        const expr = new ExprContainer(
          instr.expr1,
          instr.binOp,
          instr.expr2,
          instr.dest
        );
        generated.add(expr);
      } else if (instr instanceof CastInstruction) {
        if (killed.has(instr.src)) {
          return;
        }
        const expr = new CastExprContainer(
          instr.src,
          instr.castType,
          instr.dest
        );
        generated.add(expr);
      } else if (instr instanceof CallInstruction) {
        if (!this.localMethodSet.has(instr.methodName)) {
          breakEquiv = true;
          return;
        }
        const expr = new methodCallContainer(
          instr.methodName,
          instr.args,
          instr.returnVar ? instr.returnVar : null
        );
        generated.add(expr);
      }
      if (dest !== null) killed.add(dest);
    });
    block.instructions.reverse();
    return generated;
  }
  /**
   * Get expressions from IN that survive (aren't killed) in this block
   */
  getSurvivingExpressions(inSet, block) {
    const killed = /* @__PURE__ */ new Set();
    block.instructions.forEach((instr) => {
      const dest = instr.getDest();
      if (dest) killed.add(dest);
    });
    const result = /* @__PURE__ */ new Set();
    inSet.forEach((expr) => {
      if (expr instanceof ExprContainer) {
        if (!killed.has(expr.expr1) && !killed.has(expr.expr2)) {
          result.add(expr);
        }
      } else if (expr instanceof CastExprContainer) {
        if (!killed.has(expr.expr)) {
          result.add(expr);
        }
      }
    });
    return result;
  }
  /**
   * Replace redundant expressions with copies of existing results
   * Enhanced to handle multiple expression types, global expressions and function calls
   */
  replaceRedundantExpressions(block) {
    let changesMade = false;
    let availableExprs = /* @__PURE__ */ new Set([...block.aeIn]);
    let binaryExprMap = /* @__PURE__ */ new Map();
    let castExprMap = /* @__PURE__ */ new Map();
    let methodCallMap = /* @__PURE__ */ new Map();
    availableExprs.forEach((expr) => {
      const sig = expr.getSignature();
      if (expr instanceof ExprContainer) {
        binaryExprMap.set(sig, expr.result);
      } else if (expr instanceof CastExprContainer) {
        castExprMap.set(sig, expr.result);
      } else if (expr instanceof methodCallContainer) {
        if (expr.result === null) {
          return;
        }
        methodCallMap.set(sig, expr.result);
      }
    });
    const newInstructions = [];
    for (let i2 = 0; i2 < block.instructions.length; i2++) {
      const instr = block.instructions[i2];
      if (instr instanceof CallInstruction) {
        if (!this.localMethodSet.has(instr.methodName)) {
          availableExprs = /* @__PURE__ */ new Set();
          binaryExprMap = /* @__PURE__ */ new Map();
          castExprMap = /* @__PURE__ */ new Map();
          methodCallMap = /* @__PURE__ */ new Map();
          newInstructions.push(instr);
          continue;
        }
        const callSignature = `${instr.methodName}(${instr.args.join(",")})`;
        if (methodCallMap.has(callSignature) && methodCallMap.get(callSignature) !== instr.returnVar) {
          const sourceVar = methodCallMap.get(callSignature);
          if (instr.returnVar) {
            newInstructions.push(
              new CopyInstruction(instr.returnVar, sourceVar)
            );
          }
          changesMade = true;
        } else {
          newInstructions.push(instr);
          if (instr.returnVar !== void 0) {
            const expr = new methodCallContainer(
              instr.methodName,
              instr.args,
              instr.returnVar
            );
            availableExprs.add(expr);
            methodCallMap.set(callSignature, instr.returnVar);
          }
        }
      } else if (instr instanceof BinOpInstruction) {
        const exprSignature = `${instr.expr1}${instr.binOp.toString()}${instr.expr2}`;
        if (binaryExprMap.has(exprSignature) && binaryExprMap.get(exprSignature) !== instr.dest) {
          const sourceVar = binaryExprMap.get(exprSignature);
          newInstructions.push(new CopyInstruction(instr.dest, sourceVar));
          changesMade = true;
        } else {
          newInstructions.push(instr);
          const expr = new ExprContainer(
            instr.expr1,
            instr.binOp,
            instr.expr2,
            instr.dest
          );
          availableExprs.add(expr);
          binaryExprMap.set(exprSignature, instr.dest);
        }
      } else if (instr instanceof CastInstruction) {
        const exprSignature = `cast(${instr.src},${instr.castType})`;
        if (castExprMap.has(exprSignature) && castExprMap.get(exprSignature) !== instr.dest) {
          const sourceVar = castExprMap.get(exprSignature);
          newInstructions.push(new CopyInstruction(instr.dest, sourceVar));
          changesMade = true;
        } else {
          newInstructions.push(instr);
          const expr = new CastExprContainer(
            instr.src,
            instr.castType,
            instr.dest
          );
          availableExprs.add(expr);
          castExprMap.set(exprSignature, instr.dest);
        }
      } else {
        newInstructions.push(instr);
      }
      const dest = instr.getDest();
      if (dest) {
        this.updateExpressionMapsForNewDefinition(
          dest,
          availableExprs,
          binaryExprMap,
          castExprMap
        );
      }
    }
    block.instructions = newInstructions;
    return changesMade;
  }
  /**
   * Helper method to update expression maps when a variable is redefined
   */
  updateExpressionMapsForNewDefinition(dest, availableExprs, binaryExprMap, castExprMap) {
    const updatedExprs = /* @__PURE__ */ new Set();
    const binaryToRemove = [];
    const castToRemove = [];
    availableExprs.forEach((expr) => {
      const sig = expr.getSignature();
      if (expr instanceof ExprContainer) {
        if (!expr.usesVar(dest)) {
          updatedExprs.add(expr);
        } else {
          binaryToRemove.push(sig);
        }
      } else if (expr instanceof CastExprContainer) {
        if (!expr.usesVar(dest)) {
          updatedExprs.add(expr);
        } else {
          castToRemove.push(sig);
        }
      }
    });
    availableExprs.clear();
    updatedExprs.forEach((expr) => availableExprs.add(expr));
    binaryToRemove.forEach((sig) => binaryExprMap.delete(sig));
    castToRemove.forEach((sig) => castExprMap.delete(sig));
  }
}
function populateCfgRelationships(entryBlock) {
  const blocks = getCfgTree(entryBlock);
  const blockMap = /* @__PURE__ */ new Map();
  for (const block of blocks) {
    blockMap.set(block.label, block);
  }
  for (const block of blocks) {
    block.successors = [];
    block.predecessors = [];
  }
  for (const block of blocks) {
    if (block.branchSuccessors) {
      addSuccessor(block, block.branchSuccessors.trueBlock);
      addSuccessor(block, block.branchSuccessors.falseBlock);
    }
    if (block.joinSuccessor) {
      addSuccessor(block, block.joinSuccessor);
    }
  }
  for (const block of blocks) {
    for (const predLabel of block.mutPredecessors) {
      const predBlock = blockMap.get(predLabel.toString());
      if (predBlock) {
        if (!block.predecessors.includes(predBlock)) {
          block.predecessors.push(predBlock);
        }
      }
    }
  }
  checkConsistency(blocks);
}
function getCfgTree(entryBlock) {
  const visited = /* @__PURE__ */ new Set();
  const blocks = [];
  function visit(block) {
    if (visited.has(block.label)) {
      return;
    }
    visited.add(block.label);
    blocks.push(block);
    if (block.branchSuccessors) {
      visit(block.branchSuccessors.trueBlock);
      visit(block.branchSuccessors.falseBlock);
    }
    if (block.joinSuccessor) {
      visit(block.joinSuccessor);
    }
  }
  visit(entryBlock);
  return blocks;
}
function addSuccessor(block, successor) {
  if (!block.successors.includes(successor)) {
    block.successors.push(successor);
  }
  if (!successor.predecessors.includes(block)) {
    successor.predecessors.push(block);
  }
}
function checkConsistency(blocks) {
  for (const block of blocks) {
    for (const successor of block.successors) {
      if (!successor.predecessors.includes(block)) {
        successor.predecessors.push(block);
      }
    }
    for (const predecessor of block.predecessors) {
      if (!predecessor.successors.includes(block)) {
        predecessor.successors.push(block);
      }
    }
  }
}
function computeDominatorTree(entry) {
  const blocks = getCfgTree(entry);
  for (const block of blocks) {
    block.domPredecessors = [];
    block.domSuccessors = [];
  }
  if (blocks.length === 1) {
    return entry;
  }
  const dominators = /* @__PURE__ */ new Map();
  dominators.set(entry, /* @__PURE__ */ new Set([entry]));
  for (const block of blocks) {
    if (block !== entry) {
      dominators.set(block, new Set(blocks));
    }
  }
  let changed = true;
  while (changed) {
    changed = false;
    for (const block of blocks) {
      if (block === entry) {
        continue;
      }
      if (block.predecessors.length === 0) {
        continue;
      }
      const firstPred = block.predecessors[0];
      if (!dominators.has(firstPred)) {
        continue;
      }
      const newDoms = /* @__PURE__ */ new Set();
      for (const dom of dominators.get(firstPred)) {
        newDoms.add(dom);
      }
      for (let i2 = 1; i2 < block.predecessors.length; i2++) {
        const pred = block.predecessors[i2];
        if (!dominators.has(pred)) {
          continue;
        }
        const predDoms = dominators.get(pred);
        for (const dom of newDoms) {
          if (!predDoms.has(dom)) {
            newDoms.delete(dom);
          }
        }
      }
      newDoms.add(block);
      const oldDoms = dominators.get(block);
      if (newDoms.size !== oldDoms.size) {
        dominators.set(block, newDoms);
        changed = true;
      } else {
        let different = false;
        for (const dom of newDoms) {
          if (!oldDoms.has(dom)) {
            different = true;
            break;
          }
        }
        if (different) {
          dominators.set(block, newDoms);
          changed = true;
        }
      }
    }
  }
  for (const block of blocks) {
    if (block === entry) continue;
    const blockDoms = dominators.get(block);
    if (!blockDoms || blockDoms.size <= 1) continue;
    const strictDoms = new Set(blockDoms);
    strictDoms.delete(block);
    let idom = null;
    for (const dom of strictDoms) {
      let isIdom = true;
      for (const otherDom of strictDoms) {
        if (dom === otherDom) {
          continue;
        }
        const otherDomDoms = dominators.get(otherDom);
        if (otherDomDoms && otherDomDoms.has(dom)) {
          isIdom = false;
          break;
        }
      }
      if (isIdom) {
        idom = dom;
        break;
      }
    }
    if (!idom) {
      for (const pred of block.predecessors) {
        if (strictDoms.has(pred)) {
          let isBetterIdom = true;
          for (const otherPred of block.predecessors) {
            if (pred === otherPred) {
              continue;
            }
            const otherPredDoms = dominators.get(otherPred);
            if (otherPredDoms && otherPredDoms.has(pred)) {
              isBetterIdom = false;
              break;
            }
          }
          if (isBetterIdom) {
            idom = pred;
            break;
          }
        }
      }
      if (!idom) {
        idom = entry;
      }
    }
    if (idom) {
      block.domPredecessors = [idom];
      if (!idom.domSuccessors.includes(block)) {
        idom.domSuccessors.push(block);
      }
    }
  }
  return entry;
}
function getAllDominators(entryBlock) {
  const blocks = collectAllBlocks(entryBlock);
  for (const block of blocks) {
    let curDom = block;
    while (curDom.domPredecessors.length !== 0) {
      curDom = curDom.domPredecessors[0];
      for (const succ of block.domSuccessors) {
        succ.allDomPredecessors.add(curDom);
      }
    }
  }
}
function logDominatorRelationships(entryBlock) {
  const blocks = getCfgTree(entryBlock);
  console.log("Dominator Tree Relationships");
  for (const block of blocks) {
    console.log(`Block: ${block.label}`);
    console.log(`  Immediate Dominator:`);
    if (block.domPredecessors.length > 0) {
      console.log(`    - ${block.domPredecessors[0].label}`);
    } else {
      console.log(`    - None (entry block or unreachable)`);
    }
    console.log(`  All Predecessor Dominators:`);
    for (const succ of block.allDomPredecessors) {
      console.log(`    - ${succ.label}`);
    }
    console.log(`  Dominates (${block.domSuccessors.length}):`);
    for (const succ of block.domSuccessors) {
      console.log(`    - ${succ.label}`);
    }
    console.log("");
  }
}
class LoopOptimizer {
  constructor(program) {
    this.program = program;
    this.dataflowUtils = new DataFlowUtils();
    this.loops = /* @__PURE__ */ new Map();
  }
  optimizeLoops(blocks) {
    this.detectLoopsForMethod(blocks[0]);
    for (const [header, loop] of this.loops.entries()) {
      const invariantInstrs = this.findLoopInvariantInstructions(header, loop);
      console.log("Invariant instructions");
      this.hoistInvariantInstructions(header, invariantInstrs, loop);
      console.log("Hoist");
    }
  }
  /**
   * Detects natural loops in a single method's CFG.
   * Populates this.loops with header -> loop nodes for this method.
   */
  detectLoopsForMethod(methodEntryBlock) {
    populateCfgRelationships(methodEntryBlock);
    methodEntryBlock = computeDominatorTree(methodEntryBlock);
    getAllDominators(methodEntryBlock);
    logDominatorRelationships(methodEntryBlock);
    const blocks = collectAllBlocks(methodEntryBlock);
    for (const block of blocks) {
      for (const domPred of block.allDomPredecessors) {
        if (block.successors?.includes(domPred)) {
          const loop = this.constructLoop(domPred, block);
          if (this.loops.has(domPred)) {
            const existing = this.loops.get(domPred);
            loop.forEach((node) => existing.add(node));
          } else {
            this.loops.set(domPred, loop);
          }
        }
      }
    }
  }
  /**
   * Constructs the loop set for a given back edge (n -> d).
   * @param header The loop header (d)
   * @param node The source of the back edge (n)
   */
  constructLoop(header, node) {
    const loop = /* @__PURE__ */ new Set();
    const stack = [];
    loop.add(header);
    if (header !== node) {
      loop.add(node);
      stack.push(node);
    }
    while (stack.length > 0) {
      const m2 = stack.pop();
      for (const pred of m2.predecessors) {
        if (!loop.has(pred)) {
          loop.add(pred);
          stack.push(pred);
        }
      }
    }
    return loop;
  }
  findLoopInvariantInstructions(header, loop) {
    const blocks = Array.from(loop);
    const inMap = this.dataflowUtils.computeReachingDefinitions(blocks);
    const exitBlocks = this.findLoopExitBlocks(loop);
    const allInstructions = [];
    for (const block of blocks.filter((block2) => block2 !== header)) {
      for (const instr of block.instructions) {
        if (!(instr instanceof LabelInstruction)) {
          allInstructions.push(instr);
        }
      }
    }
    const invariantSet = /* @__PURE__ */ new Set();
    const invariantOrdered = [];
    const allDefsAreNotInsideLoop = (variable) => {
      for (const block of blocks) {
        const defs = [...inMap.get(block)].filter((def) => def.dest === variable);
        for (const def of defs) {
          const parentBlock = blocks.find((b2) => b2.instructions.includes(def.exprSrc));
          if (parentBlock && loop.has(parentBlock)) {
            return false;
          }
        }
      }
      return true;
    };
    const allDefsFromInvariant = (variable) => {
      for (const block of blocks) {
        const defs = [...inMap.get(block)].filter((def) => def.dest === variable);
        for (const def of defs) {
          if (!invariantSet.has(def.exprSrc)) {
            return false;
          }
        }
      }
      return true;
    };
    const exactlyOneDefFromInvariant = (variable) => {
      let found = null;
      for (const block of blocks) {
        const defs = [...inMap.get(block)].filter((def) => def.dest === variable);
        for (const def of defs) {
          if (found !== null) return false;
          found = def.exprSrc;
        }
      }
      return found !== null && invariantSet.has(found);
    };
    for (const instr of allInstructions) {
      console.log("EVALUATED INSTRR", instr);
      console.log("Is Constant Instruction", instr.isConstant());
      console.log("Every source does not have reaching def inside", instr.getSrcs().every((op) => allDefsAreNotInsideLoop(op)));
      console.log("safe to hoist", this.isSafeToHoist(instr, loop, allInstructions, exitBlocks));
      if ((instr.isConstant() || instr.getSrcs().every((op) => allDefsAreNotInsideLoop(op))) && this.isSafeToHoist(instr, loop, allInstructions, exitBlocks)) {
        invariantSet.add(instr);
        invariantOrdered.push(instr);
      }
    }
    let changed = true;
    do {
      changed = false;
      for (const instr of allInstructions) {
        if (!invariantSet.has(instr)) {
          if ((instr.isConstant() || instr.getSrcs().every((op) => allDefsAreNotInsideLoop(op)) || instr.getSrcs().every((op) => exactlyOneDefFromInvariant(op)) || instr.getSrcs().every((op) => allDefsFromInvariant(op))) && this.isSafeToHoist(instr, loop, allInstructions, exitBlocks)) {
            invariantSet.add(instr);
            invariantOrdered.push(instr);
            changed = true;
          }
        }
      }
    } while (changed);
    console.log("Invariant Ordered", invariantOrdered);
    return invariantOrdered;
  }
  findLoopExitBlocks(loop) {
    const exits = [];
    for (const block of loop) {
      for (const succ of block.domSuccessors) {
        if (!loop.has(succ)) {
          exits.push(succ);
        }
      }
    }
    console.log("Loop exits", exits[0]);
    return exits;
  }
  hoistInvariantInstructions(header, invariantInstrs, loop) {
    if (invariantInstrs.length == 0) {
      return;
    }
    for (const instr of invariantInstrs) {
      const origBlock = Array.from(loop).find((b2) => b2.instructions.includes(instr));
      if (!origBlock) {
        throw new Error("Should not reach this point");
      }
      origBlock.instructions = origBlock.instructions.filter((i2) => i2 !== instr);
    }
    header.domPredecessors[0].instructions = [...invariantInstrs, ...header.domPredecessors[0].instructions];
  }
  isSafeToHoist(instr, loop, allInstructions, exitBlocks) {
    const dest = instr.getDest();
    if (!dest) return false;
    for (const other of allInstructions) {
      if (other !== instr && other.getDest && other.getDest() === dest) {
        console.log("Has other statement in loop that assigns to dest");
        return false;
      }
    }
    for (const block of loop) {
      for (const useInstr of block.instructions) {
        for (const src of useInstr.getSrcs()) {
          if (src === dest) {
            const defs = [...this.dataflowUtils.computeReachingDefinitions([block]).get(block)].filter((def) => def.dest === dest);
            if (defs.some((def) => def.exprSrc !== instr)) {
              console.log("Fails 2. No use of dest in loop is reached by a definition other than instr");
              return false;
            }
          }
        }
      }
    }
    return true;
  }
}
function computeSignedMagic(d2) {
  if (d2 === 0 || d2 === -1 || d2 === 1) {
    return { magic: null, shift: null, add: null };
  }
  const bits = 32;
  const two31 = 1n << 31n;
  const ad = BigInt(Math.abs(d2));
  const dSign = d2 >> 31;
  const t2 = two31 + BigInt(dSign);
  const anc = t2 - 1n - t2 % ad;
  let q1 = two31 / anc;
  let r1 = two31 - q1 * anc;
  let q2 = two31 / ad;
  let r2 = two31 - q2 * ad;
  let p2 = 31;
  let delta;
  do {
    p2++;
    q1 <<= 1n;
    r1 <<= 1n;
    if (r1 >= anc) {
      q1 += 1n;
      r1 -= anc;
    }
    q2 <<= 1n;
    r2 <<= 1n;
    if (r2 >= ad) {
      q2 += 1n;
      r2 -= ad;
    }
    delta = ad - r2;
  } while (q1 < delta || q1 === delta && r1 === 0n);
  let magic = q2 + 1n;
  const final_magic = toSigned32(Number(magic));
  const shift = p2 - bits;
  const add = d2 > 0 && final_magic < 0 ? 1 : 0;
  return {
    magic: final_magic,
    shift,
    add
  };
}
function toSigned32(n2) {
  return n2 << 0;
}
class Inliner {
  constructor(program) {
    this.program = program;
    this.usableMethods = /* @__PURE__ */ new Map();
    this.inlineCounter = 0;
    this.voidReturns = /* @__PURE__ */ new Set();
  }
  inlinesMethod(methodName) {
    return this.usableMethods.has(methodName);
  }
  addMethod(firstBlock, isVoidReturn) {
    if (isVoidReturn) {
      this.voidReturns.add(firstBlock.label);
    }
    if (this.couldFallOff(firstBlock, isVoidReturn, /* @__PURE__ */ new Set())) {
      return;
    }
    const firstInstr = firstBlock.instructions[0];
    this.removeSuccsAfterReturn(firstBlock, /* @__PURE__ */ new Set());
    if (!(firstInstr instanceof LabelInstruction)) {
      throw new Error("First instruction is not label instruction");
    }
    const methodName = firstInstr.label;
    this.usableMethods.set(
      methodName,
      this.recursiveDupBlock(firstBlock, /* @__PURE__ */ new Map())
    );
  }
  couldFallOff(block, isVoidReturn, visited) {
    if (isVoidReturn) {
      return false;
    }
    if (visited.has(block.label)) {
      return false;
    }
    visited.add(block.label);
    const succs = block.getSuccessors();
    if (succs.length === 0) {
      return !(block.instructions[block.instructions.length - 1] instanceof ReturnInstruction);
    }
    for (const succ of succs) {
      if (this.couldFallOff(succ, isVoidReturn, visited)) {
        return true;
      }
    }
    return false;
  }
  //we don't want to inline big functions, so we just count the number of instructions capped at the inline limit
  instrCounter(methodBlock, inlineCap, visited) {
    if (visited.has(methodBlock.label)) {
      return 0;
    }
    visited.add(methodBlock.label);
    let counter = 0;
    counter += methodBlock.instructions.length;
    for (const succ of methodBlock.getSuccessors()) {
      if (counter >= inlineCap) {
        return counter;
      }
      counter += this.instrCounter(succ, inlineCap - counter, visited);
    }
    return counter;
  }
  removeBlockSuccessors(deleteBlock) {
    deleteBlock.getSuccessors().forEach((succ) => {
      succ.popPredecessor(deleteBlock);
      if (succ.getPredecessors().length === 0) {
        this.removeBlockSuccessors(succ);
      }
    });
    deleteBlock.joinSuccessor = null;
    deleteBlock.branchSuccessors = null;
  }
  removeSuccsAfterReturn(block, visited) {
    if (visited.has(block.label)) {
      return;
    }
    const blockSuccs = block.getSuccessors();
    visited.add(block.label);
    const lastInstr = block.instructions[block.instructions.length - 1];
    if (lastInstr instanceof ReturnInstruction) {
      block.getSuccessors().forEach((succ) => {
        succ.popPredecessor(block);
        if (succ.getPredecessors().length === 0) {
          this.removeBlockSuccessors(succ);
        }
        block.joinSuccessor = null;
        block.branchSuccessors = null;
      });
    }
    blockSuccs.forEach((succ) => {
      this.removeSuccsAfterReturn(succ, visited);
    });
  }
  inlineAll(methodBlock, curMethodName) {
    const allCurBlocks = this.getAllBlocks(methodBlock, /* @__PURE__ */ new Set());
    for (const block of allCurBlocks) {
      this.inlineBlock(block, curMethodName);
    }
    const inlineCap = 40;
    this.fixProblems(methodBlock, /* @__PURE__ */ new Set());
    const instrCount = this.instrCounter(methodBlock, inlineCap, /* @__PURE__ */ new Set());
    if (instrCount >= inlineCap) {
      this.usableMethods.delete(curMethodName);
    }
  }
  fixProblems(curBlock, visited) {
    if (visited.has(curBlock.label)) {
      return;
    }
    visited.add(curBlock.label);
    curBlock.mutPredecessors.clear();
    curBlock.mutPredecessorBlocks.forEach((block) => {
      curBlock.mutPredecessors.add(block.label);
    });
    curBlock.getSuccessors().forEach((succ) => {
      this.fixProblems(succ, visited);
    });
  }
  getAllBlocks(block, visited) {
    if (visited.has(block.label)) {
      return [];
    }
    visited.add(block.label);
    const blocks = [block];
    block.getSuccessors().forEach((succ) => {
      blocks.push(...this.getAllBlocks(succ, visited));
    });
    return blocks;
  }
  inlineBlock(curBlock, curMethodName) {
    let changed = true;
    while (changed) {
      changed = false;
      curBlock.instructions.forEach((instr, instrIndex) => {
        if (changed) {
          return;
        }
        if (!(instr instanceof CallInstruction)) {
          return;
        }
        if (instr.methodName === curMethodName) {
          this.usableMethods.delete(instr.methodName);
          return;
        }
        if (!this.usableMethods.has(instr.methodName)) {
          return;
        }
        const followingInstrs = curBlock.instructions.slice(instrIndex + 1);
        const followerBlock = new BasicBlock(
          `follower_${this.inlineCounter++}`,
          curBlock.curScope,
          curBlock.parentScope,
          followingInstrs
        );
        followerBlock.joinSuccessor = curBlock.joinSuccessor;
        followerBlock.branchSuccessors = curBlock.branchSuccessors;
        followerBlock.getSuccessors().forEach((succ) => {
          this.updateBlockDependencies(curBlock, followerBlock, succ);
        });
        const inlineBlock = this.createNewInlineBlock(
          instr.methodName,
          instr.args
          // inline functions don't have str literals as args
        );
        const returnVar = instr.returnVar === void 0 ? null : instr.returnVar;
        this.addJoinSuccesor(curBlock, inlineBlock);
        this.addBlockToEndPoints(
          inlineBlock,
          followerBlock,
          returnVar,
          instr.methodName,
          /* @__PURE__ */ new Set()
        );
        curBlock.instructions = curBlock.instructions.slice(0, instrIndex);
        changed = true;
        curBlock.branchSuccessors = null;
        curBlock = followerBlock;
      });
    }
  }
  addBlockToEndPoints(block, newTerm, returnVar, methodName, visited) {
    if (visited.has(block.label)) {
      return;
    }
    const isVoidReturn = this.voidReturns.has(methodName);
    visited.add(block.label);
    block.getSuccessors().forEach((succ) => {
      this.addBlockToEndPoints(succ, newTerm, returnVar, methodName, visited);
    });
    const lastInstr = block.instructions[block.instructions.length - 1];
    if (block.getSuccessors().length === 0 && (isVoidReturn || lastInstr instanceof ReturnInstruction)) {
      this.addJoinSuccesor(block, newTerm);
    }
    if (lastInstr instanceof ReturnInstruction) {
      block.instructions.pop();
      if (returnVar !== null && lastInstr.src !== null) {
        block.instructions.push(new CopyInstruction(returnVar, lastInstr.src));
      }
    }
  }
  createNewInlineBlock(methodName, params) {
    if (!this.usableMethods.has(methodName)) {
      throw new Error("trying to duplicate cfg that doesn't exist");
    }
    const firstBlock = this.usableMethods.get(methodName);
    const dupBlock = this.recursiveDupBlock(firstBlock, /* @__PURE__ */ new Map());
    dupBlock.mutPredecessorBlocks = [];
    dupBlock.mutPredecessors.clear();
    this.prefixBlockVariables(
      dupBlock,
      `${this.inlineCounter}_${methodName}`,
      /* @__PURE__ */ new Set()
    );
    let startIdx = 0;
    let curInstr = dupBlock.instructions[startIdx];
    while (curInstr instanceof LabelInstruction || curInstr instanceof CreateArrayInstruction || curInstr instanceof CreateVarInstruction) {
      startIdx++;
      curInstr = dupBlock.instructions[startIdx];
    }
    for (let i2 = 0; i2 < params.length; i2++) {
      const curInstr2 = dupBlock.instructions[i2 + startIdx];
      if (curInstr2 instanceof LabelInstruction || curInstr2 instanceof CreateArrayInstruction || curInstr2 instanceof CreateVarInstruction) {
        continue;
      }
      if (!(curInstr2 instanceof CopyInstruction)) {
        throw new Error("instruction should be copying function params");
      }
      dupBlock.instructions[i2 + startIdx] = new CopyInstruction(
        curInstr2.dest,
        params[i2]
      );
    }
    this.recusivelyModifyLabels(dupBlock, /* @__PURE__ */ new Set());
    return dupBlock;
  }
  prefixBlockVariables(block, methodName, visited) {
    if (visited.has(block.label)) {
      return;
    }
    visited.add(block.label);
    block.instructions.forEach((instr) => {
      instr.addMethodNameToVarName(methodName, this.program);
    });
    if (block.branchSuccessors !== null && !this.program.isGlobalVariable(block.branchSuccessors.conditionVar)) {
      block.branchSuccessors.conditionVar = methodName + "_" + block.branchSuccessors.conditionVar;
    }
    block.getSuccessors().forEach((succ) => {
      this.prefixBlockVariables(succ, methodName, visited);
    });
  }
  recusivelyModifyLabels(curBlock, blocksModified) {
    if (blocksModified.has(curBlock.label)) {
      return;
    }
    curBlock.label = `${curBlock.label}_${this.inlineCounter}`;
    const labelInstr = curBlock.instructions[0];
    if (!(labelInstr instanceof LabelInstruction)) {
      throw new Error("First instruction is not label instruction");
    }
    labelInstr.label = curBlock.label;
    blocksModified.add(curBlock.label);
    curBlock.getSuccessors().forEach((succ) => {
      this.recusivelyModifyLabels(succ, blocksModified);
    });
    curBlock.mutPredecessors = new Set(
      curBlock.mutPredecessorBlocks.map((block) => block.label)
    );
  }
  recursiveDupBlock(curBlock, dupMap) {
    if (dupMap.has(curBlock.label)) {
      return dupMap.get(curBlock.label);
    }
    const dupBlock = curBlock.duplicate();
    dupMap.set(dupBlock.label, dupBlock);
    dupBlock.getSuccessors().forEach((succ) => {
      const dupSuc = this.recursiveDupBlock(succ, dupMap);
      this.updateBlockDependencies(curBlock, dupBlock, dupSuc);
    });
    return dupBlock;
  }
  updateBlockDependencies(oldBlock, newBlock, dependencyBlock) {
    if (oldBlock === newBlock) {
      throw new Error("oldBlock and newBlock are the same");
    }
    dependencyBlock.mutPredecessorBlocks = dependencyBlock.mutPredecessorBlocks.map((block) => {
      if (block.label === oldBlock.label) {
        dependencyBlock.mutPredecessors.delete(block.label);
        dependencyBlock.mutPredecessors.add(newBlock.label);
        dependencyBlock.mutPredecessorBlocks = dependencyBlock.mutPredecessorBlocks.map((block2) => {
          if (block2.label === oldBlock.label) {
            return newBlock;
          }
          return block2;
        });
        dependencyBlock.mutPredecessorBlocks.push(newBlock);
        return newBlock;
      }
      return block;
    });
    if (newBlock.branchSuccessors) {
      const branches = newBlock.branchSuccessors;
      if (branches.trueBlock.label === dependencyBlock.label) {
        branches.trueBlock = dependencyBlock;
        return;
      }
      if (branches.falseBlock.label === dependencyBlock.label) {
        branches.falseBlock = dependencyBlock;
        return;
      }
      throw new Error("dependency block is not a branch successor");
    }
    if (newBlock.joinSuccessor) {
      newBlock.joinSuccessor = dependencyBlock;
    }
  }
  addJoinSuccesor(block, succ) {
    block.joinSuccessor = succ;
    succ.mutPredecessorBlocks.push(block);
    succ.mutPredecessors.add(block.label);
  }
}
class Optimizer {
  constructor(program, methods) {
    this.program = program;
    this.nodes = /* @__PURE__ */ new Map();
    this.flags = {
      constantPropagation: false,
      deadCodeElimination: false,
      algebraicSimplification: false,
      commonSubexprElimination: false,
      // Initialize CSE flag
      constantFolding: false,
      loopOptimization: false,
      inline: false
    };
    this.methodMap = /* @__PURE__ */ new Map();
    this.localMethodSet = /* @__PURE__ */ new Set();
    this.dceOptimizer = new DceOptimizer(this.program, this.localMethodSet);
    this.cpOptimizer = new CpOptimizer(this.program);
    this.cseOptimizer = new CseOptimizer(this.program, this.localMethodSet);
    this.loopOptimizer = new LoopOptimizer(this.program);
    this.inliner = new Inliner(this.program);
    methods.forEach((method) => {
      this.methodMap.set(method.method_name, method);
    });
  }
  setOptimizationFlags(flags) {
    this.flags = flags;
  }
  buildNodes() {
    const blocks = this.program.buildCFG();
    const fakeBlock = new BasicBlock("fakeBlock", -1, -1, []);
    blocks.forEach((block, index) => {
      this.program.addPredecessor(block, fakeBlock);
      const blockName = this.program.orderedMethods[index];
      this.nodes.set(blockName, this.buildMethodNodes(block));
      this.addHeaderCopies(block, blockName);
    });
    this.optimize();
    blocks.forEach((block) => {
      block.popPredecessor(fakeBlock);
    });
    return blocks;
  }
  //some optimizations like cp need to know that method parameters
  // are assigned, so we add copy instructions from var to var to solve this
  addHeaderCopies(block, methodName) {
    const methodInfo = this.methodMap.get(methodName);
    if (methodInfo === void 0) {
      throw new Error(`Method ${methodName} not found`);
    }
    const prependinstrs = methodInfo.params.ordered_params.map(
      (param) => {
        const paramName = param[0];
        return new CopyInstruction(paramName, paramName);
      }
    );
    const labelInstr = block.instructions.shift();
    block.instructions = [labelInstr, ...prependinstrs].concat(
      block.instructions
    );
  }
  buildMethodNodes(method) {
    const nodes = [method];
    const finalBlock = this.getFinalBlock(method);
    const visited = /* @__PURE__ */ new Set([method.label, finalBlock.label]);
    const queue = [method];
    while (queue.length > 0) {
      const currentBlock = queue.pop();
      currentBlock.getSuccessors().forEach((successor) => {
        if (!visited.has(successor.label)) {
          visited.add(successor.label);
          queue.push(successor);
          nodes.push(successor);
        }
      });
    }
    if (method.label !== finalBlock.label) {
      nodes.push(finalBlock);
    }
    return nodes;
  }
  getFinalBlock(method) {
    let curBlock = method;
    while (curBlock.getSuccessors().length > 0) {
      const successors = curBlock.getSuccessors();
      curBlock = successors[successors.length - 1];
    }
    return curBlock;
  }
  optimize() {
    for (let [methodName, blocks] of this.nodes.entries()) {
      const maxPasses = 4;
      let changed = true;
      let passCount = 0;
      const firstBlock = blocks[0];
      if (this.flags.inline) {
        this.inliner.addMethod(
          firstBlock,
          this.methodMap.get(methodName).returnType instanceof VoidType
        );
        this.inliner.inlineAll(firstBlock, methodName);
      }
      blocks = this.buildMethodNodes(firstBlock);
      while (changed && passCount < maxPasses) {
        passCount++;
        changed = false;
        if (this.flags.commonSubexprElimination) {
          const cseChanged = this.cseOptimizer.eliminateCommonSubexpressions(blocks);
          changed = changed || cseChanged;
        }
        if (this.flags.constantPropagation) {
          this.cpOptimizer.propagateConstants(blocks, methodName);
          changed = true;
        }
        if (this.flags.deadCodeElimination) {
          this.dceOptimizer.eliminateDeadCode(blocks, methodName);
          changed = true;
        }
        if (this.flags.algebraicSimplification) {
          const simplifyChanged = this.simplifyExpressions(blocks);
          changed = changed || simplifyChanged;
        }
        if (this.flags.constantFolding) {
          const foldingChanged = this.constantFolding(blocks);
          changed = changed || foldingChanged;
        }
      }
      if (this.flags.algebraicSimplification) {
        const simplifyChanged = this.mutateExpressions(blocks);
        changed = changed || simplifyChanged;
      }
    }
  }
  simplifyExpressions(blocks) {
    let changed = false;
    blocks.forEach((block) => {
      const originalInstructions = [...block.instructions];
      const newInstructions = [];
      block.instructions.forEach((instr) => {
        if (instr instanceof BinOpInstruction) {
          const simplified = this.simpleSimplifyBinExpr(instr);
          simplified.weight = instr.weight;
          if (simplified !== instr) {
            changed = true;
            newInstructions.push(simplified);
            return simplified;
          }
        }
        if (instr instanceof CastInstruction) {
          const simplified = this.simpleSimplifyCastInstr(instr);
          simplified.weight = instr.weight;
          if (simplified !== instr) {
            changed = true;
            newInstructions.push(simplified);
            return simplified;
          }
        }
        newInstructions.push(instr);
        return instr;
      });
      block.instructions = newInstructions;
      if (block.instructions.length !== originalInstructions.length) {
        changed = true;
      } else {
        for (let i2 = 0; i2 < block.instructions.length; i2++) {
          if (block.instructions[i2] !== originalInstructions[i2]) {
            changed = true;
            break;
          }
        }
      }
    });
    return changed;
  }
  mutateExpressions(blocks) {
    let changed = false;
    blocks.forEach((block) => {
      const newInstructions = [];
      block.instructions.forEach((instr) => {
        if (instr instanceof BinOpInstruction) {
          const simplified = this.simplifyBinExpr(instr);
          simplified.forEach((simpInstr) => {
            if (simpInstr !== instr) {
              simpInstr.weight = instr.weight;
              changed = true;
              newInstructions.push(simpInstr);
            } else {
              newInstructions.push(instr);
            }
          });
          return;
        }
        newInstructions.push(instr);
      });
      block.instructions = newInstructions;
    });
    return changed;
  }
  castLongToInt(numStr) {
    const usedStr = numStr.slice(0, -1);
    let longVal = BigInt(usedStr);
    let int32 = Number(longVal & BigInt(4294967295));
    if (int32 >= 2147483648) {
      int32 = int32 - 4294967296;
    }
    return int32.toString();
  }
  simpleSimplifyCastInstr(instr) {
    const src = instr.src;
    const numParse = safeExtractNum(src);
    if (numParse === null) {
      return instr;
    }
    if (instr.castType === literalType.long) {
      const rawNum = numParse.endsWith("L") ? numParse.slice(0, -1) : numParse;
      return new LoadConstantInstruction(
        instr.dest,
        `${rawNum}`,
        literalType.long
      );
    }
    if (!numParse.endsWith("L")) {
      return new LoadConstantInstruction(instr.dest, numParse, literalType.int);
    }
    return new LoadConstantInstruction(
      instr.dest,
      this.castLongToInt(numParse),
      literalType.int
    );
  }
  simpleSimplifyBinExpr(instr) {
    let instrUsed = instr;
    switch (instr.binOp.toString()) {
      case "+":
        if (instr.expr1 === "0" || instr.expr1 === "0L") {
          instrUsed = new CopyInstruction(instr.dest, instr.expr2);
          break;
        }
        if (instr.expr2 === "0" || instr.expr2 === "0L") {
          instrUsed = new CopyInstruction(instr.dest, instr.expr1);
          break;
        }
        break;
      case "-":
        if (instr.expr2 === "0" || instr.expr2 === "0L") {
          instrUsed = new CopyInstruction(instr.dest, instr.expr1);
          break;
        }
        break;
      case "*":
        instrUsed = this.simpleSimplifyMul(instr);
        break;
      case "/":
        instrUsed = this.simpleSimplifyDiv(instr);
        break;
      case "%":
        instrUsed = this.simpleSimplifyMod(instr);
        break;
    }
    instrUsed.weight = instr.weight;
    return instr;
  }
  simplifyBinExpr(instr) {
    let instrUsed = [instr];
    switch (instr.binOp.toString()) {
      case "+":
        if (instr.expr1 === "0" || instr.expr1 === "0L") {
          instrUsed = [new CopyInstruction(instr.dest, instr.expr2)];
          break;
        }
        if (instr.expr2 === "0" || instr.expr2 === "0L") {
          instrUsed = [new CopyInstruction(instr.dest, instr.expr1)];
          break;
        }
        break;
      case "-":
        if (instr.expr2 === "0" || instr.expr2 === "0L") {
          instrUsed = [new CopyInstruction(instr.dest, instr.expr1)];
          break;
        }
        break;
      case "*":
        instrUsed = [this.simplifyMul(instr)];
        break;
      case "/":
        instrUsed = this.simplifyDiv(instr);
        break;
      case "%":
        instrUsed = this.simplifyMod(instr);
        break;
    }
    instrUsed.forEach((i2) => i2.weight = instr.weight);
    return instrUsed;
  }
  simpleSimplifyMul(instr) {
    if (instr.binOp.toString() !== "*") {
      throw new Error("something happened! Calling simplify mul on non mul op");
    }
    if (instr.expr1 === "0" || instr.expr2 === "0") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.int);
    }
    if (instr.expr1 === "0L" || instr.expr2 === "0L") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.long);
    }
    if (instr.expr1 === "1" || instr.expr1 === "1L") {
      return new CopyInstruction(instr.dest, instr.expr2);
    }
    if (instr.expr2 === "1" || instr.expr2 === "1L") {
      return new CopyInstruction(instr.dest, instr.expr1);
    }
    if (instr.expr1 === "-1") {
      return new BinOpInstruction("0", new MinusOp(), instr.expr2, instr.dest);
    }
    if (instr.expr1 === "-1L") {
      return new BinOpInstruction("0L", new MinusOp(), instr.expr2, instr.dest);
    }
    if (instr.expr2 === "-1") {
      return new BinOpInstruction("0", new MinusOp(), instr.expr1, instr.dest);
    }
    if (instr.expr2 === "-1L") {
      return new BinOpInstruction("0L", new MinusOp(), instr.expr1, instr.dest);
    }
    return instr;
  }
  simplifyMul(instr) {
    if (instr.binOp.toString() !== "*") {
      throw new Error("something happened! Calling simplify mul on non mul op");
    }
    if (instr.expr1 === "0" || instr.expr2 === "0") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.int);
    }
    if (instr.expr1 === "0L" || instr.expr2 === "0L") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.long);
    }
    if (instr.expr1 === "1" || instr.expr1 === "1L") {
      return new CopyInstruction(instr.dest, instr.expr2);
    }
    if (instr.expr2 === "1" || instr.expr2 === "1L") {
      return new CopyInstruction(instr.dest, instr.expr1);
    }
    if (instr.expr1 === "-1") {
      return new BinOpInstruction("0", new MinusOp(), instr.expr2, instr.dest);
    }
    if (instr.expr1 === "-1L") {
      return new BinOpInstruction("0L", new MinusOp(), instr.expr2, instr.dest);
    }
    if (instr.expr2 === "-1") {
      return new BinOpInstruction("0", new MinusOp(), instr.expr1, instr.dest);
    }
    if (instr.expr2 === "-1L") {
      return new BinOpInstruction("0L", new MinusOp(), instr.expr1, instr.dest);
    }
    const pow2First = getPowOf2(instr.expr1);
    const negPow2First = getNegPowOf2(instr.expr1);
    const pow2Second = getPowOf2(instr.expr2);
    const negPow2Second = getNegPowOf2(instr.expr2);
    if (pow2First !== null) {
      return new LeftShiftInstruction(
        instr.dest,
        instr.expr2,
        pow2First,
        false
      );
    }
    if (pow2Second !== null) {
      return new LeftShiftInstruction(
        instr.dest,
        instr.expr1,
        pow2Second,
        false
      );
    }
    if (negPow2First) {
      return new LeftShiftInstruction(
        instr.dest,
        instr.expr2,
        negPow2First,
        true
      );
    }
    if (negPow2Second) {
      return new LeftShiftInstruction(
        instr.dest,
        instr.expr1,
        negPow2Second,
        true
      );
    }
    return instr;
  }
  simpleSimplifyDiv(instr) {
    if (instr.binOp.toString() !== "/") {
      throw new Error("something happened! Calling simplify div on non div op");
    }
    if (instr.expr2 === "1" || instr.expr2 === "1L") {
      return new CopyInstruction(instr.dest, instr.expr1);
    }
    if (instr.expr1 === "0") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.int);
    }
    if (instr.expr1 === "0L") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.long);
    }
    return instr;
  }
  simplifyDiv(instr) {
    if (instr.binOp.toString() !== "/") {
      throw new Error("something happened! Calling simplify div on non div op");
    }
    if (instr.expr2 === "1" || instr.expr2 === "1L") {
      return [new CopyInstruction(instr.dest, instr.expr1)];
    }
    if (instr.expr1 === "0") {
      return [new LoadConstantInstruction(instr.dest, "0", literalType.int)];
    }
    if (instr.expr1 === "0L") {
      return [new LoadConstantInstruction(instr.dest, "0", literalType.long)];
    }
    if (instr.expr2 === "-1") {
      return [
        new BinOpInstruction("0", new MinusOp(), instr.expr1, instr.dest)
      ];
    }
    if (instr.expr2 === "-1") {
      return [
        new BinOpInstruction("0L", new MinusOp(), instr.expr1, instr.dest)
      ];
    }
    const pow2Second = getPowOf2(instr.expr2);
    const negPow2Second = getNegPowOf2(instr.expr2);
    if (pow2Second !== null) {
      return [
        new RightShiftInstruction(instr.dest, instr.expr1, pow2Second, false)
      ];
    }
    if (negPow2Second) {
      return [
        new RightShiftInstruction(instr.dest, instr.expr1, negPow2Second, true)
      ];
    }
    const number = safeExtractNum(instr.expr2);
    if (number === null || number.endsWith("L")) {
      return [instr];
    }
    const divNum = Number(number);
    const posNum = divNum >= 0 ? divNum : -divNum;
    const readRes = computeSignedMagic(posNum);
    if (readRes.magic === null || readRes.shift === null || readRes.add === null) {
      return [instr];
    }
    const instrs = [
      new MagicDivideInstruction(
        instr.dest,
        instr.expr1,
        readRes.magic,
        readRes.shift,
        readRes.add
      )
    ];
    if (divNum < 0) {
      instrs.push(
        new BinOpInstruction("0", new MinusOp(), instr.dest, instr.dest)
      );
    }
    return instrs;
  }
  simpleSimplifyMod(instr) {
    if (instr.binOp.toString() !== "%") {
      throw new Error("something happened! Calling simplify div on non div op");
    }
    if (instr.expr2 === "1" || instr.expr2 === "-1") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.int);
    }
    if (instr.expr2 === "1L" || instr.expr2 === "-1L") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.long);
    }
    if (instr.expr1 === "0") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.int);
    }
    if (instr.expr1 === "0L") {
      return new LoadConstantInstruction(instr.dest, "0", literalType.long);
    }
    return instr;
  }
  simplifyMod(instr) {
    if (instr.binOp.toString() !== "%") {
      throw new Error("something happened! Calling simplify div on non div op");
    }
    if (instr.expr2 === "1" || instr.expr2 === "-1") {
      return [new LoadConstantInstruction(instr.dest, "0", literalType.int)];
    }
    if (instr.expr2 === "1L" || instr.expr2 === "-1L") {
      return [new LoadConstantInstruction(instr.dest, "0", literalType.long)];
    }
    if (instr.expr1 === "0") {
      return [new LoadConstantInstruction(instr.dest, "0", literalType.int)];
    }
    if (instr.expr1 === "0L") {
      return [new LoadConstantInstruction(instr.dest, "0", literalType.long)];
    }
    const pow2Second = getPowOf2(instr.expr2);
    const negPow2Second = getNegPowOf2(instr.expr2);
    if (pow2Second !== null) {
      return [new AndModInstruction(instr.dest, instr.expr1, instr.expr2)];
    }
    if (negPow2Second) {
      return [
        new AndModInstruction(instr.dest, instr.expr1, instr.expr2.slice(1))
      ];
    }
    let number = safeExtractNum(instr.expr2);
    if (number === null || number.endsWith("L")) {
      return [instr];
    }
    number = number.startsWith("-") ? number.slice(1) : number;
    const divNum = Number(number);
    const readRes = computeSignedMagic(divNum);
    if (readRes.magic === null || readRes.shift === null || readRes.add === null) {
      return [instr];
    }
    const magicDiv = new MagicDivideInstruction(
      instr.dest,
      instr.expr1,
      readRes.magic,
      readRes.shift,
      readRes.add
    );
    const restoreDiv = new BinOpInstruction(
      instr.dest,
      new MultiplyOp(),
      instr.expr2,
      instr.dest
    );
    const subtractFloor = new BinOpInstruction(
      instr.expr1,
      new MinusOp(),
      instr.dest,
      instr.dest
    );
    return [magicDiv, restoreDiv, subtractFloor];
  }
  constantFolding(blocks) {
    let changed = false;
    blocks.forEach((block) => {
      const originalInstructions = [...block.instructions];
      block.instructions = block.instructions.map((instr) => {
        const folded = foldInstr(instr);
        if (folded !== instr) {
          changed = true;
          return folded;
        }
        return instr;
      });
      if (block.instructions.length !== originalInstructions.length) {
        changed = true;
      } else {
        for (let i2 = 0; i2 < block.instructions.length; i2++) {
          if (block.instructions[i2] !== originalInstructions[i2]) {
            changed = true;
            break;
          }
        }
      }
    });
    return changed;
  }
}
class Web {
  constructor(varName, entries) {
    this.varName = varName;
    this.liveRange = /* @__PURE__ */ new Set();
    this.entry = /* @__PURE__ */ new Set();
    this.rangeBuff = /* @__PURE__ */ new Set();
    this.potRange = /* @__PURE__ */ new Set();
    entries.forEach((instr) => {
      this.entry.add(instr);
    });
  }
  clearPotRange() {
    this.potRange.clear();
  }
  isLoopingLabel(instr) {
    if (instr instanceof LabelInstruction) {
      const labelName = instr.label;
      return labelName.startsWith("for") || labelName.startsWith("while");
    }
    return false;
  }
  isLastUse(curInstr) {
    const range = [...this.liveRange];
    return range[range.length - 1] === curInstr;
  }
  interferesWith(web) {
    const potOveralp1 = strictSetIntersection(this.potRange, web.liveRange);
    const potOveralp2 = strictSetIntersection(web.potRange, this.liveRange);
    const potOveralp3 = strictSetIntersection(this.entry, web.entry);
    if (this.varName === web.varName && potOveralp1.size > 0) {
      this.completePotFlush();
    }
    if (this.varName === web.varName && potOveralp2.size > 0) {
      web.completePotFlush();
    }
    const overlapSet = strictSetIntersection(this.liveRange, web.liveRange);
    if (overlapSet.size > 0) {
      return true;
    }
    if (potOveralp3.size > 0) {
      return true;
    }
    if (potOveralp1.size > 0 && this.varName !== web.varName) {
      let interferes = false;
      potOveralp1.forEach((instr) => {
        if (this.isLoopingLabel(instr)) {
          interferes = true;
        }
      });
      if (interferes) {
        return true;
      }
    }
    if (potOveralp2.size > 0 && this.varName !== web.varName) {
      let interferes = false;
      potOveralp2.forEach((instr) => {
        if (this.isLoopingLabel(instr)) {
          interferes = true;
        }
      });
      if (interferes) {
        return true;
      }
    }
    return false;
  }
  union(web) {
    if (this.varName !== web.varName || !this.interferesWith(web)) {
      return false;
    }
    this.entry = strictSetUnion(this.entry, web.entry);
    this.liveRange = strictSetUnion(this.liveRange, web.liveRange);
    this.potRange = strictSetUnion(this.potRange, web.potRange);
    this.entry = strictSetUnion(this.entry, web.entry);
    return true;
  }
  add(newInstr) {
    this.rangeBuff.add(newInstr);
    const uses = new Set(newInstr.getSrcs().map((src) => getSplitName(src)));
    const dest = newInstr.getDest();
    if (dest !== null) {
      const splitDest = getSplitName(dest);
      if (splitDest !== dest) {
        uses.add(splitDest);
      }
    }
    if (uses.has(this.varName)) {
      this.flush();
    }
    if (dest === this.varName) {
      const newWeb = new Web(this.varName, [newInstr]);
      return newWeb;
    }
    return null;
  }
  flush() {
    this.liveRange = strictSetUnion(this.liveRange, this.rangeBuff);
    this.clear();
  }
  //moves range buff to potRange set as we don't know if these instructions will be part of the live range
  //or not
  potentialFlush() {
    this.potRange = strictSetUnion(this.potRange, this.rangeBuff);
    this.clear();
  }
  completePotFlush() {
    this.liveRange = strictSetUnion(this.liveRange, this.potRange);
    this.clear();
  }
  clear() {
    this.rangeBuff.clear();
  }
  duplicate() {
    const dupWeb = new Web(this.varName, [...this.entry]);
    dupWeb.liveRange = new Set(this.liveRange);
    dupWeb.entry = new Set(this.entry);
    dupWeb.rangeBuff = new Set(this.rangeBuff);
    return dupWeb;
  }
}
class InterferenceGraph {
  constructor(webMap) {
    this.nodes = [];
    this.regesKilled = /* @__PURE__ */ new Set();
    webMap.forEach((webs) => {
      webs.forEach((web) => this.nodes.push(new InterferenceNode(web)));
    });
    this.populateInterference();
    this.colorGraph();
    this.addRegesToInstructions();
    this.setRegesKilled();
  }
  setRegesKilled() {
    this.nodes.forEach((node) => {
      this.regesKilled = setUnion(this.regesKilled, node.getRegesKilled());
    });
  }
  populateInterference() {
    this.nodes.forEach((node) => {
      this.nodes.forEach((otherNode) => {
        if (node === otherNode) {
          return;
        }
        node.addInterference(otherNode);
      });
    });
  }
  addRegesToInstructions() {
    this.nodes.forEach((node) => {
      if (node.register === null) {
        return;
      }
      node.nodeWeb.entry.forEach((instr) => {
        instr.setReg(node.register);
      });
    });
  }
  colorGraph() {
    const mutNodes = this.nodes.filter((node) => !node.isAlwaysColorable()).map((node) => node);
    mutNodes.sort((a2, b2) => {
      return a2.interferences.size - b2.interferences.size;
    });
    while (true) {
      let colored = true;
      mutNodes.forEach((node) => {
        if (!colored) {
          return;
        }
        colored = colored && node.colorLargeInterference();
      });
      if (colored) {
        break;
      }
      this.undoColoring();
      this.removeNode(mutNodes);
    }
    this.nodes.forEach((node) => {
      node.color();
    });
  }
  undoColoring() {
    this.nodes.forEach((node) => {
      node.undoColor();
    });
  }
  removeNode(mutNodes) {
    const stackNode = mutNodes.pop();
    if (stackNode === void 0) {
      throw new Error("stack is empty");
    }
    this.nodes.forEach((node) => {
      node.removeDependencyNode(stackNode);
    });
    stackNode.disable();
  }
  getInterferenceNodes() {
    return this.nodes;
  }
}
class InterferenceNode {
  constructor(nodeWeb) {
    this.nodeWeb = nodeWeb;
    this.interferences = /* @__PURE__ */ new Set();
    this.availableRegs = getLongRegs();
    this.ogAvailableRegs = new Set(this.availableRegs);
    this.register = null;
    this.weight = 1;
    this.enabled = true;
    for (const instr of nodeWeb.liveRange) {
      const uses = new Set(instr.getSrcs());
      if (uses.has(this.nodeWeb.varName)) {
        this.weight += instr.weight;
      }
    }
  }
  getRegesKilled() {
    return setDifference(this.ogAvailableRegs, this.availableRegs);
  }
  isAlwaysColorable() {
    return this.availableRegs.size > this.interferences.size;
  }
  disable() {
    this.enabled = false;
  }
  addInterference(otherNode) {
    const nodeWeb = this.nodeWeb;
    const otherNodeWeb = otherNode.nodeWeb;
    if (nodeWeb.varName === otherNodeWeb.varName) {
      return;
    }
    if (nodeWeb.interferesWith(otherNodeWeb)) {
      this.interferences.add(otherNode);
      otherNode.interferences.add(this);
    }
  }
  color() {
    if (!this.enabled) {
      return;
    }
    if (this.register === null && this.nodeWeb.liveRange.size === 0) {
      this.register = ReservedLongReg.r11;
    }
    if (this.register === null) {
      this.register = this.orderedPopAvailableRegs();
      this.removeDependencyReg(this.register);
    }
  }
  orderedPopAvailableRegs() {
    if (this.availableRegs.size === 0) {
      throw new Error("Set is empty");
    }
    const orderedReges = [
      // ...getLongCalleeSavedRegs(), // try to assign callee saved first so we can do group compiling trick better
      LongCallerSavedReg.rdi,
      LongCallerSavedReg.rsi,
      LongCallerSavedReg.rcx,
      LongCallerSavedReg.r8,
      LongCallerSavedReg.r9
    ];
    const regesUsed = new Set(orderedReges);
    getLongRegs().forEach((reg) => {
      if (regesUsed.has(reg)) {
        return;
      }
      orderedReges.push(reg);
      regesUsed.add(reg);
    });
    for (const reg of orderedReges) {
      if (this.availableRegs.has(reg)) {
        this.availableRegs.delete(reg);
        return reg;
      }
    }
    throw new Error("Set is empty");
  }
  colorLargeInterference() {
    if (!this.enabled) {
      return false;
    }
    if (this.register === null && this.nodeWeb.liveRange.size === 0) {
      this.register = ReservedLongReg.r11;
      return true;
    }
    if (this.interferences.size < this.availableRegs.size) {
      return true;
    }
    if (this.register === null && this.availableRegs.size > 0) {
      this.register = setPop(this.availableRegs);
      this.removeDependencyReg(this.register);
      return true;
    }
    return false;
  }
  removeDependencyReg(reg) {
    this.interferences.forEach((node) => {
      node.availableRegs.delete(reg);
    });
  }
  undoColor() {
    this.register = null;
    this.availableRegs = new Set(this.ogAvailableRegs);
  }
  removeDependencyNode(node) {
    this.interferences.delete(node);
  }
}
class WebBuilder {
  constructor(block, cfg, methodRegesKilled) {
    this.cfg = cfg;
    this.methodRegesKilled = methodRegesKilled;
    this.webMap = /* @__PURE__ */ new Map();
    this.exploredBlocks = /* @__PURE__ */ new Set();
    this.killedReges = /* @__PURE__ */ new Set();
    this.curmethod = block.label;
    this.buildWebs(block, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
    this.mergeWebs();
  }
  buildInterferenceNodes() {
    const interferenceGraph = new InterferenceGraph(this.webMap);
    this.killedReges = setUnion(
      this.killedReges,
      interferenceGraph.regesKilled
    );
    this.methodRegesKilled.set(this.curmethod, this.killedReges);
    return interferenceGraph.getInterferenceNodes();
  }
  getKilledReges() {
    return this.killedReges;
  }
  buildWebs(curBlock, liveWebs, exploredBlocks) {
    const previouslyExplored = exploredBlocks.has(curBlock.label);
    if (previouslyExplored) {
      liveWebs.forEach((web) => {
        const labelInstr = curBlock.instructions[0];
        web.add(labelInstr);
        web.potentialFlush();
        this.appendNewWeb(web);
      });
      return;
    }
    exploredBlocks.add(curBlock.label);
    curBlock.instructions.forEach((instr) => {
      if (instr instanceof CallInstruction) {
        this.handleCallKilledReges(instr);
      }
      liveWebs.forEach((web) => {
        const newWeb = web.add(instr);
        if (newWeb !== null) {
          this.appendNewWeb(web);
          liveWebs.set(newWeb.varName, newWeb);
          return;
        }
      });
      const dest = instr.getDest();
      if (dest && !liveWebs.has(dest) && !isArrayVariable(dest) && !this.cfg.isGlobalVariable(dest)) {
        liveWebs.set(dest, new Web(dest, [instr]));
      }
    });
    const successors = curBlock.getSuccessors();
    if (successors.length === 0) {
      liveWebs.forEach((web) => this.appendNewWeb(web));
      return;
    }
    if (successors.length === 1) {
      this.buildWebs(successors[0], liveWebs, exploredBlocks);
      return;
    }
    const dupLiveWebs = /* @__PURE__ */ new Map();
    liveWebs.forEach((web, varName) => {
      const dupWeb = web.duplicate();
      dupLiveWebs.set(varName, dupWeb);
    });
    this.buildWebs(successors[0], dupLiveWebs, exploredBlocks);
    this.buildWebs(successors[1], liveWebs, exploredBlocks);
  }
  handleCallKilledReges(callInstr) {
    const methodName = callInstr.methodName;
    if (!this.methodRegesKilled.has(methodName)) {
      this.killedReges = setUnion(this.killedReges, getLongCallerSavedRegs());
      return;
    }
    this.killedReges = setUnion(
      this.killedReges,
      this.methodRegesKilled.get(methodName)
    );
  }
  appendNewWeb(web) {
    const varName = web.varName;
    if (!this.webMap.has(varName)) {
      this.webMap.set(varName, []);
    }
    this.webMap.get(varName)?.push(web);
  }
  mergeWebs() {
    this.webMap.forEach((webs, varName) => {
      let skip = false;
      let curSize = this.webMap.get(varName)?.length;
      let changed = true;
      while (changed) {
        const mergedWebs = [];
        let websUsed = this.webMap.get(varName);
        websUsed.forEach((web, index) => {
          websUsed.forEach((otherWeb, otherIdx) => {
            if (skip || otherIdx === index) return;
            if (otherIdx < index) {
              const mergedWeb = otherWeb.union(web);
              if (mergedWeb) {
                skip = true;
              }
              return;
            }
            web.union(otherWeb);
          });
          if (!skip) {
            mergedWebs.push(web);
          }
          skip = false;
        });
        this.webMap.set(varName, mergedWebs);
        changed = curSize !== this.webMap.get(varName)?.length;
        curSize = this.webMap.get(varName)?.length;
      }
    });
  }
}
function irGen(webProgram) {
  const result = tokenize(webProgram);
  if (result.hasError) {
    const errors = [];
    for (const line of result.output) {
      if (line.includes("unexpected")) {
        errors.push("Lexical error at " + line);
      }
    }
    throw new Error(errors.join("\n"));
  }
  let hasError = webParse(webProgram);
  if (hasError.length > 0) {
    throw new Error(hasError.join("\n"));
  }
  try {
    const parsed = webAstParser(webProgram);
    const ir = new IrBuilder(parsed);
    const program = ir.buildProgram();
    const ir_building_error_messages = ir.getErrorMessages();
    const ir_checking_error_messages = new IrChecker(program, "").run();
    if (ir_building_error_messages.length > 0 || ir_checking_error_messages.length > 0) {
      const allErrors = [
        ...ir_building_error_messages,
        ...ir_checking_error_messages
      ];
      throw new Error(allErrors.join("\n"));
    }
    return program;
  } catch (error) {
    throw new Error(`Parsing syntax errors further down the tree: ${error}`);
  }
}
function removeAsmComments(code) {
  return code.split("\n").filter((line) => !line.startsWith(";") && !line.startsWith("#")).join("\n");
}
function compileWeb(inputCode) {
  try {
    const program = irGen(inputCode);
    const cfgBuilder = new ControlFlowGraph(program);
    const optimizer = new Optimizer(cfgBuilder, [...program.methods.values()]);
    const allOptimizations = [
      "cp",
      "cse",
      "dce",
      "algebra",
      "fold",
      "regalloc",
      "inline"
    ];
    const enabledOpts = new Set(allOptimizations);
    let cfg;
    if (enabledOpts.size === 0) {
      cfg = cfgBuilder.buildCFG();
    } else {
      optimizer.setOptimizationFlags({
        constantPropagation: enabledOpts.has("cp"),
        deadCodeElimination: enabledOpts.has("dce"),
        algebraicSimplification: enabledOpts.has("algebra"),
        commonSubexprElimination: enabledOpts.has("cse"),
        constantFolding: enabledOpts.has("fold"),
        loopOptimization: enabledOpts.has("loop"),
        inline: enabledOpts.has("inline")
      });
      cfg = optimizer.buildNodes();
    }
    const methodRegesKilled = /* @__PURE__ */ new Map();
    const asmHelper = new AsmHelper(methodRegesKilled);
    const importList = Array.from(program.imports.keys());
    const literalMap = program.stringLiteralMap;
    let programContent = asmHelper.buildProgramHeader(importList, literalMap, program.natives) + "\n";
    asmHelper.preLoadProgramMethods(Array.from(program.methods.values()));
    cfg.forEach((block, index) => {
      const method = program.methods.get(
        cfgBuilder.orderedMethods.at(index)
      );
      if (enabledOpts.has("regalloc")) {
        const initRegesKilled = getCallKilledReges(
          method.params.ordered_params.length
        );
        methodRegesKilled.set(method.method_name, new Set(initRegesKilled));
        const webBuilder = new WebBuilder(block, cfgBuilder, methodRegesKilled);
        webBuilder.buildInterferenceNodes();
        asmHelper.setWebMap(webBuilder.webMap);
      }
      programContent += asmHelper.buildMethodAsm(method, block);
    });
    const cleanAsm = removeAsmComments(programContent);
    const finalAsm = removeRedundantMoves(cleanAsm);
    return { success: true, assembly: finalAsm, errors: [] };
  } catch (error) {
    return { success: false, errors: [String(error)] };
  }
}
class WebCompiler {
  compile(code) {
    try {
      return compileWeb(code);
    } catch (error) {
      console.error("Compilation error:", error);
      return {
        success: false,
        assembly: "",
        errors: [error.message]
      };
    }
  }
}
class X86Interpreter {
  constructor() {
    this.registers = { rax: 0, rbx: 0, rcx: 0, rdx: 0, rsi: 0, rdi: 0, r8: 0, r9: 0, r10: 0, r11: 0, r12: 0 };
    this.memory = {};
    this.strings = {};
    this.output = "";
    this.stack = [];
    this.rbp = 1e3;
  }
  getRegisterValue(reg) {
    const regMap = {
      "eax": "rax",
      "ebx": "rbx",
      "ecx": "rcx",
      "edx": "rdx",
      "esi": "rsi",
      "edi": "rdi",
      "r8d": "r8",
      "r9d": "r9",
      "r10d": "r10",
      "r11d": "r11",
      "r12d": "r12"
    };
    const actualReg = regMap[reg] || reg;
    return this.registers[actualReg] || 0;
  }
  setRegisterValue(reg, value) {
    const regMap = {
      "eax": "rax",
      "ebx": "rbx",
      "ecx": "rcx",
      "edx": "rdx",
      "esi": "rsi",
      "edi": "rdi",
      "r8d": "r8",
      "r9d": "r9",
      "r10d": "r10",
      "r11d": "r11",
      "r12d": "r12"
    };
    const actualReg = regMap[reg] || reg;
    this.registers[actualReg] = value;
  }
  extractStringLiterals(assembly) {
    const stringMatches = assembly.match(/string_literal_\d+:\s*\.string\s*"([^"]+)"/g);
    if (stringMatches) {
      stringMatches.forEach((match) => {
        const labelMatch = match.match(/string_literal_(\d+):\s*\.string\s*"([^"]+)"/);
        if (labelMatch) {
          this.strings[`string_literal_${labelMatch[1]}`] = labelMatch[2];
        }
      });
    }
  }
  processInstruction(instruction) {
    const trimmed = instruction.trim();
    const leaStringMatch = trimmed.match(/lea\s+(string_literal_\d+)\(%rip\),\s*%(\w+)/);
    if (leaStringMatch) {
      this.registers.rdi = this.strings[leaStringMatch[1]] || leaStringMatch[1];
      return;
    }
    const leaArrayMatch = trimmed.match(/lea\s+(-?\d+)\(%rbp,%(\w+),(\d+)\),\s*%(\w+)/);
    if (leaArrayMatch) {
      const offset = parseInt(leaArrayMatch[1]);
      const indexValue = this.getRegisterValue(leaArrayMatch[2]);
      const scale = parseInt(leaArrayMatch[3]);
      const address = this.rbp + offset + indexValue * scale;
      this.setRegisterValue(leaArrayMatch[4], address);
      return;
    }
    const movImmMatch = trimmed.match(/movl\s+\$(\d+),\s*%(\w+)/);
    if (movImmMatch) {
      this.setRegisterValue(movImmMatch[2], parseInt(movImmMatch[1]));
      return;
    }
    const movRegMatch = trimmed.match(/movl\s+%(\w+),\s*%(\w+)/);
    if (movRegMatch) {
      this.setRegisterValue(movRegMatch[2], this.getRegisterValue(movRegMatch[1]));
      return;
    }
    const movRegToStackMatch = trimmed.match(/movl\s+%(\w+),\s*(-?\d+)\(%rbp\)/);
    if (movRegToStackMatch) {
      const value = this.getRegisterValue(movRegToStackMatch[1]);
      const offset = parseInt(movRegToStackMatch[2]);
      const address = this.rbp + offset;
      this.memory[address] = value;
      return;
    }
    const movStackToRegMatch = trimmed.match(/movl\s+(-?\d+)\(%rbp\),\s*%(\w+)/);
    if (movStackToRegMatch) {
      const offset = parseInt(movStackToRegMatch[1]);
      const address = this.rbp + offset;
      const value = this.memory[address] || 0;
      this.setRegisterValue(movStackToRegMatch[2], value);
      return;
    }
    const movMemToRegMatch = trimmed.match(/movl\s+\(%(\w+)\),\s*%(\w+)/);
    if (movMemToRegMatch) {
      const address = this.getRegisterValue(movMemToRegMatch[1]);
      const value = this.memory[address] || 0;
      this.setRegisterValue(movMemToRegMatch[2], value);
      return;
    }
    const movRegToMemMatch = trimmed.match(/movl\s+%(\w+),\s*\(%(\w+)\)/);
    if (movRegToMemMatch) {
      const value = this.getRegisterValue(movRegToMemMatch[1]);
      const address = this.getRegisterValue(movRegToMemMatch[2]);
      this.memory[address] = value;
      return;
    }
    const xorMatch = trimmed.match(/xorl\s+%(\w+),\s*%(\w+)/);
    if (xorMatch && xorMatch[1] === xorMatch[2]) {
      this.setRegisterValue(xorMatch[1], 0);
      return;
    }
    const addMatch = trimmed.match(/addl\s+%(\w+),\s*%(\w+)/);
    if (addMatch) {
      const val1 = this.getRegisterValue(addMatch[1]);
      const val2 = this.getRegisterValue(addMatch[2]);
      this.setRegisterValue(addMatch[2], val1 + val2);
      return;
    }
    if (trimmed === "call printf") {
      this.handlePrintf();
    }
  }
  handlePrintf() {
    const formatStr = this.registers.rdi;
    if (typeof formatStr === "string") {
      let output = formatStr;
      const args = [this.registers.rsi, this.registers.rdx, this.registers.rcx, this.registers.r8, this.registers.r9];
      let argIndex = 0;
      output = output.replace(/%d/g, () => {
        return argIndex < args.length ? args[argIndex++].toString() : "%d";
      });
      output = output.replace(/\\n/g, "\n");
      this.output += output;
    }
  }
  execute(assembly) {
    this.output = "";
    this.registers = { rax: 0, rbx: 0, rcx: 0, rdx: 0, rsi: 0, rdi: 0, r8: 0, r9: 0, r10: 0, r11: 0, r12: 0 };
    this.memory = {};
    this.strings = {};
    this.extractStringLiterals(assembly);
    const lines = assembly.split("\n").filter((line) => line.trim() && !line.includes(":") && !line.startsWith("."));
    for (const line of lines) {
      this.processInstruction(line);
    }
    return this.output || "Program executed (no output generated)";
  }
}
const Compiler = () => {
  const [inputCode, setInputCode] = reactExports.useState(`// Example Decaf program
// Example Decaf program
import printf;
void main() {
    int x[3];
    x[0] = 5;        // Error: using 'x' before declaration  
    printf("%d\\n",x[0]);
}
`);
  const [outputAssembly, setOutputAssembly] = reactExports.useState("");
  const [isCompiling, setIsCompiling] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [isRunning, setIsRunning] = reactExports.useState(false);
  const [executionOutput, setExecutionOutput] = reactExports.useState("");
  const interpreterRef = reactExports.useRef(new X86Interpreter());
  const compiler = new WebCompiler();
  const executeCode = async () => {
    if (!outputAssembly) {
      setError("Please compile code first");
      return;
    }
    setIsRunning(true);
    setExecutionOutput("");
    try {
      const result = interpreterRef.current.execute(outputAssembly);
      setExecutionOutput(result);
    } catch (err) {
      setError("Execution failed: " + err.message);
    } finally {
      setIsRunning(false);
    }
  };
  const compileCode = async () => {
    setIsCompiling(true);
    setError("");
    setOutputAssembly("");
    try {
      const result = compiler.compile(inputCode);
      if (result.success) {
        setOutputAssembly(result.assembly);
      } else {
        setError(result.errors.join("\n"));
      }
    } catch (err) {
      setError(err.message || "Compilation failed");
    } finally {
      setIsCompiling(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "compiler", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Decaf Compiler" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Interactive C-like language compiler built during MIT coursework. Enter your Decaf code below:" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "compiler-interface", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Input Code" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: "code-input",
            value: inputCode,
            onChange: (e2) => setInputCode(e2.target.value),
            placeholder: "Enter your Decaf code here...",
            rows: 15
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "compile-button",
            onClick: compileCode,
            disabled: isCompiling,
            children: isCompiling ? "Compiling..." : "Compile to Assembly"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "execute-button",
            onClick: executeCode,
            disabled: isRunning || !outputAssembly,
            children: isRunning ? "Running..." : "Execute x86 Code"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "output-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Generated Assembly" }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: "code-output",
            value: outputAssembly,
            readOnly: true,
            placeholder: "Assembly output will appear here...",
            rows: 15
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "execution-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Execution Output" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: "execution-output",
            value: executionOutput,
            readOnly: true,
            placeholder: "Program output will appear here...",
            rows: 8
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "compiler-info", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "About This Compiler" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "This is a simplified web version of my multi-phase Decaf compiler, featuring:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Lexical analysis and basic parsing" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Semantic analysis (simplified for web)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "x86-64 assembly code generation" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Error reporting and validation" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "Note: This is a simplified version for web demonstration. The full compiler includes advanced optimizations, control flow analysis, and complete language support." }) })
    ] })
  ] });
};
const Experimental = () => {
  const [code, setCode] = reactExports.useState("");
  const [output, setOutput] = reactExports.useState("");
  const handleCompile = () => {
    setOutput(`Compiled output:
${code}`);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "experimental", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Experimental" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "experimental-grid", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "experiment-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "AI Integration" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Exploring machine learning APIs" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "experiment-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "WebGL Graphics" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "3D rendering experiments" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "experiment-card compiler-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "TypeScript Compiler" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: code,
            onChange: (e2) => setCode(e2.target.value),
            placeholder: "Enter TypeScript code here...",
            rows: 8,
            style: { width: "100%", marginBottom: "10px" }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleCompile, style: { marginBottom: "10px" }, children: "Compile" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: output,
            readOnly: true,
            placeholder: "Output will appear here...",
            rows: 8,
            style: { width: "100%", backgroundColor: "#f5f5f5" }
          }
        )
      ] })
    ] })
  ] });
};
const Contact = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "contact", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Contact" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Let's connect! Feel free to reach out for collaboration opportunities, internships, or just to chat about technology and computer science." }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contact-info", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contact-item", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Email:" }),
      " ragoo@alum.mit.edu"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contact-item", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "University Address:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
      "189 Vassar St.",
      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
      "Cambridge, MA 02139"
    ] })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contact-links", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:ragoo@alum.mit.edu", children: "Email" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://github.com/rafinga", children: "GitHub" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://www.linkedin.com/in/rafael-gomez-433a19256/", children: "LinkedIn" })
  ] })
] });
function App() {
  const [darkMode, setDarkMode] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { darkMode, setDarkMode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/experience", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { darkMode, setDarkMode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Experience, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/projects", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { darkMode, setDarkMode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Projects, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/skills", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { darkMode, setDarkMode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skills, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/compiler", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { darkMode, setDarkMode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Compiler, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/experimental", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { darkMode, setDarkMode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Experimental, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/contact", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { darkMode, setDarkMode, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Contact, {}) }) })
  ] }) });
}
clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
